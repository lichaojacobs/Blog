<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>kylin master-slave同步原理及问题排查 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kylin master-slave同步原理及问题排查</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kylin master-slave同步原理及问题排查</h1><div class="post-meta">Jul 6, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2017/07/06/kylin-master-slave同步原理及问题排查/" href="/2017/07/06/kylin-master-slave同步原理及问题排查/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近俩个月，团队整个数据基础架构慢慢转移到kylin上面来。而kylin也不负众望，对于一些复杂的聚合查询响应速度远超于hive。随着数据量的上来，kylin的单体部署逐渐无法支撑大量的并行读写任务。于是，自然而然的考虑到kylin的读写分离。一写多读，正好也符合kylin官方文档上的cluster架构。然而在实际的使用中也出现了一些问题:</p>
<ul>
<li>主节点更新了schema而从节点未sync</li>
<li>从节点中部分sync成功，而不是全部</li>
</ul>
<p>而很明显的是kylin中所有的数据，包括所有元数据都是落地在HBase中的，那唯一导致节点间数据不一致的可能就只有各个节点都有本地缓存的情况了。为了理解原理方便debug，我对kylin master-slave的同步原理做了一些源代码层面的剖析。</p>
<h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><h4 id="主从配置方式"><a href="#主从配置方式" class="headerlink" title="主从配置方式"></a>主从配置方式</h4><p>关于配置的格式，不得不吐槽官方文档的滑水。并没有给出详细的节点配置格式，查阅相关源码才发现正确的配置格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//kylin.properties下面的配置，根据源码，配置的格式为：user:pwd@host:port</div><div class="line">kylin.server.cluster-servers=user:password@host:port,user:password@host:port,user:password@host:port</div></pre></td></tr></table></figure>
<h4 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h4><p><img src="http://ol7zjjc80.bkt.clouddn.com/master-slave-kylin.png" alt="流程解析"></p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><ul>
<li><p>先来看看整个同步机制的核心BroadCaster类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//Broadcaster的构造函数</div><div class="line">private Broadcaster(final KylinConfig config) &#123;</div><div class="line">      this.config = config;</div><div class="line">      //获取kylin.properties中&quot;kylin.server.cluster-servers&quot;配置的值</div><div class="line">      //也就是集群中所有节点的配置了</div><div class="line">      final String[] nodes = config.getRestServers();</div><div class="line">      if (nodes == null || nodes.length &lt; 1) &#123;</div><div class="line">          logger.warn(&quot;There is no available rest server; check the &apos;kylin.server.cluster-servers&apos; config&quot;);</div><div class="line">          broadcastEvents = null; // disable the broadcaster</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">      logger.debug(nodes.length + &quot; nodes in the cluster: &quot; + Arrays.toString(nodes));</div><div class="line"></div><div class="line">      //开一个单线程，不间断的循环从broadcastEvents队列里面获取注册的事件。</div><div class="line">      Executors.newSingleThreadExecutor(new DaemonThreadFactory()).execute(new Runnable() &#123;</div><div class="line">          @Override</div><div class="line">          public void run() &#123;</div><div class="line">              final List&lt;RestClient&gt; restClients = Lists.newArrayList();</div><div class="line">              for (String node : config.getRestServers()) &#123;</div><div class="line">                  //根据配置的节点信息注册RestClient</div><div class="line">                  restClients.add(new RestClient(node));</div><div class="line">              &#125;</div><div class="line">              final ExecutorService wipingCachePool = Executors.newFixedThreadPool(restClients.size(), new DaemonThreadFactory());</div><div class="line">              while (true) &#123;</div><div class="line">                  try &#123;</div><div class="line">                      final BroadcastEvent broadcastEvent = broadcastEvents.takeFirst();</div><div class="line">                      logger.info(&quot;Announcing new broadcast event: &quot; + broadcastEvent);</div><div class="line">                      for (final RestClient restClient : restClients) &#123;</div><div class="line">                          wipingCachePool.execute(new Runnable() &#123;</div><div class="line">                              @Override</div><div class="line">                              public void run() &#123;</div><div class="line">                                  try &#123;</div><div class="line">                                      restClient.wipeCache(broadcastEvent.getEntity(), broadcastEvent.getEvent(), broadcastEvent.getCacheKey());</div><div class="line">                                  &#125; catch (IOException e) &#123;</div><div class="line">                                      logger.warn(&quot;Thread failed during wipe cache at &quot; + broadcastEvent, e);</div><div class="line">                                  &#125;</div><div class="line">                              &#125;</div><div class="line">                          &#125;);</div><div class="line">                      &#125;</div><div class="line">                  &#125; catch (Exception e) &#123;</div><div class="line">                      logger.error(&quot;error running wiping&quot;, e);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过Broadcaster的构造函数其实就能清楚整个同步过程的大概逻辑了。无非就是启动一个线程去轮询阻塞队列里面的元素，有的话就消费下来广播到其他从节点从而达到清理缓存的目的。</p>
</li>
<li><p>再来看看广播的实际逻辑实现,基本封装在RestClient中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//此处是根据配置的节点信息正则匹配：&quot;user:pwd@host:port&quot;</div><div class="line">public RestClient(String uri) &#123;</div><div class="line">   Matcher m = fullRestPattern.matcher(uri);</div><div class="line">   if (!m.matches())</div><div class="line">       throw new IllegalArgumentException(&quot;URI: &quot; + uri + &quot; -- does not match pattern &quot; + fullRestPattern);</div><div class="line"></div><div class="line">   String user = m.group(1);</div><div class="line">   String pwd = m.group(2);</div><div class="line">   String host = m.group(3);</div><div class="line">   String portStr = m.group(4);</div><div class="line">   int port = Integer.parseInt(portStr == null ? &quot;7070&quot; : portStr);</div><div class="line"></div><div class="line">   init(host, port, user, pwd);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>根据配置的节点信息实例化RestClient，然后在init方法中，拼接wipe cache的url</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private void init(String host, int port, String userName, String password) &#123;</div><div class="line">  this.host = host;</div><div class="line">  this.port = port;</div><div class="line">  this.userName = userName;</div><div class="line">  this.password = password;</div><div class="line">  //拼接rest接口</div><div class="line">  this.baseUrl = &quot;http://&quot; + host + &quot;:&quot; + port + &quot;/kylin/api&quot;;</div><div class="line"></div><div class="line">  client = new DefaultHttpClient();</div><div class="line"></div><div class="line">  if (userName != null &amp;&amp; password != null) &#123;</div><div class="line">      CredentialsProvider provider = new BasicCredentialsProvider();</div><div class="line">      UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(userName, password);</div><div class="line">      provider.setCredentials(AuthScope.ANY, credentials);</div><div class="line">      client.setCredentialsProvider(provider);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现kylin所有的交互接口基本上底层都是调用的自己的rest接口，它自己所谓的jdbc的查询方式其实也只是在rest接口上封装了一层，底层还是http请求。可谓是挂羊头卖狗肉了。看看RestClient中怎么去通知其他节点wipe cache的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void wipeCache(String entity, String event, String cacheKey) throws IOException &#123;</div><div class="line">   String url = baseUrl + &quot;/cache/&quot; + entity + &quot;/&quot; + cacheKey + &quot;/&quot; + event;</div><div class="line">   HttpPut request = new HttpPut(url);</div><div class="line"></div><div class="line">   try &#123;</div><div class="line">       HttpResponse response = client.execute(request);</div><div class="line">       String msg = EntityUtils.toString(response.getEntity());</div><div class="line"></div><div class="line">       if (response.getStatusLine().getStatusCode() != 200)</div><div class="line">           throw new IOException(&quot;Invalid response &quot; + response.getStatusLine().getStatusCode() + &quot; with cache wipe url &quot; + url + &quot;\n&quot; + msg);</div><div class="line">   &#125; catch (Exception ex) &#123;</div><div class="line">       throw new IOException(ex);</div><div class="line">   &#125; finally &#123;</div><div class="line">       request.releaseConnection();</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>已经很明了了，就是调的rest接口：/kylin/api/cache/{entity}/{cacaheKey}/{event}</p>
</li>
<li><p>当slave节点接收到wipeCache的指令时的处理逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public void notifyMetadataChange(String entity, Event event, String cacheKey) throws IOException &#123;</div><div class="line">     Broadcaster broadcaster = Broadcaster.getInstance(getConfig());</div><div class="line"></div><div class="line">     //这里会判断当前节点是否注册为listener了，如果注册了，此逻辑会被ignored</div><div class="line">     broadcaster.registerListener(cacheSyncListener, &quot;cube&quot;);</div><div class="line"></div><div class="line">     broadcaster.notifyListener(entity, event, cacheKey);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> //注册listener的逻辑</div><div class="line"> public void registerListener(Listener listener, String... entities) &#123;</div><div class="line">  synchronized (CACHE) &#123;</div><div class="line">      // ignore re-registration</div><div class="line">      List&lt;Listener&gt; all = listenerMap.get(SYNC_ALL);</div><div class="line">      if (all != null &amp;&amp; all.contains(listener)) &#123;</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      for (String entity : entities) &#123;</div><div class="line">          if (!StringUtils.isBlank(entity))</div><div class="line">              addListener(entity, listener);</div><div class="line">      &#125;</div><div class="line">      //注册几种事件类型</div><div class="line">      addListener(SYNC_ALL, listener);</div><div class="line">      addListener(SYNC_PRJ_SCHEMA, listener);</div><div class="line">      addListener(SYNC_PRJ_DATA, listener);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>notifyListener主要就是对所有事件处理逻辑的划分，根据事件类型选择处理逻辑，一般sheme的更新走的是默认逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public void notifyListener(String entity, Event event, String cacheKey) throws IOException &#123;</div><div class="line">     synchronized (CACHE) &#123;</div><div class="line">         List&lt;Listener&gt; list = listenerMap.get(entity);</div><div class="line">         if (list == null)</div><div class="line">             return;</div><div class="line"></div><div class="line">         logger.debug(&quot;Broadcasting metadata change: entity=&quot; + entity + &quot;, event=&quot; + event + &quot;, cacheKey=&quot; + cacheKey + &quot;, listeners=&quot; + list);</div><div class="line"></div><div class="line">         // prevents concurrent modification exception</div><div class="line">         list = Lists.newArrayList(list);</div><div class="line">         switch (entity) &#123;</div><div class="line">         case SYNC_ALL:</div><div class="line">             for (Listener l : list) &#123;</div><div class="line">                 l.onClearAll(this);</div><div class="line">             &#125;</div><div class="line">             clearCache(); // clear broadcaster too in the end</div><div class="line">             break;</div><div class="line">         case SYNC_PRJ_SCHEMA:</div><div class="line">             ProjectManager.getInstance(config).clearL2Cache();</div><div class="line">             for (Listener l : list) &#123;</div><div class="line">                 l.onProjectSchemaChange(this, cacheKey);</div><div class="line">             &#125;</div><div class="line">             break;</div><div class="line">         case SYNC_PRJ_DATA:</div><div class="line">             ProjectManager.getInstance(config).clearL2Cache(); // cube&apos;s first becoming ready leads to schema change too</div><div class="line">             for (Listener l : list) &#123;</div><div class="line">                 l.onProjectDataChange(this, cacheKey);</div><div class="line">             &#125;</div><div class="line">             break;</div><div class="line">         //大部分的走向</div><div class="line">         default:</div><div class="line">             for (Listener l : list) &#123;</div><div class="line">                 l.onEntityChange(this, entity, event, cacheKey);</div><div class="line">             &#125;</div><div class="line">             break;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         logger.debug(&quot;Done broadcasting metadata change: entity=&quot; + entity + &quot;, event=&quot; + event + &quot;, cacheKey=&quot; + cacheKey);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看到default分支会执行onEntityChange这个方法，看一下这个方法干的是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private Broadcaster.Listener cacheSyncListener = new Broadcaster.Listener() &#123;</div><div class="line">   @Override</div><div class="line">   public void onClearAll(Broadcaster broadcaster) throws IOException &#123;</div><div class="line">       removeAllOLAPDataSources();</div><div class="line">       cleanAllDataCache();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void onProjectSchemaChange(Broadcaster broadcaster, String project) throws IOException &#123;</div><div class="line">       removeOLAPDataSource(project);</div><div class="line">       cleanDataCache(project);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void onProjectDataChange(Broadcaster broadcaster, String project) throws IOException &#123;</div><div class="line">       removeOLAPDataSource(project); // data availability (cube enabled/disabled) affects exposed schema to SQL</div><div class="line">       cleanDataCache(project);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void onEntityChange(Broadcaster broadcaster, String entity, Event event, String cacheKey) throws IOException &#123;</div><div class="line">       if (&quot;cube&quot;.equals(entity) &amp;&amp; event == Event.UPDATE) &#123;</div><div class="line">           final String cubeName = cacheKey;</div><div class="line">           new Thread() &#123; // do not block the event broadcast thread</div><div class="line">               public void run() &#123;</div><div class="line">                   try &#123;</div><div class="line">                       Thread.sleep(1000);</div><div class="line">                       cubeService.updateOnNewSegmentReady(cubeName);</div><div class="line">                   &#125; catch (Throwable ex) &#123;</div><div class="line">                       logger.error(&quot;Error in updateOnNewSegmentReady()&quot;, ex);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;.start();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>看到对于cache的同步是单独实现了一个listener的，Event为update的时候，会单独启动一个线程去执行刷新缓存操作</p>
</li>
</ul>
<h3 id="加入简单的重试逻辑"><a href="#加入简单的重试逻辑" class="headerlink" title="加入简单的重试逻辑"></a>加入简单的重试逻辑</h3><p>由于目前对于同步失败的猜想是目标服务短暂不可用（响应超时或者处于失败重启阶段），于是我只是单纯的将失败的任务重新塞入broadcastEvents队列尾部供再一次调用。当然这种操作过于草率和暴力，却也是验证猜想最简单快速的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for (final RestClient restClient : restClients) &#123;</div><div class="line">           wipingCachePool.execute(new Runnable() &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">               try &#123;</div><div class="line">                 restClient.wipeCache(broadcastEvent.getEntity(), broadcastEvent.getEvent(),</div><div class="line">                     broadcastEvent.getCacheKey());</div><div class="line">               &#125; catch (IOException e) &#123;</div><div class="line">                 logger</div><div class="line">                     .warn(&quot;Thread failed during wipe cache at &#123;&#125;, error msg: &#123;&#125;&quot;, broadcastEvent,</div><div class="line">                         e.getMessage());</div><div class="line">                 try &#123;</div><div class="line">                   //这里重新塞入队列尾部，等待重新执行</div><div class="line">                   broadcastEvents.putLast(broadcastEvent);</div><div class="line">                   logger.info(&quot;put failed broadcastEvent to queue. broacastEvent: &#123;&#125;&quot;,</div><div class="line">                       broadcastEvent);</div><div class="line">                 &#125; catch (InterruptedException ex) &#123;</div><div class="line">                   logger.warn(&quot;error reentry failed broadcastEvent to queue, broacastEvent:&#123;&#125;, error: &#123;&#125; &quot;,</div><div class="line">                       broadcastEvent, ex);</div><div class="line">                 &#125;</div><div class="line">               &#125;</div><div class="line">             &#125;</div><div class="line">           &#125;);</div><div class="line">         &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>编译部署之后，日志中出现了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread failed during wipe cache at java.lang.IllegalStateException: Invalid use of BasicClientConnManager: connection still allocated.</div></pre></td></tr></table></figure>
<p>比较意外，不过也终于发现了问题的所在。Kylin在启动的时候会按照配置的nodes实例化一次RestClient，之后就直接从缓存中拿了，而kylin用的DefaultHttpClient每次只允许一次请求，请求完必须释放链接，否则无法复用HttpClient。所以需要修改wipeCache方法的逻辑如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void wipeCache(String entity, String event, String cacheKey) throws IOException &#123;</div><div class="line">    String url = baseUrl + &quot;/cache/&quot; + entity + &quot;/&quot; + cacheKey + &quot;/&quot; + event;</div><div class="line">    HttpPut request = new HttpPut(url);</div><div class="line"></div><div class="line">    HttpResponse response =null;</div><div class="line">    try &#123;</div><div class="line">        response = client.execute(request);</div><div class="line">        String msg = EntityUtils.toString(response.getEntity());</div><div class="line"></div><div class="line">        if (response.getStatusLine().getStatusCode() != 200)</div><div class="line">            throw new IOException(&quot;Invalid response &quot; + response.getStatusLine().getStatusCode() + &quot; with cache wipe url &quot; + url + &quot;\n&quot; + msg);</div><div class="line">    &#125; catch (Exception ex) &#123;</div><div class="line">        throw new IOException(ex);</div><div class="line">    &#125; finally &#123;</div><div class="line">        //确保释放连接</div><div class="line">        if(response!=null) &#123;</div><div class="line">          EntityUtils.consume(response.getEntity());</div><div class="line">        &#125;</div><div class="line">        request.releaseConnection();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://ol7zjjc80.bkt.clouddn.com/271524552778_.pic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/07/06/kylin-master-slave同步原理及问题排查/" data-id="cjgj0ldc8000max46tzkrqsf0" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvklEQVR42u3awW7rMAwEwP7/T7fAOz2gtbNLmW0Oo1OR1JZGASSC5MdHPD7/jftP2m//H9+fuv/24YGHh4c3WvrVuJr4CvP92au57j/PZ7laMx4eHt427/5wv1/W/YJyUj578hQeHh7eO/BOniqO8jL4xsPDw3tnXgvOF9deIXh4eHjvwEuSEScTt1dIskEP51rw8PDwJhHsA0v5nb8X63t4eHh4B1X1NmXQJmfzcHy4Wjw8PLwF3ixFO0tSzNINeYh/+QPg4eHhLfDyYDqPWmcBentJ5O/Ew8PDe4qXh8InYXHeRpBsYnF14eHh4a3xkmA3KYO1y5qVyoorBA8PD2+N1x7lJ8X+8yRFsTV4eHh4y7y8pJRvQZv8nRXPLmfHw8PDW+C1BbDodaNyVH4lJNsxbB3Aw8PDC3izayAJjvOtyYPmdlV4eHh4G7z8uG8TE23DQZ5DOGl0wMPDwzvnPZWMaItkn+XIkxEraVw8PDy8uFqU/8/s2TaMnq0ZDw8Pb5uXH9/nrQZtM0GeOH6Rd8HDw8M74OUl/JPP20O8DdkvExZ4eHh4C7xZE0CShM2D7Nn7i4QvHh4e3hovT4y2YfdTbQrttYSHh4e3wZuV7dugtr0kZomP6HfDw8PDe4iXF6KebSPYZuPh4eHt8Wavu19c++2Lwv+o7RUPDw/vr3h5F9NJQev8evhhRjw8PLwF3iyV0Bau8gC6LZhFPwYeHh7eo7w2WdA2DeThdVuEi7YGDw8Pb5mXjLztadZkcNIo8OJiwMPDw3uINztw21RCcrUctQicDzw8PLySt3Fkz96WB99FuI+Hh4e3xssLV23DQfv+WYHtcmvw8PDw/pSXpxjypG2bFG63Hg8PD+89ebNkweyyaVPJeHh4eHu85HVtuevZLZg1ZuHh4eFt8GYFsHxxbXi9UsHDw8PDe4b3BSP7Ayf2p0U7AAAAAElFTkSuQmCC" class="article-share-link">分享</a><div class="tags"><a href="/tags/成长/">成长</a><a href="/tags/infrastructure/">infrastructure</a><a href="/tags/源码/">源码</a><a href="/tags/Kylin/">Kylin</a></div><div class="post-nav"><a href="/2017/08/07/Kylin二次开发——测试环境搭建/" class="pre">Kylin二次开发——测试环境搭建</a><a href="/2017/06/25/HBase架构脑图/" class="next">HBase架构脑图</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'https://jacobs-wanhb.disqus.com/embed.js';
var disqus_identifier = '2017/07/06/kylin-master-slave同步原理及问题排查/';
var disqus_title = 'kylin master-slave同步原理及问题排查';
var disqus_url = 'http://yoursite.com/2017/07/06/kylin-master-slave同步原理及问题排查/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//https://jacobs-wanhb.disqus.com/embed.js.disqus.com/count.js" async></script></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/okhttp-support-100-continue-for-palo/">okhttp support 307 redirect for palo</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/JVM知识总结/">JVM知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/kylin-query原理剖析/">kylin query原理剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/superset-customization/">superset customization</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/23/lombok-builder-泛型擦除问题/">lombok builder 泛型擦除</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Kylin二次开发——测试环境搭建/">Kylin二次开发——测试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/kylin-master-slave同步原理及问题排查/">kylin master-slave同步原理及问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/HBase架构脑图/">HBase架构脑图</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/02/Kylin学习笔记/">Kylin学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/11/Spark学习笔记/">Spark学习笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//https://jacobs-wanhb.disqus.com/embed.js.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/chao-li-11/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://weibo.com/3101672623/profile?topnav=1&amp;wvr=6" title="微博" target="_blank">微博</a><ul></ul><a href="https://github.com/lichaojacobs" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>