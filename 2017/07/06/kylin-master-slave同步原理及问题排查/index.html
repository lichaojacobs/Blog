<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>kylin master-slave同步原理及问题排查 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kylin master-slave同步原理及问题排查</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kylin master-slave同步原理及问题排查</h1><div class="post-meta">Jul 6, 2017<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近俩个月，团队整个数据基础架构慢慢转移到kylin上面来。而kylin也不负众望，对于一些复杂的聚合查询响应速度远超于hive。随着数据量的上来，kylin的单体部署逐渐无法支撑大量的并行读写任务。于是，自然而然的考虑到kylin的读写分离。一写多读，正好也符合kylin官方文档上的cluster架构。然而在实际的使用中也出现了一些问题:</p>
<ul>
<li>主节点更新了schema而从节点未sync</li>
<li>从节点中部分sync成功，而不是全部</li>
</ul>
<p>而很明显的是kylin中所有的数据，包括所有元数据都是落地在HBase中的，那唯一导致节点间数据不一致的可能就只有各个节点都有本地缓存的情况了。为了理解原理方便debug，我对kylin master-slave的同步原理做了一些源代码层面的剖析。</p>
<h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><h4 id="主从配置方式"><a href="#主从配置方式" class="headerlink" title="主从配置方式"></a>主从配置方式</h4><p>关于配置的格式，不得不吐槽官方文档的滑水。并没有给出详细的节点配置格式，查阅相关源码才发现正确的配置格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//kylin.properties下面的配置，根据源码，配置的格式为：user:pwd@host:port</span><br><span class="line">kylin.server.cluster-servers=user:password@host:port,user:password@host:port,user:password@host:port</span><br></pre></td></tr></table></figure>
<h4 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h4><p><img src="http://imgs.wanhb.cn/master-slave-kylin.png" alt="流程解析"></p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><ul>
<li><p>先来看看整个同步机制的核心BroadCaster类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//Broadcaster的构造函数</span><br><span class="line">private Broadcaster(final KylinConfig config) &#123;</span><br><span class="line">      this.config = config;</span><br><span class="line">      //获取kylin.properties中&quot;kylin.server.cluster-servers&quot;配置的值</span><br><span class="line">      //也就是集群中所有节点的配置了</span><br><span class="line">      final String[] nodes = config.getRestServers();</span><br><span class="line">      if (nodes == null || nodes.length &lt; 1) &#123;</span><br><span class="line">          logger.warn(&quot;There is no available rest server; check the &apos;kylin.server.cluster-servers&apos; config&quot;);</span><br><span class="line">          broadcastEvents = null; // disable the broadcaster</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      logger.debug(nodes.length + &quot; nodes in the cluster: &quot; + Arrays.toString(nodes));</span><br><span class="line"></span><br><span class="line">      //开一个单线程，不间断的循环从broadcastEvents队列里面获取注册的事件。</span><br><span class="line">      Executors.newSingleThreadExecutor(new DaemonThreadFactory()).execute(new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              final List&lt;RestClient&gt; restClients = Lists.newArrayList();</span><br><span class="line">              for (String node : config.getRestServers()) &#123;</span><br><span class="line">                  //根据配置的节点信息注册RestClient</span><br><span class="line">                  restClients.add(new RestClient(node));</span><br><span class="line">              &#125;</span><br><span class="line">              final ExecutorService wipingCachePool = Executors.newFixedThreadPool(restClients.size(), new DaemonThreadFactory());</span><br><span class="line">              while (true) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      final BroadcastEvent broadcastEvent = broadcastEvents.takeFirst();</span><br><span class="line">                      logger.info(&quot;Announcing new broadcast event: &quot; + broadcastEvent);</span><br><span class="line">                      for (final RestClient restClient : restClients) &#123;</span><br><span class="line">                          wipingCachePool.execute(new Runnable() &#123;</span><br><span class="line">                              @Override</span><br><span class="line">                              public void run() &#123;</span><br><span class="line">                                  try &#123;</span><br><span class="line">                                      restClient.wipeCache(broadcastEvent.getEntity(), broadcastEvent.getEvent(), broadcastEvent.getCacheKey());</span><br><span class="line">                                  &#125; catch (IOException e) &#123;</span><br><span class="line">                                      logger.warn(&quot;Thread failed during wipe cache at &quot; + broadcastEvent, e);</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                      logger.error(&quot;error running wiping&quot;, e);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过Broadcaster的构造函数其实就能清楚整个同步过程的大概逻辑了。无非就是启动一个线程去轮询阻塞队列里面的元素，有的话就消费下来广播到其他从节点从而达到清理缓存的目的。</p>
</li>
<li><p>再来看看广播的实际逻辑实现,基本封装在RestClient中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//此处是根据配置的节点信息正则匹配：&quot;user:pwd@host:port&quot;</span><br><span class="line">public RestClient(String uri) &#123;</span><br><span class="line">   Matcher m = fullRestPattern.matcher(uri);</span><br><span class="line">   if (!m.matches())</span><br><span class="line">       throw new IllegalArgumentException(&quot;URI: &quot; + uri + &quot; -- does not match pattern &quot; + fullRestPattern);</span><br><span class="line"></span><br><span class="line">   String user = m.group(1);</span><br><span class="line">   String pwd = m.group(2);</span><br><span class="line">   String host = m.group(3);</span><br><span class="line">   String portStr = m.group(4);</span><br><span class="line">   int port = Integer.parseInt(portStr == null ? &quot;7070&quot; : portStr);</span><br><span class="line"></span><br><span class="line">   init(host, port, user, pwd);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>根据配置的节点信息实例化RestClient，然后在init方法中，拼接wipe cache的url</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void init(String host, int port, String userName, String password) &#123;</span><br><span class="line">  this.host = host;</span><br><span class="line">  this.port = port;</span><br><span class="line">  this.userName = userName;</span><br><span class="line">  this.password = password;</span><br><span class="line">  //拼接rest接口</span><br><span class="line">  this.baseUrl = &quot;http://&quot; + host + &quot;:&quot; + port + &quot;/kylin/api&quot;;</span><br><span class="line"></span><br><span class="line">  client = new DefaultHttpClient();</span><br><span class="line"></span><br><span class="line">  if (userName != null &amp;&amp; password != null) &#123;</span><br><span class="line">      CredentialsProvider provider = new BasicCredentialsProvider();</span><br><span class="line">      UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(userName, password);</span><br><span class="line">      provider.setCredentials(AuthScope.ANY, credentials);</span><br><span class="line">      client.setCredentialsProvider(provider);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现kylin所有的交互接口基本上底层都是调用的自己的rest接口，它自己所谓的jdbc的查询方式其实也只是在rest接口上封装了一层，底层还是http请求。可谓是挂羊头卖狗肉了。看看RestClient中怎么去通知其他节点wipe cache的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void wipeCache(String entity, String event, String cacheKey) throws IOException &#123;</span><br><span class="line">   String url = baseUrl + &quot;/cache/&quot; + entity + &quot;/&quot; + cacheKey + &quot;/&quot; + event;</span><br><span class="line">   HttpPut request = new HttpPut(url);</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">       HttpResponse response = client.execute(request);</span><br><span class="line">       String msg = EntityUtils.toString(response.getEntity());</span><br><span class="line"></span><br><span class="line">       if (response.getStatusLine().getStatusCode() != 200)</span><br><span class="line">           throw new IOException(&quot;Invalid response &quot; + response.getStatusLine().getStatusCode() + &quot; with cache wipe url &quot; + url + &quot;\n&quot; + msg);</span><br><span class="line">   &#125; catch (Exception ex) &#123;</span><br><span class="line">       throw new IOException(ex);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       request.releaseConnection();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>已经很明了了，就是调的rest接口：/kylin/api/cache/{entity}/{cacaheKey}/{event}</p>
</li>
<li><p>当slave节点接收到wipeCache的指令时的处理逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void notifyMetadataChange(String entity, Event event, String cacheKey) throws IOException &#123;</span><br><span class="line">     Broadcaster broadcaster = Broadcaster.getInstance(getConfig());</span><br><span class="line"></span><br><span class="line">     //这里会判断当前节点是否注册为listener了，如果注册了，此逻辑会被ignored</span><br><span class="line">     broadcaster.registerListener(cacheSyncListener, &quot;cube&quot;);</span><br><span class="line"></span><br><span class="line">     broadcaster.notifyListener(entity, event, cacheKey);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //注册listener的逻辑</span><br><span class="line"> public void registerListener(Listener listener, String... entities) &#123;</span><br><span class="line">  synchronized (CACHE) &#123;</span><br><span class="line">      // ignore re-registration</span><br><span class="line">      List&lt;Listener&gt; all = listenerMap.get(SYNC_ALL);</span><br><span class="line">      if (all != null &amp;&amp; all.contains(listener)) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (String entity : entities) &#123;</span><br><span class="line">          if (!StringUtils.isBlank(entity))</span><br><span class="line">              addListener(entity, listener);</span><br><span class="line">      &#125;</span><br><span class="line">      //注册几种事件类型</span><br><span class="line">      addListener(SYNC_ALL, listener);</span><br><span class="line">      addListener(SYNC_PRJ_SCHEMA, listener);</span><br><span class="line">      addListener(SYNC_PRJ_DATA, listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>notifyListener主要就是对所有事件处理逻辑的划分，根据事件类型选择处理逻辑，一般sheme的更新走的是默认逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void notifyListener(String entity, Event event, String cacheKey) throws IOException &#123;</span><br><span class="line">     synchronized (CACHE) &#123;</span><br><span class="line">         List&lt;Listener&gt; list = listenerMap.get(entity);</span><br><span class="line">         if (list == null)</span><br><span class="line">             return;</span><br><span class="line"></span><br><span class="line">         logger.debug(&quot;Broadcasting metadata change: entity=&quot; + entity + &quot;, event=&quot; + event + &quot;, cacheKey=&quot; + cacheKey + &quot;, listeners=&quot; + list);</span><br><span class="line"></span><br><span class="line">         // prevents concurrent modification exception</span><br><span class="line">         list = Lists.newArrayList(list);</span><br><span class="line">         switch (entity) &#123;</span><br><span class="line">         case SYNC_ALL:</span><br><span class="line">             for (Listener l : list) &#123;</span><br><span class="line">                 l.onClearAll(this);</span><br><span class="line">             &#125;</span><br><span class="line">             clearCache(); // clear broadcaster too in the end</span><br><span class="line">             break;</span><br><span class="line">         case SYNC_PRJ_SCHEMA:</span><br><span class="line">             ProjectManager.getInstance(config).clearL2Cache();</span><br><span class="line">             for (Listener l : list) &#123;</span><br><span class="line">                 l.onProjectSchemaChange(this, cacheKey);</span><br><span class="line">             &#125;</span><br><span class="line">             break;</span><br><span class="line">         case SYNC_PRJ_DATA:</span><br><span class="line">             ProjectManager.getInstance(config).clearL2Cache(); // cube&apos;s first becoming ready leads to schema change too</span><br><span class="line">             for (Listener l : list) &#123;</span><br><span class="line">                 l.onProjectDataChange(this, cacheKey);</span><br><span class="line">             &#125;</span><br><span class="line">             break;</span><br><span class="line">         //大部分的走向</span><br><span class="line">         default:</span><br><span class="line">             for (Listener l : list) &#123;</span><br><span class="line">                 l.onEntityChange(this, entity, event, cacheKey);</span><br><span class="line">             &#125;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         logger.debug(&quot;Done broadcasting metadata change: entity=&quot; + entity + &quot;, event=&quot; + event + &quot;, cacheKey=&quot; + cacheKey);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>看到default分支会执行onEntityChange这个方法，看一下这个方法干的是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private Broadcaster.Listener cacheSyncListener = new Broadcaster.Listener() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void onClearAll(Broadcaster broadcaster) throws IOException &#123;</span><br><span class="line">       removeAllOLAPDataSources();</span><br><span class="line">       cleanAllDataCache();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onProjectSchemaChange(Broadcaster broadcaster, String project) throws IOException &#123;</span><br><span class="line">       removeOLAPDataSource(project);</span><br><span class="line">       cleanDataCache(project);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onProjectDataChange(Broadcaster broadcaster, String project) throws IOException &#123;</span><br><span class="line">       removeOLAPDataSource(project); // data availability (cube enabled/disabled) affects exposed schema to SQL</span><br><span class="line">       cleanDataCache(project);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onEntityChange(Broadcaster broadcaster, String entity, Event event, String cacheKey) throws IOException &#123;</span><br><span class="line">       if (&quot;cube&quot;.equals(entity) &amp;&amp; event == Event.UPDATE) &#123;</span><br><span class="line">           final String cubeName = cacheKey;</span><br><span class="line">           new Thread() &#123; // do not block the event broadcast thread</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       Thread.sleep(1000);</span><br><span class="line">                       cubeService.updateOnNewSegmentReady(cubeName);</span><br><span class="line">                   &#125; catch (Throwable ex) &#123;</span><br><span class="line">                       logger.error(&quot;Error in updateOnNewSegmentReady()&quot;, ex);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;.start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>看到对于cache的同步是单独实现了一个listener的，Event为update的时候，会单独启动一个线程去执行刷新缓存操作</p>
</li>
</ul>
<h3 id="加入简单的重试逻辑"><a href="#加入简单的重试逻辑" class="headerlink" title="加入简单的重试逻辑"></a>加入简单的重试逻辑</h3><p>由于目前对于同步失败的猜想是目标服务短暂不可用（响应超时或者处于失败重启阶段），于是我只是单纯的将失败的任务重新塞入broadcastEvents队列尾部供再一次调用。当然这种操作过于草率和暴力，却也是验证猜想最简单快速的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for (final RestClient restClient : restClients) &#123;</span><br><span class="line">           wipingCachePool.execute(new Runnable() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public void run() &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                 restClient.wipeCache(broadcastEvent.getEntity(), broadcastEvent.getEvent(),</span><br><span class="line">                     broadcastEvent.getCacheKey());</span><br><span class="line">               &#125; catch (IOException e) &#123;</span><br><span class="line">                 logger</span><br><span class="line">                     .warn(&quot;Thread failed during wipe cache at &#123;&#125;, error msg: &#123;&#125;&quot;, broadcastEvent,</span><br><span class="line">                         e.getMessage());</span><br><span class="line">                 try &#123;</span><br><span class="line">                   //这里重新塞入队列尾部，等待重新执行</span><br><span class="line">                   broadcastEvents.putLast(broadcastEvent);</span><br><span class="line">                   logger.info(&quot;put failed broadcastEvent to queue. broacastEvent: &#123;&#125;&quot;,</span><br><span class="line">                       broadcastEvent);</span><br><span class="line">                 &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                   logger.warn(&quot;error reentry failed broadcastEvent to queue, broacastEvent:&#123;&#125;, error: &#123;&#125; &quot;,</span><br><span class="line">                       broadcastEvent, ex);</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>编译部署之后，日志中出现了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread failed during wipe cache at java.lang.IllegalStateException: Invalid use of BasicClientConnManager: connection still allocated.</span><br></pre></td></tr></table></figure>
<p>比较意外，不过也终于发现了问题的所在。Kylin在启动的时候会按照配置的nodes实例化一次RestClient，之后就直接从缓存中拿了，而kylin用的DefaultHttpClient每次只允许一次请求，请求完必须释放链接，否则无法复用HttpClient。所以需要修改wipeCache方法的逻辑如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void wipeCache(String entity, String event, String cacheKey) throws IOException &#123;</span><br><span class="line">    String url = baseUrl + &quot;/cache/&quot; + entity + &quot;/&quot; + cacheKey + &quot;/&quot; + event;</span><br><span class="line">    HttpPut request = new HttpPut(url);</span><br><span class="line"></span><br><span class="line">    HttpResponse response =null;</span><br><span class="line">    try &#123;</span><br><span class="line">        response = client.execute(request);</span><br><span class="line">        String msg = EntityUtils.toString(response.getEntity());</span><br><span class="line"></span><br><span class="line">        if (response.getStatusLine().getStatusCode() != 200)</span><br><span class="line">            throw new IOException(&quot;Invalid response &quot; + response.getStatusLine().getStatusCode() + &quot; with cache wipe url &quot; + url + &quot;\n&quot; + msg);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        throw new IOException(ex);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //确保释放连接</span><br><span class="line">        if(response!=null) &#123;</span><br><span class="line">          EntityUtils.consume(response.getEntity());</span><br><span class="line">        &#125;</span><br><span class="line">        request.releaseConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://ol7zjjc80.bkt.clouddn.com/271524552778_.pic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/07/06/kylin-master-slave同步原理及问题排查/" data-id="cjwpxrfji000lt69kgnw280oc" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvklEQVR42u3awW7rMAwEwP7/T7fAOz2gtbNLmW0Oo1OR1JZGASSC5MdHPD7/jftP2m//H9+fuv/24YGHh4c3WvrVuJr4CvP92au57j/PZ7laMx4eHt427/5wv1/W/YJyUj578hQeHh7eO/BOniqO8jL4xsPDw3tnXgvOF9deIXh4eHjvwEuSEScTt1dIskEP51rw8PDwJhHsA0v5nb8X63t4eHh4B1X1NmXQJmfzcHy4Wjw8PLwF3ixFO0tSzNINeYh/+QPg4eHhLfDyYDqPWmcBentJ5O/Ew8PDe4qXh8InYXHeRpBsYnF14eHh4a3xkmA3KYO1y5qVyoorBA8PD2+N1x7lJ8X+8yRFsTV4eHh4y7y8pJRvQZv8nRXPLmfHw8PDW+C1BbDodaNyVH4lJNsxbB3Aw8PDC3izayAJjvOtyYPmdlV4eHh4G7z8uG8TE23DQZ5DOGl0wMPDwzvnPZWMaItkn+XIkxEraVw8PDy8uFqU/8/s2TaMnq0ZDw8Pb5uXH9/nrQZtM0GeOH6Rd8HDw8M74OUl/JPP20O8DdkvExZ4eHh4C7xZE0CShM2D7Nn7i4QvHh4e3hovT4y2YfdTbQrttYSHh4e3wZuV7dugtr0kZomP6HfDw8PDe4iXF6KebSPYZuPh4eHt8Wavu19c++2Lwv+o7RUPDw/vr3h5F9NJQev8evhhRjw8PLwF3iyV0Bau8gC6LZhFPwYeHh7eo7w2WdA2DeThdVuEi7YGDw8Pb5mXjLztadZkcNIo8OJiwMPDw3uINztw21RCcrUctQicDzw8PLySt3Fkz96WB99FuI+Hh4e3xssLV23DQfv+WYHtcmvw8PDw/pSXpxjypG2bFG63Hg8PD+89ebNkweyyaVPJeHh4eHu85HVtuevZLZg1ZuHh4eFt8GYFsHxxbXi9UsHDw8PDe4b3BSP7Ayf2p0U7AAAAAElFTkSuQmCC" class="article-share-link">分享</a><div class="tags"><a href="/tags/成长/">成长</a><a href="/tags/infrastructure/">infrastructure</a><a href="/tags/Kylin/">Kylin</a><a href="/tags/源码/">源码</a></div><div class="post-nav"><a href="/2017/08/07/Kylin二次开发——测试环境搭建/" class="pre">Kylin二次开发——测试环境搭建</a><a href="/2017/06/25/HBase架构脑图/" class="next">HBase架构脑图</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/">【Spark源码分析】Job提交执行过程详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/【Spark源码分析】Broadcast/">【Spark源码分析】Broadcast</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/【Spark源码分析】Dynamic-Resource-Allocation设计的思考/">【Spark源码分析】Dynamic Resource Allocation设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/Raft论文学习/">Raft论文学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/12/【spark-tips】spark2-4-0触发的executor内存溢出排查/">【spark-tips】spark2.4.0触发的executor内存溢出排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/20/Flink实战总结/">Flink实战总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/Spark学习笔记/">Spark实战总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/airflow实战总结/">airflow实战总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/12/impala集群搭建/">impala集群搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/okhttp-support-100-continue-for-palo/">okhttp support 100-continue for palo</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/chao-li-11/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://weibo.com/3101672623/profile?topnav=1&amp;wvr=6" title="微博" target="_blank">微博</a><ul></ul><a href="https://github.com/lichaojacobs" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>