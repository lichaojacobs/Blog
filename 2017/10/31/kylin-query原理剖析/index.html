<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>kylin query原理剖析 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kylin query原理剖析</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kylin query原理剖析</h1><div class="post-meta">Oct 31, 2017<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近我们组负责数据建模的同学抱怨kylin的relization选择策略：同一个project下一条查询语句本来期望命中某一个cube的，结果系统却选择了其他cube。之前也有大概翻阅过kylin这块的实现源码，知道如果同一个project下如果有多个满足条件的的实现，会按照成本排序并选择成本最低的那个实现。对于成本这块的度量标准，没有做过多研究，于是带着问题，对这块源码进行了一次梳理。</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>为使博文简洁相关实现只贴部分核心代码，以下所指的Realization对应于构建好的Cube。</p>
<h4 id="查询入口"><a href="#查询入口" class="headerlink" title="查询入口"></a>查询入口</h4><ul>
<li>QueryService.doQueryWithCache()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> //kylin.query.cache-enabled是否开启，如果开启将会从cache里面去读结果</span><br><span class="line"> if (queryCacheEnabled) &#123;</span><br><span class="line">	sqlResponse = searchQueryInCache(sqlRequest);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> try &#123;</span><br><span class="line">if (null == sqlResponse) &#123;</span><br><span class="line">	if (isSelect) &#123;</span><br><span class="line">		//查询入口</span><br><span class="line">		sqlResponse = query(sqlRequest);</span><br><span class="line">	&#125; else if (kylinConfig.isPushDownEnabled() &amp;&amp; kylinConfig.isPushDownUpdateEnabled()) &#123;</span><br><span class="line">		//如果开启了pushDown的话允许非查询的sql，如update</span><br><span class="line">		sqlResponse = update(sqlRequest);</span><br><span class="line">	&#125; else &#123;	</span><br><span class="line">		logger.debug(&quot;Directly return exception as the sql is unsupported, and query pushdown is disabled&quot;);</span><br><span class="line">                       throw new BadRequestException(msg.getNOT_SUPPORTED_SQL());</span><br><span class="line">			&#125;</span><br><span class="line"> ...</span><br><span class="line"> catch()&#123;</span><br><span class="line"> 	...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们忽略从缓存中查找（searchQueryInCache），以及非select查询的情况，单单从一次正常的查询进行分析，进入query方法。</p>
<ul>
<li>QueryService.query()</li>
</ul>
<p>query方法相对来说比较简单，记录了query开始和结束的信息，相当于做了一个切面的工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public SQLResponse query(SQLRequest sqlRequest) throws Exception &#123;</span><br><span class="line">    SQLResponse ret = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final String user = SecurityContextHolder.getContext().getAuthentication().getName();</span><br><span class="line">        badQueryDetector.queryStart(Thread.currentThread(), sqlRequest, user);</span><br><span class="line"></span><br><span class="line">        ret = queryWithSqlMassage(sqlRequest);</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        String badReason = (ret != null &amp;&amp; ret.isPushDown()) ? BadQueryEntry.ADJ_PUSHDOWN : null;</span><br><span class="line">        badQueryDetector.queryEnd(Thread.currentThread(), badReason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中badQueryDetector是一个单起的线程，用来统计和监测bad query的。当有bad query时notify相关的观察者，做一些操作，如打印日志，记录bad query等。kylin 中很多事件的通知都是通过生产者消费者模式订阅发布的。继续进入queryWithSqlMessage()</p>
<ul>
<li>QueryService.queryWithSqlMessage()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Connection conn = null;</span><br><span class="line">try &#123;</span><br><span class="line">	 conn = QueryConnection.getConnection(sqlRequest.getProject());</span><br><span class="line">	 ...</span><br><span class="line">	 return execute(correctedSql, sqlRequest, conn);</span><br><span class="line">	 ...</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">		DBUtils.closeQuietly(conn);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里首先获取了数据库连接，kylin的查询的中间层是基于Calcite的，接下来会看一下QueryConnection背后的逻辑。不过话说回来kylin这种整个大块的try catch异常捕获的机制某种意义上来说是种不负责任的表现。</p>
<ul>
<li>QueryConnection.getConnection():</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Connection getConnection(String project) throws SQLException &#123;</span><br><span class="line">    if (!isRegister) &#123;</span><br><span class="line">        DriverManager.registerDriver(new Driver());</span><br><span class="line">        isRegister = true;</span><br><span class="line">    &#125;</span><br><span class="line">    File olapTmp = OLAPSchemaFactory.createTempOLAPJson(project, KylinConfig.getInstanceFromEnv());</span><br><span class="line">    Properties info = new Properties();</span><br><span class="line">    info.put(&quot;model&quot;, olapTmp.getAbsolutePath());</span><br><span class="line">    return DriverManager.getConnection(&quot;jdbc:calcite:&quot;, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法比较简单，主要是通过OLAPSchemaFactory.createTempOLAPJson()生成了连接的元数据文件，用来创建连接</p>
<ul>
<li>OLAPSchemaFactory</li>
</ul>
<p>OLAPSchemaFactory 实现了calcite的 SchemaFactory接口，实现了create方法，用来创建连接时生成Schema</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Schema create(SchemaPlus parentSchema, String schemaName, Map&lt;String, Object&gt; operand) &#123;</span><br><span class="line">    String project = (String) operand.get(SCHEMA_PROJECT);</span><br><span class="line">    Schema newSchema = new OLAPSchema(project, schemaName, false);</span><br><span class="line">    return newSchema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在OLAPSchema的init方法中调用了KylinConfigBase.getStorageUrl方法，此方法返回了我们在配置文件中配置的kylin数据的存储信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public StorageURL getStorageUrl() &#123;</span><br><span class="line">        String url = getOptional(&quot;kylin.storage.url&quot;, &quot;default@hbase&quot;);</span><br><span class="line">        </span><br><span class="line">        // for backward compatibility</span><br><span class="line">        // 对2.0早期版本的配置做了兼容</span><br><span class="line">        if (&quot;hbase&quot;.equals(url))</span><br><span class="line">            url = &quot;default@hbase&quot;;</span><br><span class="line"></span><br><span class="line">        return StorageURL.valueOf(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也可以看出kylin默认的存储系统是HBase</p>
<ul>
<li>QueryService.execute()</li>
</ul>
<p>从之前的QueryService.queryWithSqlMessage()方法继续往下深入到 execute()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ResultSet resultSet = null;</span><br><span class="line">if (isPrepareStatementWithParams(sqlRequest)) &#123;</span><br><span class="line">	stat = conn.prepareStatement(correctedSql); // to be closed in the finally</span><br><span class="line">	PreparedStatement prepared = (PreparedStatement) stat;</span><br><span class="line">	processStatementAttr(prepared, sqlRequest);</span><br><span class="line">	for (int i = 0; i &lt; ((PrepareSqlRequest) sqlRequest).getParams().length; i++) &#123;</span><br><span class="line">			setParam(prepared, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	resultSet = prepared.executeQuery();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	stat = conn.createStatement();</span><br><span class="line">	processStatementAttr(stat, sqlRequest);</span><br><span class="line">	resultSet = stat.executeQuery(correctedSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>OLAPTable</li>
</ul>
<p>最后查出的结果是在resultSet里，追踪到这一步发现再往下追踪都是Calcite底层的逻辑了，kylin肯定是对Calcite 做了一定的扩展，并且将结果按照kylin预定义的规则做了各种聚合操作。Calcite文档中表示，可以实现三种类型的Table:</p>
<ul>
<li>a simple implementation of Table, using the ScannableTable interface, that enumerates all rows directly;</li>
<li>a more advanced implementation that implements FilterableTable, and can filter out rows according to simple predicates;</li>
<li>advanced implementation of Table, using TranslatableTable, that translates to relational operators using planner rules.</li>
</ul>
<p>发现在core-query模块中OLAPTable 实现了TranslatableTable。而OLAPTable 中实现的asQueryable方法有三种Enumerator的实现，这里默认选的是OLAP的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public &lt;T&gt; Queryable&lt;T&gt; asQueryable(QueryProvider queryProvider, SchemaPlus schema, String tableName) &#123;</span><br><span class="line">       return new AbstractTableQueryable&lt;T&gt;(queryProvider, schema, this, tableName) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            public Enumerator&lt;T&gt; enumerator() &#123;</span><br><span class="line">                final OLAPQuery query = new OLAPQuery(EnumeratorTypeEnum.OLAP, 0);</span><br><span class="line">                return (Enumerator&lt;T&gt;) query.enumerator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">OLAPQuery.enumerator</span><br><span class="line">public Enumerator&lt;Object[]&gt; enumerator() &#123;</span><br><span class="line">        OLAPContext olapContext = OLAPContext.getThreadLocalContextById(contextId);</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">        case OLAP:</span><br><span class="line">            return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new OLAPEnumerator(olapContext, optiqContext);</span><br><span class="line">        case LOOKUP_TABLE:</span><br><span class="line">            return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new LookupTableEnumerator(olapContext);</span><br><span class="line">        case HIVE:</span><br><span class="line">            return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new HiveEnumerator(olapContext);</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalArgumentException(&quot;Wrong type &quot; + type + &quot;!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>OLAPEnumerator.queryStorage()</li>
</ul>
<p>由OLAPTable.asQueryable进入，到了OLAPEnumerator.queryStorage()，终于能看到真实的查库操作了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private ITupleIterator queryStorage() &#123;</span><br><span class="line">    logger.debug(&quot;query storage...&quot;);</span><br><span class="line"></span><br><span class="line">    // bind dynamic variables</span><br><span class="line">    bindVariable(olapContext.filter);</span><br><span class="line"></span><br><span class="line">    olapContext.resetSQLDigest();</span><br><span class="line">    SQLDigest sqlDigest = olapContext.getSQLDigest();</span><br><span class="line"></span><br><span class="line">    // query storage engine</span><br><span class="line">    IStorageQuery storageEngine = StorageFactory.createQuery(olapContext.realization);</span><br><span class="line">    ITupleIterator iterator = storageEngine.search(olapContext.storageContext, sqlDigest, olapContext.returnTupleInfo);</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;return TupleIterator...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return iterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里StorageEngine 由StorageFactory创建，且有三种不同的实现，默认还是HBase</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   private static ThreadLocal&lt;ImplementationSwitch&lt;IStorage&gt;&gt; storages = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   public static IStorage storage(IStorageAware aware) &#123;</span><br><span class="line">       ImplementationSwitch&lt;IStorage&gt; current = storages.get();</span><br><span class="line">       if (storages.get() == null) &#123;</span><br><span class="line">           current = new ImplementationSwitch&lt;&gt;(KylinConfig.getInstanceFromEnv().getStorageEngines(), IStorage.class);</span><br><span class="line">           storages.set(current);</span><br><span class="line">       &#125;</span><br><span class="line">       return current.get(aware.getStorageType());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  //KylinConfig.getInstanceFromEnv().getStorageEngines()</span><br><span class="line">public Map&lt;Integer, String&gt; getStorageEngines() &#123;</span><br><span class="line">       Map&lt;Integer, String&gt; r = Maps.newLinkedHashMap();</span><br><span class="line">       // ref constants in IStorageAware</span><br><span class="line">       r.put(0, &quot;org.apache.kylin.storage.hbase.HBaseStorage&quot;);</span><br><span class="line">       r.put(1, &quot;org.apache.kylin.storage.hybrid.HybridStorage&quot;);</span><br><span class="line">       r.put(2, &quot;org.apache.kylin.storage.hbase.HBaseStorage&quot;);</span><br><span class="line">       r.putAll(convertKeyToInteger(getPropertiesByPrefix(&quot;kylin.storage.provider.&quot;)));</span><br><span class="line">       return r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>OLAPTableScan.register()</li>
</ul>
<p>由于OLAPTable实现了TranslatableTable，它会通过一系列的relation operators将结果聚合,relation operators的注册逻辑在OLAPTableScan中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void register(RelOptPlanner planner) &#123;</span><br><span class="line">       // force clear the query context before traversal relational operators</span><br><span class="line">       OLAPContext.clearThreadLocalContexts();</span><br><span class="line"></span><br><span class="line">       // register OLAP rules</span><br><span class="line">       planner.addRule(OLAPToEnumerableConverterRule.INSTANCE);</span><br><span class="line">       planner.addRule(OLAPFilterRule.INSTANCE);</span><br><span class="line">       planner.addRule(OLAPProjectRule.INSTANCE);</span><br><span class="line">       planner.addRule(OLAPAggregateRule.INSTANCE);</span><br><span class="line">       planner.addRule(OLAPJoinRule.INSTANCE);</span><br><span class="line">       planner.addRule(OLAPLimitRule.INSTANCE);</span><br><span class="line">       planner.addRule(OLAPSortRule.INSTANCE);</span><br><span class="line">       planner.addRule(OLAPUnionRule.INSTANCE);</span><br><span class="line">       planner.addRule(OLAPWindowRule.INSTANCE);</span><br><span class="line">       ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里着重看OLAPToEnumerableConverterRule 里返回的 OLAPToEnumerableConverter的实现，它是解释我在前言里提到的问题的关键。</p>
<ul>
<li>OLAPToEnumerableConverter.implement()</li>
</ul>
<p>这里面有对所有满足query条件的realization选择的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public Result implement(EnumerableRelImplementor enumImplementor, Prefer pref) &#123;</span><br><span class="line"> 	  </span><br><span class="line"> 	 ...</span><br><span class="line">     // identify model &amp; realization</span><br><span class="line">     List&lt;OLAPContext&gt; contexts = listContextsHavingScan();</span><br><span class="line"></span><br><span class="line">     // intercept query</span><br><span class="line">     List&lt;QueryInterceptor&gt; intercepts = QueryInterceptorUtil.getQueryInterceptors();</span><br><span class="line">     for (QueryInterceptor intercept : intercepts) &#123;</span><br><span class="line">         intercept.intercept(contexts);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">//RealizationChooser 中有对Realization选择的具体实现</span><br><span class="line">     RealizationChooser.selectRealization(contexts);</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">return impl.visitChild(this, 0, inputAsEnum, pref);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RealizationChooser.attemptSelectRealization()</li>
</ul>
<p>attemptSelectRealization方法里面主要干了两件事： 1）拉取属于该project与factTableName下的所有Realization，经过一系列的条件过滤掉不符合query的Realization，并将符合条件的Realization按照RealizationCost排序。2）对第一步收集的Realization map，调用QueryRouter.selectRealization()，一旦QueryRouter.selectRealization()有返回值立即中断循环返回最终选择的Realization</p>
<ul>
<li>RealizationChooser.makeOrderedModelMap() 部分的实现逻辑如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  //按条件过滤realization</span><br><span class="line">   for (IRealization real : realizations) &#123;</span><br><span class="line">       //过滤disabled cube</span><br><span class="line">       if (real.isReady() == false) &#123;</span><br><span class="line">           context.realizationCheck.addIncapableCube(real,</span><br><span class="line">                   RealizationCheck.IncapableReason.create(RealizationCheck.IncapableType.CUBE_NOT_READY));</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">       //过滤不包含querycontext里面全部的columns</span><br><span class="line">       if (containsAll(real.getAllColumnDescs(), first.allColumns) == false) &#123;</span><br><span class="line">           context.realizationCheck.addIncapableCube(real, RealizationCheck.IncapableReason</span><br><span class="line">                   .notContainAllColumn(notContain(real.getAllColumnDescs(), first.allColumns)));</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">       ／／过滤存在黑名单里面的cube</span><br><span class="line">       if (RemoveBlackoutRealizationsRule.accept(real) == false) &#123;</span><br><span class="line">           context.realizationCheck.addIncapableCube(real, RealizationCheck.IncapableReason</span><br><span class="line">                   .create(RealizationCheck.IncapableType.CUBE_BLACK_OUT_REALIZATION));</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">//过滤完，按RealizationCost排序</span><br><span class="line">       RealizationCost cost = new RealizationCost(real);</span><br><span class="line">       DataModelDesc m = real.getModel();</span><br><span class="line">       Set&lt;IRealization&gt; set = models.get(m);</span><br><span class="line">       if (set == null) &#123;</span><br><span class="line">           set = Sets.newHashSet();</span><br><span class="line">           set.add(real);</span><br><span class="line">           models.put(m, set);</span><br><span class="line">           costs.put(m, cost);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           set.add(real);</span><br><span class="line">           RealizationCost curCost = costs.get(m);</span><br><span class="line">           if (cost.compareTo(curCost) &lt; 0)</span><br><span class="line">               costs.put(m, cost);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>重点就在RealizationCost的实现里了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public RealizationCost(IRealization real) &#123;</span><br><span class="line">          // ref Candidate.PRIORITIES</span><br><span class="line">          this.priority = Candidate.PRIORITIES.get(real.getType());</span><br><span class="line"></span><br><span class="line">          // ref CubeInstance.getCost()</span><br><span class="line">          int c = real.getAllDimensions().size() * CubeInstance.COST_WEIGHT_DIMENSION</span><br><span class="line">                  + real.getMeasures().size() * CubeInstance.COST_WEIGHT_MEASURE;</span><br><span class="line">          for (JoinTableDesc join : real.getModel().getJoinTables()) &#123;</span><br><span class="line">              if (join.getJoin().isInnerJoin())</span><br><span class="line">                  c += CubeInstance.COST_WEIGHT_INNER_JOIN;</span><br><span class="line">          &#125;</span><br><span class="line">          this.cost = c;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>到此，对于kylin的Realization的成本计算规则清楚了。就是对dimension，measure,jointable三个维度的数量进行加权求和，得到的就是每个Realization对应的成本。相对的，每个维度对应的权重是有所斟酌的，dimension对应的是10，measure为1（考虑到是预计算的结果），jointable为100。从这也能看出建模时应该考虑的优化方向：避免过多的dimension，以及jointable的操作，结果尽量从预计算中出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次经过对kylin query源码的分析，基本上对kylin的核心代码都过了一遍，学习了不少优秀的代码解耦方式，也对底层原理加深了理解。关于RealizationCost的实现，目前kylin实现比较简单，在遍历所有满足条件的实现时找到Realization便返回处理的有些过于仓促。对于其是map的结构或许kylin在之后的扩展方面也是有所考虑。目前我们还不打算扩展Realizaiton的选择策略，了解了源码就可以在建模层面将查询结果不如意的情况给规避了。</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://ol7zjjc80.bkt.clouddn.com/271524552778_.pic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/10/31/kylin-query原理剖析/" data-id="ck61q9rob0011ogyhm1nmmemn" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJElEQVR42u3aQW7DMAwEwP7/0+65CJzsik4By6NT4bqWRgeWIvXzE4/jZLy+8/p+8tv3zy8bGBgYt2Ucb8fZO++/0G5E/vx0FgwMjAcwziZ+Hy7bkJqH43xtGBgYGC2jTRBzHgYGBkbLaINji8fAwMBYO8QmxbW2MJds38VncQwMjBsy8qr7///8lf4GBgbGrRhHOea8SXg9XRUGBsbWjDzA5Z9bY+eJ4+ksGBgYmzIW3WXbYNKwjI7BGBgYD2PksCS8tulj3jD48wQDA+MBjCRcrtW+JilgsUEYGBhbM9orEfOl5yG7fY6BgbErI0kNk2sTa6W39kj8IchiYGBsysgPkO2FjHazkpVERTcMDIxNGW1Rfu0gOkkui7VhYGBsx2jLapP2ZPKF9m/r3cLAwLgtYx4Er7pgUaSAkw4DBgbGrRjtBYs8XH6jAXDxHTcMDIwbMvJg2pb419oGdckPAwNja8b3FrRWaJt/EwMDYz/G2nJbTP6FtsCHgYHxNMZaIE7K9/kVtDxk12dxDAyM7RhrCd9VYbreYgwMjAcw2qJbm+TNS2kfZsHAwNiUcZRj7bDahvv6whkGBsbWjHmwm7Qkk3SwPQZjYGDsymhTvSR9nCSIa+kmBgbGExhrDYA21VsDR/8rMDAwMILQ2TY42+3AwMDAuGpxk0A8SV4xMDCewGibAckiooun8XZ8mB0DA2NrxtrR8SpYm+ONGpkYGBj3Y/wCek28KmL3VTcAAAAASUVORK5CYII=" class="article-share-link">分享</a><div class="tags"><a href="/tags/kylin-Java-源码/">kylin - Java - 源码</a></div><div class="post-nav"><a href="/2018/03/26/JVM知识总结/" class="pre">JVM知识总结</a><a href="/2017/10/13/superset-customization/" class="next">superset customization</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/MR任务在Hadoop子系统中状态流转/">MR任务在Hadoop子系统中状态流转</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Yarn-Federation源码串读/">Yarn Federation源码串读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Hadoop-Rpc源码分析/">Hadoop Rpc源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/">【Spark源码分析】Job提交执行过程详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/【Spark源码分析】Broadcast/">【Spark源码分析】Broadcast</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/【Spark源码分析】Dynamic-Resource-Allocation设计的思考/">【Spark源码分析】Dynamic Resource Allocation设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/Raft论文学习/">Raft论文学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/12/【spark-tips】spark2-4-0触发的executor内存溢出排查/">【spark-tips】spark2.4.0触发的executor内存溢出排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/20/Flink实战总结/">Flink实战总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/Spark学习笔记/">Spark实战总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/chao-li-11/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://weibo.com/3101672623/profile?topnav=1&amp;wvr=6" title="微博" target="_blank">微博</a><ul></ul><a href="https://github.com/lichaojacobs" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>