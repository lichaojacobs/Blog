<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>kylin query原理剖析 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kylin query原理剖析</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">kylin query原理剖析</h1><div class="post-meta">Oct 31, 2017</div><a data-disqus-identifier="2017/10/31/kylin-query原理剖析/" href="/2017/10/31/kylin-query原理剖析/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近我们组负责数据建模的同学抱怨kylin的relization选择策略：同一个project下一条查询语句本来期望命中某一个cube的，结果系统却选择了其他cube。之前也有大概翻阅过kylin这块的实现源码，知道如果同一个project下如果有多个满足条件的的实现，会按照成本排序并选择成本最低的那个实现。对于成本这块的度量标准，没有做过多研究，于是带着问题，对这块源码进行了一次梳理。</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>为使博文简洁相关实现只贴部分核心代码，以下所指的Realization对应于构建好的Cube。</p>
<h4 id="查询入口"><a href="#查询入口" class="headerlink" title="查询入口"></a>查询入口</h4><ul>
<li>QueryService.doQueryWithCache()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> //kylin.query.cache-enabled是否开启，如果开启将会从cache里面去读结果</div><div class="line"> if (queryCacheEnabled) &#123;</div><div class="line">	sqlResponse = searchQueryInCache(sqlRequest);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> try &#123;</div><div class="line">if (null == sqlResponse) &#123;</div><div class="line">	if (isSelect) &#123;</div><div class="line">		//查询入口</div><div class="line">		sqlResponse = query(sqlRequest);</div><div class="line">	&#125; else if (kylinConfig.isPushDownEnabled() &amp;&amp; kylinConfig.isPushDownUpdateEnabled()) &#123;</div><div class="line">		//如果开启了pushDown的话允许非查询的sql，如update</div><div class="line">		sqlResponse = update(sqlRequest);</div><div class="line">	&#125; else &#123;	</div><div class="line">		logger.debug(&quot;Directly return exception as the sql is unsupported, and query pushdown is disabled&quot;);</div><div class="line">                       throw new BadRequestException(msg.getNOT_SUPPORTED_SQL());</div><div class="line">			&#125;</div><div class="line"> ...</div><div class="line"> catch()&#123;</div><div class="line"> 	...</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里，我们忽略从缓存中查找（searchQueryInCache），以及非select查询的情况，单单从一次正常的查询进行分析，进入query方法。</p>
<ul>
<li>QueryService.query()</li>
</ul>
<p>query方法相对来说比较简单，记录了query开始和结束的信息，相当于做了一个切面的工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public SQLResponse query(SQLRequest sqlRequest) throws Exception &#123;</div><div class="line">    SQLResponse ret = null;</div><div class="line">    try &#123;</div><div class="line">        final String user = SecurityContextHolder.getContext().getAuthentication().getName();</div><div class="line">        badQueryDetector.queryStart(Thread.currentThread(), sqlRequest, user);</div><div class="line"></div><div class="line">        ret = queryWithSqlMassage(sqlRequest);</div><div class="line">        return ret;</div><div class="line"></div><div class="line">    &#125; finally &#123;</div><div class="line">        String badReason = (ret != null &amp;&amp; ret.isPushDown()) ? BadQueryEntry.ADJ_PUSHDOWN : null;</div><div class="line">        badQueryDetector.queryEnd(Thread.currentThread(), badReason);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中badQueryDetector是一个单起的线程，用来统计和监测bad query的。当有bad query时notify相关的观察者，做一些操作，如打印日志，记录bad query等。kylin 中很多事件的通知都是通过生产者消费者模式订阅发布的。继续进入queryWithSqlMessage()</p>
<ul>
<li>QueryService.queryWithSqlMessage()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Connection conn = null;</div><div class="line">try &#123;</div><div class="line">	 conn = QueryConnection.getConnection(sqlRequest.getProject());</div><div class="line">	 ...</div><div class="line">	 return execute(correctedSql, sqlRequest, conn);</div><div class="line">	 ...</div><div class="line">   &#125; finally &#123;</div><div class="line">		DBUtils.closeQuietly(conn);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个方法里首先获取了数据库连接，kylin的查询的中间层是基于Calcite的，接下来会看一下QueryConnection背后的逻辑。不过话说回来kylin这种整个大块的try catch异常捕获的机制某种意义上来说是种不负责任的表现。</p>
<ul>
<li>QueryConnection.getConnection():</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static Connection getConnection(String project) throws SQLException &#123;</div><div class="line">    if (!isRegister) &#123;</div><div class="line">        DriverManager.registerDriver(new Driver());</div><div class="line">        isRegister = true;</div><div class="line">    &#125;</div><div class="line">    File olapTmp = OLAPSchemaFactory.createTempOLAPJson(project, KylinConfig.getInstanceFromEnv());</div><div class="line">    Properties info = new Properties();</div><div class="line">    info.put(&quot;model&quot;, olapTmp.getAbsolutePath());</div><div class="line">    return DriverManager.getConnection(&quot;jdbc:calcite:&quot;, info);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法比较简单，主要是通过OLAPSchemaFactory.createTempOLAPJson()生成了连接的元数据文件，用来创建连接</p>
<ul>
<li>OLAPSchemaFactory</li>
</ul>
<p>OLAPSchemaFactory 实现了calcite的 SchemaFactory接口，实现了create方法，用来创建连接时生成Schema</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Schema create(SchemaPlus parentSchema, String schemaName, Map&lt;String, Object&gt; operand) &#123;</div><div class="line">    String project = (String) operand.get(SCHEMA_PROJECT);</div><div class="line">    Schema newSchema = new OLAPSchema(project, schemaName, false);</div><div class="line">    return newSchema;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在OLAPSchema的init方法中调用了KylinConfigBase.getStorageUrl方法，此方法返回了我们在配置文件中配置的kylin数据的存储信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public StorageURL getStorageUrl() &#123;</div><div class="line">        String url = getOptional(&quot;kylin.storage.url&quot;, &quot;default@hbase&quot;);</div><div class="line">        </div><div class="line">        // for backward compatibility</div><div class="line">        // 对2.0早期版本的配置做了兼容</div><div class="line">        if (&quot;hbase&quot;.equals(url))</div><div class="line">            url = &quot;default@hbase&quot;;</div><div class="line"></div><div class="line">        return StorageURL.valueOf(url);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也可以看出kylin默认的存储系统是HBase</p>
<ul>
<li>QueryService.execute()</li>
</ul>
<p>从之前的QueryService.queryWithSqlMessage()方法继续往下深入到 execute()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ResultSet resultSet = null;</div><div class="line">if (isPrepareStatementWithParams(sqlRequest)) &#123;</div><div class="line">	stat = conn.prepareStatement(correctedSql); // to be closed in the finally</div><div class="line">	PreparedStatement prepared = (PreparedStatement) stat;</div><div class="line">	processStatementAttr(prepared, sqlRequest);</div><div class="line">	for (int i = 0; i &lt; ((PrepareSqlRequest) sqlRequest).getParams().length; i++) &#123;</div><div class="line">			setParam(prepared, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);</div><div class="line">	&#125;</div><div class="line">	resultSet = prepared.executeQuery();</div><div class="line">&#125; else &#123;</div><div class="line">	stat = conn.createStatement();</div><div class="line">	processStatementAttr(stat, sqlRequest);</div><div class="line">	resultSet = stat.executeQuery(correctedSql);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>OLAPTable</li>
</ul>
<p>最后查出的结果是在resultSet里，追踪到这一步发现再往下追踪都是Calcite底层的逻辑了，kylin肯定是对Calcite 做了一定的扩展，并且将结果按照kylin预定义的规则做了各种聚合操作。Calcite文档中表示，可以实现三种类型的Table:</p>
<ul>
<li>a simple implementation of Table, using the ScannableTable interface, that enumerates all rows directly;</li>
<li>a more advanced implementation that implements FilterableTable, and can filter out rows according to simple predicates;</li>
<li>advanced implementation of Table, using TranslatableTable, that translates to relational operators using planner rules.</li>
</ul>
<p>发现在core-query模块中OLAPTable 实现了TranslatableTable。而OLAPTable 中实现的asQueryable方法有三种Enumerator的实现，这里默认选的是OLAP的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public &lt;T&gt; Queryable&lt;T&gt; asQueryable(QueryProvider queryProvider, SchemaPlus schema, String tableName) &#123;</div><div class="line">       return new AbstractTableQueryable&lt;T&gt;(queryProvider, schema, this, tableName) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            public Enumerator&lt;T&gt; enumerator() &#123;</div><div class="line">                final OLAPQuery query = new OLAPQuery(EnumeratorTypeEnum.OLAP, 0);</div><div class="line">                return (Enumerator&lt;T&gt;) query.enumerator();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">OLAPQuery.enumerator</div><div class="line">public Enumerator&lt;Object[]&gt; enumerator() &#123;</div><div class="line">        OLAPContext olapContext = OLAPContext.getThreadLocalContextById(contextId);</div><div class="line">        switch (type) &#123;</div><div class="line">        case OLAP:</div><div class="line">            return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new OLAPEnumerator(olapContext, optiqContext);</div><div class="line">        case LOOKUP_TABLE:</div><div class="line">            return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new LookupTableEnumerator(olapContext);</div><div class="line">        case HIVE:</div><div class="line">            return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new HiveEnumerator(olapContext);</div><div class="line">        default:</div><div class="line">            throw new IllegalArgumentException(&quot;Wrong type &quot; + type + &quot;!&quot;);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>OLAPEnumerator.queryStorage()</li>
</ul>
<p>由OLAPTable.asQueryable进入，到了OLAPEnumerator.queryStorage()，终于能看到真实的查库操作了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private ITupleIterator queryStorage() &#123;</div><div class="line">    logger.debug(&quot;query storage...&quot;);</div><div class="line"></div><div class="line">    // bind dynamic variables</div><div class="line">    bindVariable(olapContext.filter);</div><div class="line"></div><div class="line">    olapContext.resetSQLDigest();</div><div class="line">    SQLDigest sqlDigest = olapContext.getSQLDigest();</div><div class="line"></div><div class="line">    // query storage engine</div><div class="line">    IStorageQuery storageEngine = StorageFactory.createQuery(olapContext.realization);</div><div class="line">    ITupleIterator iterator = storageEngine.search(olapContext.storageContext, sqlDigest, olapContext.returnTupleInfo);</div><div class="line">    if (logger.isDebugEnabled()) &#123;</div><div class="line">        logger.debug(&quot;return TupleIterator...&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return iterator;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里StorageEngine 由StorageFactory创建，且有三种不同的实现，默认还是HBase</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">   private static ThreadLocal&lt;ImplementationSwitch&lt;IStorage&gt;&gt; storages = new ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">   public static IStorage storage(IStorageAware aware) &#123;</div><div class="line">       ImplementationSwitch&lt;IStorage&gt; current = storages.get();</div><div class="line">       if (storages.get() == null) &#123;</div><div class="line">           current = new ImplementationSwitch&lt;&gt;(KylinConfig.getInstanceFromEnv().getStorageEngines(), IStorage.class);</div><div class="line">           storages.set(current);</div><div class="line">       &#125;</div><div class="line">       return current.get(aware.getStorageType());</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">  //KylinConfig.getInstanceFromEnv().getStorageEngines()</div><div class="line">public Map&lt;Integer, String&gt; getStorageEngines() &#123;</div><div class="line">       Map&lt;Integer, String&gt; r = Maps.newLinkedHashMap();</div><div class="line">       // ref constants in IStorageAware</div><div class="line">       r.put(0, &quot;org.apache.kylin.storage.hbase.HBaseStorage&quot;);</div><div class="line">       r.put(1, &quot;org.apache.kylin.storage.hybrid.HybridStorage&quot;);</div><div class="line">       r.put(2, &quot;org.apache.kylin.storage.hbase.HBaseStorage&quot;);</div><div class="line">       r.putAll(convertKeyToInteger(getPropertiesByPrefix(&quot;kylin.storage.provider.&quot;)));</div><div class="line">       return r;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>OLAPTableScan.register()</li>
</ul>
<p>由于OLAPTable实现了TranslatableTable，它会通过一系列的relation operators将结果聚合,relation operators的注册逻辑在OLAPTableScan中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void register(RelOptPlanner planner) &#123;</div><div class="line">       // force clear the query context before traversal relational operators</div><div class="line">       OLAPContext.clearThreadLocalContexts();</div><div class="line"></div><div class="line">       // register OLAP rules</div><div class="line">       planner.addRule(OLAPToEnumerableConverterRule.INSTANCE);</div><div class="line">       planner.addRule(OLAPFilterRule.INSTANCE);</div><div class="line">       planner.addRule(OLAPProjectRule.INSTANCE);</div><div class="line">       planner.addRule(OLAPAggregateRule.INSTANCE);</div><div class="line">       planner.addRule(OLAPJoinRule.INSTANCE);</div><div class="line">       planner.addRule(OLAPLimitRule.INSTANCE);</div><div class="line">       planner.addRule(OLAPSortRule.INSTANCE);</div><div class="line">       planner.addRule(OLAPUnionRule.INSTANCE);</div><div class="line">       planner.addRule(OLAPWindowRule.INSTANCE);</div><div class="line">       ...</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里着重看OLAPToEnumerableConverterRule 里返回的 OLAPToEnumerableConverter的实现，它是解释我在前言里提到的问题的关键。</p>
<ul>
<li>OLAPToEnumerableConverter.implement()</li>
</ul>
<p>这里面有对所有满足query条件的realization选择的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public Result implement(EnumerableRelImplementor enumImplementor, Prefer pref) &#123;</div><div class="line"> 	  </div><div class="line"> 	 ...</div><div class="line">     // identify model &amp; realization</div><div class="line">     List&lt;OLAPContext&gt; contexts = listContextsHavingScan();</div><div class="line"></div><div class="line">     // intercept query</div><div class="line">     List&lt;QueryInterceptor&gt; intercepts = QueryInterceptorUtil.getQueryInterceptors();</div><div class="line">     for (QueryInterceptor intercept : intercepts) &#123;</div><div class="line">         intercept.intercept(contexts);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">//RealizationChooser 中有对Realization选择的具体实现</div><div class="line">     RealizationChooser.selectRealization(contexts);</div><div class="line">     ...</div><div class="line"></div><div class="line">return impl.visitChild(this, 0, inputAsEnum, pref);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>RealizationChooser.attemptSelectRealization()</li>
</ul>
<p>attemptSelectRealization方法里面主要干了两件事： 1）拉取属于该project与factTableName下的所有Realization，经过一系列的条件过滤掉不符合query的Realization，并将符合条件的Realization按照RealizationCost排序。2）对第一步收集的Realization map，调用QueryRouter.selectRealization()，一旦QueryRouter.selectRealization()有返回值立即中断循环返回最终选择的Realization</p>
<ul>
<li>RealizationChooser.makeOrderedModelMap() 部分的实现逻辑如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">  //按条件过滤realization</div><div class="line">   for (IRealization real : realizations) &#123;</div><div class="line">       //过滤disabled cube</div><div class="line">       if (real.isReady() == false) &#123;</div><div class="line">           context.realizationCheck.addIncapableCube(real,</div><div class="line">                   RealizationCheck.IncapableReason.create(RealizationCheck.IncapableType.CUBE_NOT_READY));</div><div class="line">           continue;</div><div class="line">       &#125;</div><div class="line">       //过滤不包含querycontext里面全部的columns</div><div class="line">       if (containsAll(real.getAllColumnDescs(), first.allColumns) == false) &#123;</div><div class="line">           context.realizationCheck.addIncapableCube(real, RealizationCheck.IncapableReason</div><div class="line">                   .notContainAllColumn(notContain(real.getAllColumnDescs(), first.allColumns)));</div><div class="line">           continue;</div><div class="line">       &#125;</div><div class="line">       ／／过滤存在黑名单里面的cube</div><div class="line">       if (RemoveBlackoutRealizationsRule.accept(real) == false) &#123;</div><div class="line">           context.realizationCheck.addIncapableCube(real, RealizationCheck.IncapableReason</div><div class="line">                   .create(RealizationCheck.IncapableType.CUBE_BLACK_OUT_REALIZATION));</div><div class="line">           continue;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//过滤完，按RealizationCost排序</div><div class="line">       RealizationCost cost = new RealizationCost(real);</div><div class="line">       DataModelDesc m = real.getModel();</div><div class="line">       Set&lt;IRealization&gt; set = models.get(m);</div><div class="line">       if (set == null) &#123;</div><div class="line">           set = Sets.newHashSet();</div><div class="line">           set.add(real);</div><div class="line">           models.put(m, set);</div><div class="line">           costs.put(m, cost);</div><div class="line">       &#125; else &#123;</div><div class="line">           set.add(real);</div><div class="line">           RealizationCost curCost = costs.get(m);</div><div class="line">           if (cost.compareTo(curCost) &lt; 0)</div><div class="line">               costs.put(m, cost);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>重点就在RealizationCost的实现里了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public RealizationCost(IRealization real) &#123;</div><div class="line">          // ref Candidate.PRIORITIES</div><div class="line">          this.priority = Candidate.PRIORITIES.get(real.getType());</div><div class="line"></div><div class="line">          // ref CubeInstance.getCost()</div><div class="line">          int c = real.getAllDimensions().size() * CubeInstance.COST_WEIGHT_DIMENSION</div><div class="line">                  + real.getMeasures().size() * CubeInstance.COST_WEIGHT_MEASURE;</div><div class="line">          for (JoinTableDesc join : real.getModel().getJoinTables()) &#123;</div><div class="line">              if (join.getJoin().isInnerJoin())</div><div class="line">                  c += CubeInstance.COST_WEIGHT_INNER_JOIN;</div><div class="line">          &#125;</div><div class="line">          this.cost = c;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>到此，对于kylin的Realization的成本计算规则清楚了。就是对dimension，measure,jointable三个维度的数量进行加权求和，得到的就是每个Realization对应的成本。相对的，每个维度对应的权重是有所斟酌的，dimension对应的是10，measure为1（考虑到是预计算的结果），jointable为100。从这也能看出建模时应该考虑的优化方向：避免过多的dimension，以及jointable的操作，结果尽量从预计算中出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次经过对kylin query源码的分析，基本上对kylin的核心代码都过了一遍，学习了不少优秀的代码解耦方式，也对底层原理加深了理解。关于RealizationCost的实现，目前kylin实现比较简单，在遍历所有满足条件的实现时找到Realization便返回处理的有些过于仓促。对于其是map的结构或许kylin在之后的扩展方面也是有所考虑。目前我们还不打算扩展Realizaiton的选择策略，了解了源码就可以在建模层面将查询结果不如意的情况给规避了。</p>
</div><div class="tags"><a href="/tags/kylin-Java-源码/">kylin - Java - 源码</a></div><div class="post-nav"><a href="/2018/03/26/JVM知识总结/" class="pre">JVM知识总结</a><a href="/2017/10/13/superset-customization/" class="next">superset customization</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'https://jacobs-wanhb.disqus.com/embed.js';
var disqus_identifier = '2017/10/31/kylin-query原理剖析/';
var disqus_title = 'kylin query原理剖析';
var disqus_url = 'http://yoursite.com/2017/10/31/kylin-query原理剖析/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//https://jacobs-wanhb.disqus.com/embed.js.disqus.com/count.js" async></script></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/okhttp-support-100-continue-for-palo/">okhttp support 100-continue for palo</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/JVM知识总结/">JVM知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/kylin-query原理剖析/">kylin query原理剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/superset-customization/">superset customization</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/23/lombok-builder-泛型擦除问题/">lombok builder 泛型擦除</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Kylin二次开发——测试环境搭建/">Kylin二次开发——测试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/kylin-master-slave同步原理及问题排查/">kylin master-slave同步原理及问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/HBase架构脑图/">HBase架构脑图</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/02/Kylin学习笔记/">Kylin学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/11/Spark学习笔记/">Spark学习笔记</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>