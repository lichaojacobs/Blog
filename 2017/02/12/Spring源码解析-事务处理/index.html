<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Spring源码解析--事务处理 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring源码解析--事务处理</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring源码解析--事务处理</h1><div class="post-meta">Feb 12, 2017</div><a data-disqus-identifier="2017/02/12/Spring源码解析-事务处理/" href="/2017/02/12/Spring源码解析-事务处理/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h3 id="事务处理相关类的层次结构"><a href="#事务处理相关类的层次结构" class="headerlink" title="事务处理相关类的层次结构"></a>事务处理相关类的层次结构</h3><p><img src="http://ol7zjjc80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-11%20%E4%B8%8B%E5%8D%887.54.25.png" alt="事务处理相关类的层次结构"></p>
<p>在 Spring事务处理中，可以通过设计一个TransactionProxyFactoryBean来使用AOP功能，通过它可以生成Proxy代理对象。在代理对象中，通过TranscationInterceptor来完成对代理对象方法的拦截。实现声明式事务处理时，是AOP和IOC集成的部分，而对于具体的事物处理实现，是通过设计PlatformTransactionManager，AbstractPlatforTransactionmanager以及一系列具体事务处理器来实现的。PlatformTransactionManager又实现了TransactionInterceptor，这样就能将一系列处理给串联起来。</p>
<h3 id="Spring声明式事务处理"><a href="#Spring声明式事务处理" class="headerlink" title="Spring声明式事务处理"></a>Spring声明式事务处理</h3><h4 id="设计原理与过程"><a href="#设计原理与过程" class="headerlink" title="设计原理与过程"></a>设计原理与过程</h4><p>在实现声明式的事务处理时，常用的方式是结合IOC容器和Spring已有的TransactionProxyFactoryBean对事务管理进行配置，实现可分为以下几个步骤：</p>
<ul>
<li>读取和处理在IOC容器中配置的事务处理属性，并转化为Spring事务处理需要的内部数据结构。</li>
<li>Spring事务处理模块实现统一的事务处理过程。</li>
<li>底层的事务处理实现。Spring委托给具体的事务处理器来完成。</li>
</ul>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-11%20%E4%B8%8B%E5%8D%888.23.09.png" alt="建立事务处理对象时序图"></p>
<p>从TransactionProxyFactoryBean入手，通过代码来了解Spring是如何通过AOP功能来完成事务管理配置的，从图中可以看到Spring为声明式事务处理的实现所做的一些准备工作：包括为AOP配置基础设施，这些基础设施包括设置拦截器TransactionInterceptor、通过DefaultPointcutAdvisor或TransactionAttributeSourceAdvisor。同时，在TransactionProxyFactoryBean的实现中，还可以看到注入进来的PlatformTransactionManager和事务处理属性TransactionAttribute等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TransactionProxyFactoryBean extends AbstractSingletonProxyFactoryBean implements BeanFactoryAware &#123;</div><div class="line">  private final TransactionInterceptor transactionInterceptor = new TransactionInterceptor();／／这个拦截器通过AOP发挥作用，通过这个拦截器的实现，Spring封装了事务处理实现</div><div class="line">  private Pointcut pointcut;</div><div class="line"></div><div class="line">  public TransactionProxyFactoryBean() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;</div><div class="line">    this.transactionInterceptor.setTransactionManager(transactionManager);</div><div class="line">  &#125;</div><div class="line">  //通过依赖注入的事务属性以Properties的形式出现，把BeanDefinition中读到的事务管理的属性信息注入到TransactionInterceptor中</div><div class="line">  public void setTransactionAttributes(Properties transactionAttributes) &#123;</div><div class="line">    this.transactionInterceptor.setTransactionAttributes(transactionAttributes);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) &#123;</div><div class="line">    this.transactionInterceptor.setTransactionAttributeSource(transactionAttributeSource);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setPointcut(Pointcut pointcut) &#123;</div><div class="line">    this.pointcut = pointcut;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setBeanFactory(BeanFactory beanFactory) &#123;</div><div class="line">    this.transactionInterceptor.setBeanFactory(beanFactory);</div><div class="line">  &#125;</div><div class="line">//这里创建Spring  AOP对事务处理的Advisor</div><div class="line">  protected Object createMainInterceptor() &#123;</div><div class="line">    this.transactionInterceptor.afterPropertiesSet();//事务处理完成AOP配置的地方</div><div class="line">    return this.pointcut != null?new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor):new TransactionAttributeSourceAdvisor(this.transactionInterceptor);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  protected void postProcessProxyFactory(ProxyFactory proxyFactory) &#123;</div><div class="line">    proxyFactory.addInterface(TransactionalProxy.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成了AOP配置，Spring的TransactionInterceptor配置是IOC容器完成Bean的依赖注入时，通过initializeBean方法被调用。</p>
<p>   在建立TransactionProxyFactoryBean的事务处理拦截器的时候， afterPropertiesSet方法首先对 ProxyFactoryBean的目标Bean设置进行检查，如果这个目标Bean的设置是正确的，就会创建ProxyFactory对象，从而实现AOP的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void afterPropertiesSet() &#123;</div><div class="line">  if(this.getTransactionManager() == null &amp;&amp; this.beanFactory == null) &#123;</div><div class="line">    throw new IllegalStateException(&quot;Set the \&apos;transactionManager\&apos; property or make sure to run within a BeanFactory containing a PlatformTransactionManager bean!&quot;);</div><div class="line">  &#125; else if(this.getTransactionAttributeSource() == null) &#123;</div><div class="line">    throw new IllegalStateException(&quot;Either \&apos;transactionAttributeSource\&apos; or \&apos;transactionAttributes\&apos; is required: If there are no transactional methods, then don\&apos;t use a transaction aspect.&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事务处理配置的读入"><a href="#事务处理配置的读入" class="headerlink" title="事务处理配置的读入"></a>事务处理配置的读入</h4><p>在AOP配置完成的基础上，以TransactionAttributeSourceAdvisor的实现为入口，了解具体的事务属性配置是如何读入的，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private TransactionInterceptor transactionInterceptor;／／同样需要AOP中用到的Interceptro和Pointcut，通过内部类，调用TransactionInterceptor来得到事务的配置属性，在对Proxy的方法进行匹配调用时，会使用到这些配置属性。</div><div class="line">private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() &#123;</div><div class="line">  protected TransactionAttributeSource getTransactionAttributeSource() &#123;</div><div class="line">    return TransactionAttributeSourceAdvisor.this.transactionInterceptor != null?TransactionAttributeSourceAdvisor.this.transactionInterceptor.getTransactionAttributeSource():null;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在声明式事务处理中，通过对目标对象的方法调用进行拦截实现，这个拦截通过AOP发挥作用。在AOP中，对于拦截的启动，首先需要对方法调用是否需要拦截进行判断，依据时那些在TransactionProxyFactoryBean中为目标对象设置的事务属性。这个匹配判断在TransactionAttributeSourcePointcut中完成。实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123;</div><div class="line">  if(TransactionalProxy.class.isAssignableFrom(targetClass)) &#123;</div><div class="line">    return false;</div><div class="line">  &#125; else &#123;</div><div class="line">    TransactionAttributeSource tas = this.getTransactionAttributeSource();</div><div class="line">    return tas == null || tas.getTransactionAttribute(method, targetClass) != null;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在方法中，首先把事务方法的属性配置读取到TransactionAttributeSource对象中，有了这些事务处理的配置以后，根据当前方法调用的method对象和目标对象，对是否需要启动事务处理拦截器进行判断。</p>
<p>在Pointcut的matches判断过程中，会用到transactionAttributeSource对象，这个transactionAttributeSource对象是在对TransactionInterceptor进行依赖注入时就配置好的，它的设置是在TransactionInterceptor的基类TransactionAspectSupport中完成的。配置的是一个NameMatchTransactionAttributeSouce对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void setTransactionAttributes(Properties transactionAttributes) &#123;</div><div class="line">  NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();</div><div class="line">  tas.setProperties(transactionAttributes);</div><div class="line">  this.transactionAttributeSource = tas;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可知，NameMatchTransactionAttributeSouce作为TransacionAttributeSource的具体实现，是实际完成事务处理属性读入和匹配的地方。对于NameMatchTransactionAttributeSouce是怎样实现事务处理属性的读入和匹配的，可看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public void setProperties(Properties transactionAttributes) &#123;//设置配置的事务方法</div><div class="line">  TransactionAttributeEditor tae = new TransactionAttributeEditor();</div><div class="line">  Enumeration propNames = transactionAttributes.propertyNames();</div><div class="line"></div><div class="line">  while(propNames.hasMoreElements()) &#123;</div><div class="line">    String methodName = (String)propNames.nextElement();</div><div class="line">    String value = transactionAttributes.getProperty(methodName);</div><div class="line">    tae.setAsText(value);</div><div class="line">    TransactionAttribute attr = (TransactionAttribute)tae.getValue();</div><div class="line">    this.addTransactionalMethod(methodName, attr);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">private Map&lt;String, TransactionAttribute&gt; nameMap = new HashMap();</div><div class="line"></div><div class="line"></div><div class="line">public void addTransactionalMethod(String methodName, TransactionAttribute attr) &#123;</div><div class="line">  if(logger.isDebugEnabled()) &#123;</div><div class="line">    logger.debug(&quot;Adding transactional method [&quot; + methodName + &quot;] with attribute [&quot; + attr + &quot;]&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  this.nameMap.put(methodName, attr);</div><div class="line">&#125;</div><div class="line">／／对调用的方法进行判断，判断它是否是事务方法，如果是，那么取出相应的事务配置属性</div><div class="line">public TransactionAttribute getTransactionAttribute(Method method, Class&lt;?&gt; targetClass) &#123;</div><div class="line">  if(!ClassUtils.isUserLevelMethod(method)) &#123;</div><div class="line">    return null;</div><div class="line">  &#125; else &#123;</div><div class="line">    String methodName = method.getName();／／判断当前目标调用的方法与配置的事务方法是否直接匹配</div><div class="line">    TransactionAttribute attr = (TransactionAttribute)this.nameMap.get(methodName);</div><div class="line">    if(attr == null) &#123;//如果不能直接匹配，就通过调用PatternMatchUtils的simpleMatch方法来进行匹配判断。</div><div class="line">      String bestNameMatch = null;</div><div class="line">      Iterator var6 = this.nameMap.keySet().iterator();</div><div class="line"></div><div class="line">      while(true) &#123;</div><div class="line">        String mappedName;</div><div class="line">        do &#123;</div><div class="line">          do &#123;</div><div class="line">            if(!var6.hasNext()) &#123;</div><div class="line">              return attr;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mappedName = (String)var6.next();</div><div class="line">          &#125; while(!this.isMatch(methodName, mappedName));</div><div class="line">        &#125; while(bestNameMatch != null &amp;&amp; bestNameMatch.length() &gt; mappedName.length());</div><div class="line"></div><div class="line">        attr = (TransactionAttribute)this.nameMap.get(mappedName);</div><div class="line">        bestNameMatch = mappedName;</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      return attr;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">／／事务方法的匹配判断，详细的匹配过程在PatternMatchUtils中实现</div><div class="line">protected boolean isMatch(String methodName, String mappedName) &#123;</div><div class="line">  return PatternMatchUtils.simpleMatch(mappedName, methodName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事务处理拦截器的设计与实现："><a href="#事务处理拦截器的设计与实现：" class="headerlink" title="事务处理拦截器的设计与实现："></a>事务处理拦截器的设计与实现：</h4><p>经过TransactionProxyFactoryBean的AOP包装，此时如果对目标对象进行方法调用，起作用的对象实际傻姑娘是一个Proxy代理对象。对目标对象方法的调用，不会直接作用在TransactionProxyFactoryBean设置的目标对象上。而是会被设置的事务处理器拦截。而在TransactionProxyFactoryBean的AOP实现中，获取Proxy对象的过程并不复杂，TransactionProxyFactoryBean作为一个FactoryBean，对Bean对象的引用通过getObejct方法来得到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public Object getObject() &#123; ／／TransactionProxyFactoryBean 的父类 AbstractSingletonProxyFactoryBean中</div><div class="line">／／返回的是一个Proxy，是ProxyFactory生成的AOP代理，已经封装了对事务处理的拦截器设置</div><div class="line">  if(this.proxy == null) &#123;</div><div class="line">    throw new FactoryBeanNotInitializedException();</div><div class="line">  &#125; else &#123;</div><div class="line">    return this.proxy;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于AOP代理对象的作用方法入口，我们一般都知道invoke方法，这个invke方法在事务处理拦截器TransactionInterceptor中，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</div><div class="line">  Class targetClass = invocation.getThis() != null?AopUtils.getTargetClass(invocation.getThis()):null;</div><div class="line">  return this.invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123;</div><div class="line">    public Object proceedWithInvocation() throws Throwable &#123;</div><div class="line">      return invocation.proceed();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final TransactionAspectSupport.InvocationCallback invocation) throws Throwable &#123;</div><div class="line">  final TransactionAttribute txAttr = this.getTransactionAttributeSource().getTransactionAttribute(method, targetClass);／／这里读取事务的属性配置，通过TransactionAttributeSource对象取得</div><div class="line">  final PlatformTransactionManager tm = this.determineTransactionManager(txAttr);／／根据TransactionProxyFactoryBean的配置信息获得具体的事务处理器</div><div class="line">  final String joinpointIdentification = this.methodIdentification(method, targetClass, txAttr);</div><div class="line">  if(txAttr != null &amp;&amp; tm instanceof CallbackPreferringPlatformTransactionManager) &#123;</div><div class="line">    try &#123;</div><div class="line">      Object ex1 = ((CallbackPreferringPlatformTransactionManager)tm).execute(txAttr, new TransactionCallback() &#123;</div><div class="line">        public Object doInTransaction(TransactionStatus status) &#123;</div><div class="line">          TransactionAspectSupport.TransactionInfo txInfo = TransactionAspectSupport.this.prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);／／创建事务，同时把事务过程中得到的信息放到TransactionInfo中去，TransactionInfo是保存当前事务状态的对象。</div><div class="line"></div><div class="line">          TransactionAspectSupport.ThrowableHolder var4;</div><div class="line">          try &#123;</div><div class="line">            Object ex = invocation.proceedWithInvocation();</div><div class="line">            return ex;</div><div class="line">          &#125; catch (Throwable var8) &#123;</div><div class="line">            if(txAttr.rollbackOn(var8)) &#123;</div><div class="line">              if(var8 instanceof RuntimeException) &#123;</div><div class="line">                throw (RuntimeException)var8;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              throw new TransactionAspectSupport.ThrowableHolderException(var8);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            var4 = new TransactionAspectSupport.ThrowableHolder(var8);</div><div class="line">          &#125; finally &#123;</div><div class="line">            TransactionAspectSupport.this.cleanupTransactionInfo(txInfo);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          return var4;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">      if(ex1 instanceof TransactionAspectSupport.ThrowableHolder) &#123;</div><div class="line">        throw ((TransactionAspectSupport.ThrowableHolder)ex1).getThrowable();</div><div class="line">      &#125; else &#123;</div><div class="line">        return ex1;</div><div class="line">      &#125;</div><div class="line">    &#125; catch (TransactionAspectSupport.ThrowableHolderException var14) &#123;</div><div class="line">      throw var14.getCause();</div><div class="line">    &#125;</div><div class="line">  &#125; else &#123;</div><div class="line">    TransactionAspectSupport.TransactionInfo ex = this.createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</div><div class="line">    Object retVal = null;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">      retVal = invocation.proceedWithInvocation();／／这里的调用使处理沿着拦截器链进行，使最后目标对象的方法得到调用</div><div class="line">    &#125; catch (Throwable var15) &#123;</div><div class="line">      this.completeTransactionAfterThrowing(ex, var15);／／如果事务处理方法中调用出现了异常，事务处理如何进行需要根据具体情况考虑是否会滚或者提交</div><div class="line">      throw var15;</div><div class="line">    &#125; finally &#123;</div><div class="line">      this.cleanupTransactionInfo(ex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.commitTransactionAfterReturning(ex);//这里通过事务处理器来对事务进行提交</div><div class="line">    return retVal;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于Spring而言，事务管理实际上是通过一个TransactionInfo对象来完成的，在该对象中，封装了事务对象和事务处理的状态信息，这是事务处理的抽象。在这一步完成以后，会对拦截器链进行处理，因为有可能在该事务对象中还配置了除事务处理AOP之外的其他拦截器，在结束对拦截器链处理之后，会对 TransactionInfo中的信息进行更新，以反映最近的事务处理情况，在这个时候，也就完成了事务提交的准备，通过调用事务处理器PlatformTransactionManager的commitTransactionAfterReturning方法来完成事务的提交。这个提交的处理过程已经封装在事务处理器中了，而与具体数据源相关的处理过程，最终委托给相关的事务处理器完成，如：DataSourceTransactionManager、HibernateTransactionManager等。</p>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-11%20%E4%B8%8B%E5%8D%8810.51.15.png" alt="事务提交时序图"></p>
<p>这个invoke方法的实现中，可以看到整个事务处理在AOP拦截器中实现的全过程。同时，它也是Spring采用AOP封装事务处理和实现声明式事务处理的核心部分。</p>
<h3 id="Spring事务处理的设计与实现"><a href="#Spring事务处理的设计与实现" class="headerlink" title="Spring事务处理的设计与实现"></a>Spring事务处理的设计与实现</h3><h4 id="Spring事务传播属性"><a href="#Spring事务传播属性" class="headerlink" title="Spring事务传播属性"></a>Spring事务传播属性</h4><blockquote>
<p>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。<br>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。  PROPAGATION_NESTED –<br>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。<br>前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。</p>
</blockquote>
<h4 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h4><p>声明式事务中，TransactionInterceptor拦截器的invoke方法作为事务处理实现的起点，invoke方法中createTransactionIfNeccessary方法作为事务创建的入口。以下是createTransactionIfNeccessary方法的时序图</p>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-11%20%E4%B8%8B%E5%8D%8811.09.41.png" alt="createTransactionIfNeccessary方法的时序图"></p>
<p>在createTransactionIfNeccessary中首先会向AbstractTransactionManager执行getTransaction，这个获取Transaction事务对象的过程，在AbstractTransactionManager中需要对事务不同的情况作出处理，然后创建一个TransactionStatus，并把这个TransactionStatus设置到对应的TransactionInfo中去，同时将TransactionInfo和当前的线程绑定，从而完成事务的创建过程。TransactionStatus和TransactionInfo这俩个对象持有的数据是事务处理器对事务进行处理的主要依据。对这俩个对象的使用贯穿整个事务处理的全过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">protected TransactionAspectSupport.TransactionInfo createTransactionIfNecessary(PlatformTransactionManager tm, final TransactionAttribute txAttr, final String joinpointIdentification) &#123;</div><div class="line">  if(txAttr != null &amp;&amp; ((TransactionAttribute)txAttr).getName() == null) &#123;</div><div class="line">    txAttr = new DelegatingTransactionAttribute((TransactionAttribute)txAttr) &#123;</div><div class="line">      public String getName() &#123;</div><div class="line">        return joinpointIdentification;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  TransactionStatus status = null;</div><div class="line">  if(txAttr != null) &#123;</div><div class="line">    if(tm != null) &#123;</div><div class="line">      status = tm.getTransaction((TransactionDefinition)txAttr);／／这里使用了定义好的事务方法的配置信息。事务创建由事务处理器来完成，同时返回TransactionStatus来记录当前的事务状态，包括已经创建的事务。</div><div class="line">    &#125; else if(this.logger.isDebugEnabled()) &#123;</div><div class="line">      this.logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification + &quot;] because no transaction manager has been configured&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return this.prepareTransactionInfo(tm, (TransactionAttribute)txAttr, joinpointIdentification, status);</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected TransactionAspectSupport.TransactionInfo prepareTransactionInfo(PlatformTransactionManager tm, TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) &#123;</div><div class="line">  TransactionAspectSupport.TransactionInfo txInfo = new TransactionAspectSupport.TransactionInfo(tm, txAttr, joinpointIdentification);</div><div class="line">  if(txAttr != null) &#123;</div><div class="line">    if(this.logger.isTraceEnabled()) &#123;</div><div class="line">      this.logger.trace(&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    txInfo.newTransactionStatus(status);</div><div class="line">  &#125; else if(this.logger.isTraceEnabled()) &#123;</div><div class="line">    this.logger.trace(&quot;Don\&apos;t need to create transaction for [&quot; + joinpointIdentification + &quot;]: This method isn\&apos;t transactional.&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  txInfo.bindToThread();</div><div class="line">  return txInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getTansaction实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException &#123;</div><div class="line">       Object transaction = doGetTransaction();</div><div class="line"></div><div class="line">       // Cache debug flag to avoid repeated checks.</div><div class="line">       boolean debugEnabled = logger.isDebugEnabled();</div><div class="line"></div><div class="line">       if (definition == null) &#123;</div><div class="line">              // Use defaults if no transaction definition given.</div><div class="line">              definition = new DefaultTransactionDefinition();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (isExistingTransaction(transaction)) &#123;</div><div class="line">              // Existing transaction found -&gt; check propagation behavior to find out how to behave.</div><div class="line">              return handleExistingTransaction(definition, transaction, debugEnabled);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Check definition settings for new transaction.</div><div class="line">       if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</div><div class="line">              throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());</div><div class="line">       &#125;</div><div class="line">／／没有事务存在，需要根据事务传播属性设置来创建事务，这里会看到事务传播属性的设置：mandatory、required required_new nested等</div><div class="line">       // No existing transaction found -&gt; check propagation behavior to find out how to proceed.</div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</div><div class="line">              throw new IllegalTransactionStateException(</div><div class="line">                            &quot;No existing transaction found for transaction marked with propagation &apos;mandatory&apos;&quot;);</div><div class="line">       &#125;</div><div class="line">       else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</div><div class="line">                     definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</div><div class="line">                     definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</div><div class="line">              SuspendedResourcesHolder suspendedResources = suspend(null);</div><div class="line">              if (debugEnabled) &#123;</div><div class="line">                     logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);</div><div class="line">              &#125;</div><div class="line">              try &#123;</div><div class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">                     DefaultTransactionStatus status = newTransactionStatus(</div><div class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</div><div class="line">                     doBegin(transaction, definition);</div><div class="line">                     prepareSynchronization(status, definition);</div><div class="line">                     return status;</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException ex) &#123;</div><div class="line">                     resume(null, suspendedResources);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (Error err) &#123;</div><div class="line">                     resume(null, suspendedResources);</div><div class="line">                     throw err;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line">       else &#123;</div><div class="line">              // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</div><div class="line">              if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</div><div class="line">                     logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +</div><div class="line">                                   &quot;isolation level will effectively be ignored: &quot; + definition);</div><div class="line">              &#125;</div><div class="line">              boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</div><div class="line">              return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handleExsitingTransaction方法是理解Spring事务传播属性的关键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Create a TransactionStatus for an existing transaction.</div><div class="line">*/</div><div class="line">private TransactionStatus handleExistingTransaction(</div><div class="line">              TransactionDefinition definition, Object transaction, boolean debugEnabled)</div><div class="line">              throws TransactionException &#123;</div><div class="line"></div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</div><div class="line">              throw new IllegalTransactionStateException(</div><div class="line">                            &quot;Existing transaction found for transaction marked with propagation &apos;never&apos;&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</div><div class="line">              if (debugEnabled) &#123;</div><div class="line">                     logger.debug(&quot;Suspending current transaction&quot;);</div><div class="line">              &#125;</div><div class="line">              Object suspendedResources = suspend(transaction);</div><div class="line">              boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</div><div class="line">              return prepareTransactionStatus(</div><div class="line">                            definition, null, false, newSynchronization, debugEnabled, suspendedResources);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</div><div class="line">              if (debugEnabled) &#123;</div><div class="line">                     logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; +</div><div class="line">                                   definition.getName() + &quot;]&quot;);</div><div class="line">              &#125;</div><div class="line">              SuspendedResourcesHolder suspendedResources = suspend(transaction);</div><div class="line">              try &#123;</div><div class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">                     DefaultTransactionStatus status = newTransactionStatus(</div><div class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</div><div class="line">                     doBegin(transaction, definition);</div><div class="line">                     prepareSynchronization(status, definition);</div><div class="line">                     return status;</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException beginEx) &#123;</div><div class="line">                     resumeAfterBeginException(transaction, suspendedResources, beginEx);</div><div class="line">                     throw beginEx;</div><div class="line">              &#125;</div><div class="line">              catch (Error beginErr) &#123;</div><div class="line">                     resumeAfterBeginException(transaction, suspendedResources, beginErr);</div><div class="line">                     throw beginErr;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</div><div class="line">              if (!isNestedTransactionAllowed()) &#123;</div><div class="line">                     throw new NestedTransactionNotSupportedException(</div><div class="line">                                   &quot;Transaction manager does not allow nested transactions by default - &quot; +</div><div class="line">                                   &quot;specify &apos;nestedTransactionAllowed&apos; property with value &apos;true&apos;&quot;);</div><div class="line">              &#125;</div><div class="line">              if (debugEnabled) &#123;</div><div class="line">                     logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;);</div><div class="line">              &#125;</div><div class="line">              if (useSavepointForNestedTransaction()) &#123;／／在Spring管理的事务中，创建事务保存点</div><div class="line">                     // Create savepoint within existing Spring-managed transaction,</div><div class="line">                     // through the SavepointManager API implemented by TransactionStatus.</div><div class="line">                     // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</div><div class="line">                     DefaultTransactionStatus status =</div><div class="line">                                   prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);</div><div class="line">                     status.createAndHoldSavepoint();</div><div class="line">                     return status;</div><div class="line">              &#125;</div><div class="line">              else &#123;</div><div class="line">                     // Nested transaction through nested begin and commit/rollback calls.</div><div class="line">                     // Usually only for JTA: Spring synchronization might get activated here</div><div class="line">                     // in case of a pre-existing JTA transaction.</div><div class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">                     DefaultTransactionStatus status = newTransactionStatus(</div><div class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, null);</div><div class="line">                     doBegin(transaction, definition);</div><div class="line">                     prepareSynchronization(status, definition);</div><div class="line">                     return status;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</div><div class="line">       if (debugEnabled) &#123;</div><div class="line">              logger.debug(&quot;Participating in existing transaction&quot;);</div><div class="line">       &#125;</div><div class="line">       if (isValidateExistingTransaction()) &#123;</div><div class="line">              if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</div><div class="line">                     Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</div><div class="line">                     if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) &#123;</div><div class="line">                            Constants isoConstants = DefaultTransactionDefinition.constants;</div><div class="line">                            throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</div><div class="line">                                          definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; +</div><div class="line">                                          (currentIsolationLevel != null ?</div><div class="line">                                                        isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</div><div class="line">                                                        &quot;(unknown)&quot;));</div><div class="line">                     &#125;</div><div class="line">              &#125;</div><div class="line">              if (!definition.isReadOnly()) &#123;</div><div class="line">                     if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</div><div class="line">                            throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</div><div class="line">                                          definition + &quot;] is not marked as read-only but existing transaction is&quot;);</div><div class="line">                     &#125;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line">       boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">       return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事务挂起"><a href="#事务挂起" class="headerlink" title="事务挂起"></a>事务挂起</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException &#123;／／返回的SuspendedResourcesHolder会作为参数传给TransactionStatus</div><div class="line">       if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</div><div class="line">              List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</div><div class="line">              try &#123;</div><div class="line">                     Object suspendedResources = null;／／把挂起事务的处理交给具体事务处理器去完成，如果具体的事务处理器不支持事务挂起，则默认抛出TransactionSuspensionNotSupportedException</div><div class="line">                     if (transaction != null) &#123;</div><div class="line">                            suspendedResources = doSuspend(transaction);</div><div class="line">                     &#125;//这里在线程中保存与事务处理有关的信息，并重置线程中相关的ThreadLocal变量</div><div class="line">                     String name = TransactionSynchronizationManager.getCurrentTransactionName();</div><div class="line">                     TransactionSynchronizationManager.setCurrentTransactionName(null);</div><div class="line">                     boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</div><div class="line">                     TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);</div><div class="line">                     Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</div><div class="line">                     TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);</div><div class="line">                     boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();</div><div class="line">                     TransactionSynchronizationManager.setActualTransactionActive(false);</div><div class="line">                     return new SuspendedResourcesHolder(</div><div class="line">                                   suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException ex) &#123;</div><div class="line">                     // doSuspend failed - original transaction is still active… 如果处理失败，则恢复原始的事务</div><div class="line">                     doResumeSynchronization(suspendedSynchronizations);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (Error err) &#123;</div><div class="line">                     // doSuspend failed - original transaction is still active...</div><div class="line">                     doResumeSynchronization(suspendedSynchronizations);</div><div class="line">                     throw err;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line">       else if (transaction != null) &#123;</div><div class="line">              // Transaction active but no synchronization active.</div><div class="line">              Object suspendedResources = doSuspend(transaction);</div><div class="line">              return new SuspendedResourcesHolder(suspendedResources);</div><div class="line">       &#125;</div><div class="line">       else &#123;</div><div class="line">              // Neither transaction nor synchronization active.</div><div class="line">              return null;</div><div class="line">       &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Reactivate transaction synchronization for the current thread</div><div class="line"> * and resume all given synchronizations.</div><div class="line"> * @param suspendedSynchronizations List of TransactionSynchronization objects</div><div class="line"> */doSuspend 失败则恢复事务</div><div class="line">private void doResumeSynchronization(List&lt;TransactionSynchronization&gt; suspendedSynchronizations) &#123;</div><div class="line">       TransactionSynchronizationManager.initSynchronization();／／维护着ThreadLocal变量</div><div class="line">       for (TransactionSynchronization synchronization : suspendedSynchronizations) &#123;</div><div class="line">              synchronization.resume();</div><div class="line">              TransactionSynchronizationManager.registerSynchronization(synchronization);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事务的提交"><a href="#事务的提交" class="headerlink" title="事务的提交"></a>事务的提交</h4><p>在声明式事务处理中，事务的提交在TransactionInteceptor的invoke方法中实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">commitTransactionAfterReturning(txInfo)</div></pre></td></tr></table></figure></p>
<p>txInfo是TransactionInfo对象，是创建事务时生成的。同时，Spring的事务管理框架的生成的TransactionStatus对象就包含在TransactionInfo对象中。commitTransactionAfterReturning具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void commitTransactionAfterReturning(TransactionAspectSupport.TransactionInfo txInfo) &#123;</div><div class="line">  if(txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;</div><div class="line">    if(this.logger.isTraceEnabled()) &#123;</div><div class="line">      this.logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用具体的事务管理器实现。而在事务管理器中的实现在AbstractPlatformTransactionManager中存在一个模版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* This implementation of commit handles participating in existing</div><div class="line">* transactions and programmatic rollback requests.</div><div class="line">* Delegates to &#123;@code isRollbackOnly&#125;, &#123;@code doCommit&#125;</div><div class="line">* and &#123;@code rollback&#125;.</div><div class="line">* @see org.springframework.transaction.TransactionStatus#isRollbackOnly()</div><div class="line">* @see #doCommit</div><div class="line">* @see #rollback</div><div class="line">*/</div><div class="line">@Override</div><div class="line">public final void commit(TransactionStatus status) throws TransactionException &#123;</div><div class="line">       if (status.isCompleted()) &#123;</div><div class="line">              throw new IllegalTransactionStateException(</div><div class="line">                            &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</div><div class="line">       if (defStatus.isLocalRollbackOnly()) &#123;／／如果事务处理过程中发生了异常，调用回滚。</div><div class="line">              if (defStatus.isDebug()) &#123;</div><div class="line">                     logger.debug(&quot;Transactional code has requested rollback&quot;);</div><div class="line">              &#125;</div><div class="line">              processRollback(defStatus);</div><div class="line">              return;</div><div class="line">       &#125;</div><div class="line">       if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</div><div class="line">              if (defStatus.isDebug()) &#123;</div><div class="line">                     logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);</div><div class="line">              &#125;／／处理回滚</div><div class="line">              processRollback(defStatus);</div><div class="line">              // Throw UnexpectedRollbackException only at outermost transaction boundary</div><div class="line">              // or if explicitly asked to.</div><div class="line">              if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</div><div class="line">                     throw new UnexpectedRollbackException(</div><div class="line">                                   &quot;Transaction rolled back because it has been marked as rollback-only&quot;);</div><div class="line">              &#125;</div><div class="line">              return;</div><div class="line">       &#125;</div><div class="line">       ／／处理提交入口</div><div class="line">       processCommit(defStatus);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出rollback和commit都在这个方法中实现。看看 processCommit的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;</div><div class="line">       try &#123;</div><div class="line">              boolean beforeCompletionInvoked = false;</div><div class="line">              try &#123;／／事务的提交准备工作由具体的事务处理器来完成</div><div class="line">                     prepareForCommit(status);</div><div class="line">                     triggerBeforeCommit(status);</div><div class="line">                     triggerBeforeCompletion(status);</div><div class="line">                     beforeCompletionInvoked = true;</div><div class="line">                     boolean globalRollbackOnly = false;</div><div class="line">                     if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</div><div class="line">                            globalRollbackOnly = status.isGlobalRollbackOnly();</div><div class="line">                     &#125;／／嵌套事务的处理过程。</div><div class="line">                     if (status.hasSavepoint()) &#123;</div><div class="line">                            if (status.isDebug()) &#123;</div><div class="line">                                   logger.debug(&quot;Releasing transaction savepoint&quot;);</div><div class="line">                            &#125;</div><div class="line">                            status.releaseHeldSavepoint();</div><div class="line">                     &#125;</div><div class="line">                     else if (status.isNewTransaction()) &#123;／／根据当前线程中保存的事务状态进行处理，如果当前的事务是一个新的事务，调用具体事务处理器的完成提交，如果当前所持有的事务不是一个新事务，则不提交，由已经存在的事务来完成提交</div><div class="line">                            if (status.isDebug()) &#123;</div><div class="line">                                   logger.debug(&quot;Initiating transaction commit&quot;);</div><div class="line">                            &#125;</div><div class="line">                            doCommit(status);</div><div class="line">                     &#125;</div><div class="line">                     // Throw UnexpectedRollbackException if we have a global rollback-only</div><div class="line">                     // marker but still didn&apos;t get a corresponding exception from commit.</div><div class="line">                     if (globalRollbackOnly) &#123;</div><div class="line">                            throw new UnexpectedRollbackException(</div><div class="line">                                          &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);</div><div class="line">                     &#125;</div><div class="line">              &#125;</div><div class="line">              catch (UnexpectedRollbackException ex) &#123;</div><div class="line">                     // can only be caused by doCommit</div><div class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (TransactionException ex) &#123;</div><div class="line">                     // can only be caused by doCommit</div><div class="line">                     if (isRollbackOnCommitFailure()) &#123;</div><div class="line">                            doRollbackOnCommitException(status, ex);</div><div class="line">                     &#125;</div><div class="line">                     else &#123;</div><div class="line">                            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</div><div class="line">                     &#125;</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException ex) &#123;</div><div class="line">                     if (!beforeCompletionInvoked) &#123;</div><div class="line">                            triggerBeforeCompletion(status);</div><div class="line">                     &#125;</div><div class="line">                     doRollbackOnCommitException(status, ex);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (Error err) &#123;</div><div class="line">                     if (!beforeCompletionInvoked) &#123;</div><div class="line">                            triggerBeforeCompletion(status);</div><div class="line">                     &#125;</div><div class="line">                     doRollbackOnCommitException(status, err);</div><div class="line">                     throw err;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              // Trigger afterCommit callbacks, with an exception thrown there</div><div class="line">              // propagated to callers but the transaction still considered as committed.</div><div class="line">              try &#123;</div><div class="line">                     triggerAfterCommit(status);</div><div class="line">              &#125;</div><div class="line">              finally &#123;</div><div class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">       finally &#123;</div><div class="line">              cleanupAfterCompletion(status);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，对事务的提交处理都是紧紧围绕TransactionStatus保存的事务处理相关状态进行判断。具体的提交处理过程都设计成抽象方法，交由具体的事务处理器来完成。</p>
<h4 id="事务的回滚"><a href="#事务的回滚" class="headerlink" title="事务的回滚"></a>事务的回滚</h4><p>在事务的提交方法中看到了事务的回滚入口，即processRollback方法，其实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">private void processRollback(DefaultTransactionStatus status) &#123;</div><div class="line">       try &#123;</div><div class="line">              try &#123;</div><div class="line">                     triggerBeforeCompletion(status);</div><div class="line">                     if (status.hasSavepoint()) &#123;／／嵌套事务的回滚处理</div><div class="line">                            if (status.isDebug()) &#123;</div><div class="line">                                   logger.debug(&quot;Rolling back transaction to savepoint&quot;);</div><div class="line">                            &#125;</div><div class="line">                            status.rollbackToHeldSavepoint();</div><div class="line">                     &#125;／／当前事务调用方法中新建事务的回滚处理</div><div class="line">                     else if (status.isNewTransaction()) &#123;</div><div class="line">                            if (status.isDebug()) &#123;</div><div class="line">                                   logger.debug(&quot;Initiating transaction rollback&quot;);</div><div class="line">                            &#125;</div><div class="line">                            doRollback(status);</div><div class="line">                     &#125;／／如果在当前事务调用方法中没有新建事务的回滚处理</div><div class="line">                     else if (status.hasTransaction()) &#123;</div><div class="line">                            if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</div><div class="line">                                   if (status.isDebug()) &#123;</div><div class="line">                                          logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);</div><div class="line">                                   &#125;</div><div class="line">                                   doSetRollbackOnly(status);</div><div class="line">                            &#125;／／由线程的前一个事务来处理回滚，这里不执行任何操作。</div><div class="line">                            else &#123;</div><div class="line">                                   if (status.isDebug()) &#123;</div><div class="line">                                          logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);</div><div class="line">                                   &#125;</div><div class="line">                            &#125;</div><div class="line">                     &#125;</div><div class="line">                     else &#123;</div><div class="line">                            logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);</div><div class="line">                     &#125;</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException ex) &#123;</div><div class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (Error err) &#123;</div><div class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</div><div class="line">                     throw err;</div><div class="line">              &#125;</div><div class="line">              triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</div><div class="line">       &#125;</div><div class="line">       finally &#123;</div><div class="line">              cleanupAfterCompletion(status);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，看了代码我们很快就能理解，Spring 事务传播属性中的 Required_New和NESTED（嵌套事务）的本质区别</p>
<ol>
<li>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行. </li>
<li>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,它将取得一个 savepoint. 如果这个嵌套事务失败,我们将回滚到此savepoint潜套事务是外部事务的一部分,只有外部事务结束后它才会被提交。</li>
<li>由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back. </li>
</ol>
<p>也就是说：</p>
<ol>
<li>PROPAGATION_REQUIRES_NEW事务不受外部事务的影响，是隔离的。</li>
<li>PROPAGATION_NESTED，如果内部事务失败且内部，它会回到savepoint之前的状态不会产生脏数据，而外部事务catch住异常后可以选择回滚或者提交；如果外部事务失败，由于嵌套事务是外部事务的一部分，则会导致外部事务与嵌套事务一起回滚。</li>
</ol>
</div><div class="tags"><a href="/tags/spring/">spring</a><a href="/tags/ioc/">ioc</a><a href="/tags/aop/">aop</a><a href="/tags/源码/">源码</a><a href="/tags/事务处理/">事务处理</a></div><div class="post-nav"><a href="/2017/02/15/InnoDB读书笔记/" class="pre">InnoDB读书笔记</a><a href="/2017/02/07/Spring源码解读/" class="next">Spring源码解读(-)</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'https://jacobs-wanhb.disqus.com/embed.js';
var disqus_identifier = '2017/02/12/Spring源码解析-事务处理/';
var disqus_title = 'Spring源码解析--事务处理';
var disqus_url = 'http://yoursite.com/2017/02/12/Spring源码解析-事务处理/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//https://jacobs-wanhb.disqus.com/embed.js.disqus.com/count.js" async></script></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/superset-customization/">superset customization</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/23/lombok-builder-泛型擦除问题/">lombok builder 泛型擦除</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Kylin二次开发——测试环境搭建/">Kylin二次开发——测试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/kylin-master-slave同步原理及问题排查/">kylin master-slave同步原理及问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/HBase架构脑图/">HBase架构脑图</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/02/Kylin学习笔记/">Kylin学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/11/Spark学习笔记/">Spark学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/HBase学习与经验总结/">HBase学习与经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/15/InnoDB读书笔记/">InnoDB读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/12/Spring源码解析-事务处理/">Spring源码解析--事务处理</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>