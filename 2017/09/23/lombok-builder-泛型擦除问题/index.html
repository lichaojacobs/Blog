<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content><title>lombok builder 泛型擦除 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">lombok builder 泛型擦除</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">lombok builder 泛型擦除</h1><div class="post-meta">Sep 23, 2017<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>众所周知，Java长期以来比较遭业界嫌弃的是太笨重，代码冗余过大。然而依托于Java庞大健全的开源社区，这些缺点正在逐渐改善。Java 8 引进的lambda以及函数式编程的思想让我们的代码越来越简洁。lombok等各大开源神器让我们的冗余代码越来越少。</p>
</li>
<li><p>使用lombok已经很长时间了，一直很好用，然而最近发现使用lombok builder构造泛型的时候会出现泛型擦除的情况，导致得到的对象是Object类型</p>
</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>定义一个待使用builder构造的泛型类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Builder</span><br><span class="line">public class PageableResponse&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  List&lt;T&gt; results;</span><br><span class="line">  @SerializedName(&quot;total_pages&quot;)</span><br><span class="line">  long totalPages;</span><br><span class="line">  @SerializedName(&quot;total_elements&quot;)</span><br><span class="line">  long totalElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下，我是可以这样使用的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public PageableResponse&lt;String&gt; getPageableResponse() &#123;</span><br><span class="line">  return PageableResponse</span><br><span class="line">      .builder()</span><br><span class="line">      .results(Lists.newArrayList())</span><br><span class="line">      .totalElements(0)</span><br><span class="line">      .totalPages(0)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而出现类型转换错误，PageableResponse.builder()生成的是PageableResponse.PageableResponseBuilder<code>&lt;Object&gt;</code> 想来也是，我这里调用builder方法时候并没有指定任何类型。</p>
<h3 id="泛型基础知识"><a href="#泛型基础知识" class="headerlink" title="泛型基础知识"></a>泛型基础知识</h3><p>那为什么会得到这样的结果？这里就要回顾一下泛型的知识了，这里我们的场景比较复杂一点，属于泛型类里面的静态泛型方法。这里提一下知识点：</p>
<h5 id="java泛型转换的几个事实："><a href="#java泛型转换的几个事实：" class="headerlink" title="java泛型转换的几个事实："></a>java泛型转换的几个事实：</h5><ul>
<li>虚拟机中没有泛型，只有普通的类和方法</li>
<li>无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，替换为限定类型（无限定的变量用Object）。当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换</li>
<li>所有的类型参数都用它们的限定类型替换 如:Pair<code>&lt;T&gt;</code> 擦除类型之后就变成了Pair<code>&lt;Object&gt;</code></li>
<li>桥方法被合成来保持多态</li>
<li>为保证类型安全性，必要时插入强制类型转换</li>
</ul>
<h5 id="泛型的约束与局限性"><a href="#泛型的约束与局限性" class="headerlink" title="泛型的约束与局限性"></a>泛型的约束与局限性</h5><ul>
<li><p>不能用基本类型实例化类型参数</p>
</li>
<li><p>运行时类型查询只适用于原始类型:</p>
<ul>
<li>if(a instanceof Pair<code>&lt;String&gt;</code>)//ERROR</li>
<li><p>同理getClass方法也总是返回原始类型:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair=...</span><br><span class="line">Pair&lt;Employ&gt; employPair=...</span><br><span class="line">if(stringPair.getClass()==employPair.getClass()) //True</span><br><span class="line">//两次调用都将返回Pair.class</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不能创建参数化类型数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]//ERROR</span><br><span class="line">//类型擦除之后，table的类型是Pair[]。可以把它转换为Object[]</span><br><span class="line">Object[] arr = table</span><br><span class="line">//数组会记住它的元素类型，如果试图存储其他类型的元素，会抛出ArrayStoreException异常</span><br><span class="line">//只是不允许创建这些数组，但是声明类型为Pair&lt;String&gt;[]的变量仍是合法的，只是不能用new Pair&lt;String&gt;[10]初始化这个变量</span><br><span class="line">//可以声明通配类型的数组，然后进行类型转换，导致的结果将是不安全的</span><br><span class="line">Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能实例化类型变量: 不能new T(….)</p>
<ul>
<li>类型擦除会将T改变成Object，而且，本意肯定不希望调用new Object()</li>
<li><p>可以通过反射调用Class.newInstance方法来构造泛型对象，细节有点复杂</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//不能以下方式调用</span><br><span class="line">first = T.class.newInstance();//ERROR</span><br><span class="line">//表达式T.class是不合法的，必须如下方式才可以支配Class对象：</span><br><span class="line"></span><br><span class="line">public static&lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)&#123;</span><br><span class="line">   try &#123; return new Pair&lt;&gt;(cl.newInstance(),cl.newInstance()) &#125;</span><br><span class="line">   catch (Exception ex) &#123; return null; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br><span class="line">//注意，Class类本身就是泛型，String.class是一个Class&lt;String&gt;的实例（唯一实例）。因此makePair方法能够判断出pair的类型。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不能以如下的方式构造泛型数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//类型擦除会让这个方法永远构造Object[2]数组，而要求extends Comparable，这显然会抛出转换异常</span><br><span class="line">// 此时可以把 extends Comparable去掉，这样能保证强制转换的正确性</span><br><span class="line">public static &lt;T extends Comparable&gt; T[] minmax(T... a) &#123;</span><br><span class="line"></span><br><span class="line">   	Object[] mm = new Object[2];</span><br><span class="line">   	mm[0] = a[0];</span><br><span class="line">   	mm[1] = a[1];</span><br><span class="line"></span><br><span class="line">   	return (T[]) mm;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	或者使用反射，调用Array.newInstance:</span><br><span class="line"></span><br><span class="line"> 	public static &lt;T extends Comparable&gt; T[] minmax(T... a) &#123;</span><br><span class="line"></span><br><span class="line">   	T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), 2);</span><br><span class="line">   	...</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="泛型类里面的泛型方法和静态泛型方法是有区别的："><a href="#泛型类里面的泛型方法和静态泛型方法是有区别的：" class="headerlink" title="泛型类里面的泛型方法和静态泛型方法是有区别的："></a>泛型类里面的泛型方法和静态泛型方法是有区别的：</h5><ul>
<li>泛型类定义的泛型 在整个类中有效 如果被方法使用，当泛型类确定类型之后，泛型方法也就确定类型了</li>
<li>而对于静态泛型方法而言，其泛型的类型是不依赖于泛型类的类型，也就是这两者的类型完全不相干（依据上一条的事实一）</li>
</ul>
<h5 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h5><ul>
<li>考虑一个类和一个子类，如Employee和Manager。Pair<code>&lt;Manager&gt;</code> 却不是Pair<code>&lt;Employee&gt;</code>的子类。事实上，它们的关系如下图所示</li>
</ul>
<p><img src="http://jacobs.wanhb.cn/images/generics1.png" alt></p>
<ul>
<li>泛型类可以扩展或实现其他泛型类。这一点与普通的类没什么区别。如：ArrayList<code>&lt;T&gt;</code> 类实现List<code>&lt;T&gt;</code>接口，意味着一个ArrayList<code>&lt;Manager&gt;</code> 可以被转换为一个List<code>&lt;Manager&gt;</code>。但是一个ArrayList<code>&lt;Manager&gt;</code> 不是一个ArrayList<code>&lt;Employee&gt;</code> 或者List<code>&lt;Employee&gt;</code>，它们的关系如下图:</li>
</ul>
<p><img src="http://jacobs.wanhb.cn/images/generics2.png" alt></p>
<h3 id="案例解释"><a href="#案例解释" class="headerlink" title="案例解释"></a>案例解释</h3><ul>
<li>泛型知识作了一番复习之后，我们再回到上面的案例。之所以无法正常的使用builder，是因为静态泛型方法不继承泛型类的类型。下面是案例类生成的代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class PageableResponse&lt;T&gt; &#123;</span><br><span class="line">  List&lt;T&gt; results;</span><br><span class="line">  @JSONField(</span><br><span class="line">    name = &quot;total_pages&quot;</span><br><span class="line">  )</span><br><span class="line">  long totalPages;</span><br><span class="line">  @JSONField(</span><br><span class="line">    name = &quot;total_elements&quot;</span><br><span class="line">  )</span><br><span class="line">  long totalElements;</span><br><span class="line"></span><br><span class="line">  //这个T不依赖于PageableResponse&lt;T&gt;的T</span><br><span class="line">  public static &lt;T&gt; PageableResponse.PageableResponseBuilder&lt;T&gt; builder() &#123;</span><br><span class="line">    return new PageableResponse.PageableResponseBuilder();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>而正常的没有泛型的生成代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Address &#123;</span><br><span class="line">  private String city;</span><br><span class="line"></span><br><span class="line">  //不带泛型</span><br><span class="line">  public static Address.AddressBuilder builder() &#123;</span><br><span class="line">    return new Address.AddressBuilder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Address() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @ConstructorProperties(&#123;&quot;city&quot;&#125;)</span><br><span class="line">  public Address(String city) &#123;</span><br><span class="line">    this.city = city;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class AddressBuilder &#123;</span><br><span class="line">    private String city;</span><br><span class="line"></span><br><span class="line">    AddressBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address.AddressBuilder city(String city) &#123;</span><br><span class="line">      this.city = city;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address build() &#123;</span><br><span class="line">      return new Address(this.city);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">      return &quot;Address.AddressBuilder(city=&quot; + this.city + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以如果必须要使用泛型且如果这种情况不是太多的话，可以自己实现lombok的builder生成的代码，以案例定义的类为例，改造完的代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class PageableResponse&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  List&lt;T&gt; results;</span><br><span class="line">  @SerializedName(&quot;total_pages&quot;)</span><br><span class="line">  long totalPages;</span><br><span class="line">  @SerializedName(&quot;total_elements&quot;)</span><br><span class="line">  long totalElements;</span><br><span class="line"></span><br><span class="line">  //这里使用非静态方法的写法可以达到继承泛型类型的目的</span><br><span class="line">  public PageableResponseBuilder&lt;T&gt; builder() &#123;</span><br><span class="line">    return new PageableResponseBuilder&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public class PageableResponseBuilder&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; results;</span><br><span class="line">    long totalPages;</span><br><span class="line">    long totalElements;</span><br><span class="line"></span><br><span class="line">    public PageableResponseBuilder&lt;T&gt; totalPages(long totalPages) &#123;</span><br><span class="line">      this.totalPages = totalPages;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PageableResponseBuilder&lt;T&gt; totalElements(long totalElements) &#123;</span><br><span class="line">      this.totalElements = totalElements;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PageableResponseBuilder&lt;T&gt; results(List&lt;T&gt; results) &#123;</span><br><span class="line">      this.results = results;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PageableResponse&lt;T&gt; build() &#123;</span><br><span class="line">      return new PageableResponse&lt;&gt;(results, totalPages, totalElements);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://ol7zjjc80.bkt.clouddn.com/271524552778_.pic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/09/23/lombok-builder-泛型擦除问题/" data-id="ckjz5aro7000pu9yhrq2i5jqq" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvklEQVR42u3awYrdMAwF0Pn/n55CV4U2yb2WnTeFk1XIhBcfD1hC0tdXfH3/vv6+v3rnzyf3z6/+mry57cLDw8NbWvrVdbXQqyct4H7Lkq8/bAEeHh7eMV4bDNon9xuXn+1tcMLDw8P7LK9NhfMEvU2+8fDw8P4v3vzgTtL3/B4PDw/vU7z8k+0iklJsm3wfqbXg4eHhxbxJA+xT9y/19/Dw8PDKBDc/fNv329bX2mrx8PDwTvAmRdWENylbtAMEUa0FDw8Pbysvbz61waAtIrTb9xB+8PDw8I7x1hpga4d1WxRuNw4PDw/vHK/9cFJanZcqikP/fgvw8PDwDvDmP5pvQf7OZHwhSqzx8PDwBl9pi7btFqyFnPyXiwIuHh4e3lbe2uhVW2DNl9u20C5XiIeHh3eYlyxrUhRYCzMR48qCh4eHd4AXJaZxm6ptjL0UfvDw8PDeyGwXi7BJUMkT5bakW1x4eHh4W3ntcT9ZYp6UJ+l4xMbDw8N7hZe38POxqrzQkMNG8xF4eHh4JW+tnNoy8jJuHhgiNh4eHt5WXp6k5uFh0uxvyw0PW4yHh4f3Cq9tUE2S5vsglISBhy3Gw8PDO8BrU9tdISRPuNdS9uh/iIeHhzfgtc2thJdg8jJHe85HH8bDw8Nb4q2NAsyT7MkQQFHywMPDwzvAa4eudm1Kmyi3A154eHh453h7D/G1JLgF56NXeHh4eCd4a02ptfGpPBFPmnCLyTQeHh7emPddXvNxgbzxnwePyyCBh4eHd4DXHr75pqyVg+dpNB4eHt47vLVgMC8fREWEeHwhGiDAw8PD28pbCwZrZd9R1aQtpuDh4eH9AF6bduf4tcGFzYEBDw8PbytvXmBtBxGSsPGQ3OPh4eEd4+XFiMmQQX7E72qb4eHh4Z3gTRpRyejApFXWtty29ffw8PDw/r22X+94+T6hQ/3AAAAAAElFTkSuQmCC" class="article-share-link">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/成长/">成长</a></div><div class="post-nav"><a href="/2017/10/13/superset-customization/" class="pre">superset customization</a><a href="/2017/08/07/Kylin二次开发——测试环境搭建/" class="next">Kylin二次开发——测试环境搭建</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/Hadoop-Yarn/" style="font-size: 15px;">Hadoop - Yarn</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/kubernetes-源码/" style="font-size: 15px;">kubernetes - 源码</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/16/Netty源码解析系列：参数篇/">Netty源码解析系列：参数篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/27/kubernetes-shared-Informer-源码解析/">kubernetes shared Informer 源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/kubernetes-federation深度解析/">kubernetes federation深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/MR任务在Hadoop子系统中状态流转/">MR任务在Hadoop子系统中状态流转</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Yarn-Federation源码串读/">Yarn Federation源码串读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Hadoop-Rpc源码分析/">Hadoop Rpc源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/">【Spark源码分析】Job提交执行过程详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/【Spark源码分析】Broadcast/">【Spark源码分析】Broadcast</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/【Spark源码分析】Dynamic-Resource-Allocation设计的思考/">【Spark源码分析】Dynamic Resource Allocation设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/Raft论文学习/">Raft论文学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/chao-li-11/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://weibo.com/3101672623/profile?topnav=1&amp;wvr=6" title="微博" target="_blank">微博</a><ul></ul><a href="https://github.com/lichaojacobs" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>