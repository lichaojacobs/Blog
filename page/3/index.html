<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.7.1" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>CHAO LI&#39;s Blog</title>


    <meta property="og:type" content="website">
<meta property="og:title" content="CHAO LI&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="CHAO LI&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CHAO LI&#39;s Blog">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/hadoop_logo.jpg" alt="CHAO LI&#39;s Blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-05-02T02:40:01.000Z">2017-05-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15 分钟 读完 (大约 2193 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/05/02/Kylin学习笔记/">Kylin学习笔记</a>
            
        </h1>
        <div class="content">
            <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="OLAP-on-Line-AnalysisProcessing-的实现方式"><a href="#OLAP-on-Line-AnalysisProcessing-的实现方式" class="headerlink" title="OLAP(on-Line AnalysisProcessing)的实现方式"></a>OLAP(on-Line AnalysisProcessing)的实现方式</h3><ul>
<li>ROLAP:<br>基于关系数据库的OLAP实现（Relational OLAP）。ROLAP将多维数据库的多维结构划分为两类表:一类是事实表,用来存储数据和维关键字;另一类是维表,即对每个维至少使用一个表来存放维的层次、成员类别等维的描述信息。维表和事实表通过主关键字和外关键字联系在一起,形成了”星型模式”。对于层次复杂的维,为避免冗余数据占用过大的存储空间,可以使用多个表来描述,这种星型模式的扩展称为”雪花模式”。特点是将细节数据保留在关系型数据库的事实表中，聚合后的数据也保存在关系型的数据库中。这种方式查询效率最低，不推荐使用。</li>
<li><p>MOLAP:<br>多维数据组织的OLAP实现（Multidimensional OLAP。以多维数据组织方式为核心,也就是说,MOLAP使用多维数组存储数据。多维数据在存储中将形成”立方块（Cube）”的结构,在MOLAP中对”立方块”的”旋转”、”切块”、”切片”是产生多维数据报表的主要技术。特点是将细节数据和聚合后的数据均保存在cube中，所以以空间换效率，查询时效率高，但生成cube时需要大量的时间和空间。</p>
</li>
<li><p>HOLAP: 基于混合数据组织的OLAP实现（Hybrid OLAP）。如低层是关系型的，高层是多维矩阵型的。这种方式具有更好的灵活性。特点是将细节数据保留在关系型数据库的事实表中，但是聚合后的数据保存在cube中,聚合时需要比ROLAP更多的时间,查询效率比ROLAP高，但低于MOLAP。</p>
</li>
<li><p>kylin的cube数据是作为key-value结构存储在hbase中的，key是每一个维度成员的组合值，不同的cuboid下面的key的结构是不一样的，例如cuboid={brand，product，year}下面的一个key可能是brand=’Nike’，product=’shoe’，year=2015，那么这个key就可以写成Nike:shoe:2015，但是如果使用这种方式的话会出现很多重复，所以一般情况下我们会把一个维度下的所有成员取出来，然后保存在一个数组里面，使用数组的下标组合成为一个key，这样可以大大节省key的存储空间，kylin也使用了相同的方法，只不过使用了字典树（Trie树），每一个维度的字典树作为cube的元数据以二进制的方式存储在hbase中，内存中也会一直保持一份。</p>
</li>
</ul>
<h3 id="cube-构建"><a href="#cube-构建" class="headerlink" title="cube 构建"></a>cube 构建</h3><ul>
<li>Dimension：Mandatory、hierarchy、derived</li>
<li>增量cube: kylin的核心在于预计算缓存数据，因此无法达到真正的实时查询效果。一个cube中包含了多个segment，每一个segment对应着一个物理cube，在实际存储上对应着一个hbase的一个表。每次查询的时候会查询所有的segment聚合之后的值进行返回，但是当segment数量较多时，查询效率会降低，这时会对segment进行合并。被合并的几个segment所对应的hbase表并没有被删除。</li>
<li>cube词典树：cube数据是作为key-value结构存储在HBase中的。key是每一个维度成员的组合值</li>
</ul>
<h3 id="Streaming-cubing"><a href="#Streaming-cubing" class="headerlink" title="Streaming cubing"></a>Streaming cubing</h3><ul>
<li>支持实时数据的cub。与传统的cub一样，共享storage engine(HBase)以及query engine。kylin Streaming cubing相比其他实时分析系统来说，不需要特别大的内存，也不需要实现真正的实时分析。因为在OLAP中，存在几分钟的数据延迟是完全可以接受的。于是实现手法上采用了micro batch approach。</li>
<li>micro batch approach:将监听到的数据按照时间窗口的方式划分，并且为每个窗口封装了一个微量批处理，批处理后的结果直接存到HBase。</li>
<li>Streaming cubing data 最终会慢慢转换成普通的cubes,因为所有的数据是直接保存到HBase中的，并且保存为一个新的segment，当segment数量到达一定程度时，job engine会将segment 合并起来形成一个大的cube。</li>
</ul>
<h3 id="实战问题总结"><a href="#实战问题总结" class="headerlink" title="实战问题总结"></a>实战问题总结</h3><p>由于集群环境是CDH集群，所以选择了kylin CDH 1.6的版本，支持从Kafka读取消息建立Streaming cubes直接写入HDFS中</p>
<ul>
<li>选择一个集群namenode节点，将解压包放入/opt/cloudrea/parcels/目录中。如果是部署单节点，暂时不用更改配置文件。所有的配置加载都在bin/kylin.sh中。</li>
<li>直接kylin.sh start/stop 运行脚本，服务就会在7070端口起一个web界面。这个界面是可以进行可视化操作的。</li>
</ul>
<h3 id="Hive-数据源"><a href="#Hive-数据源" class="headerlink" title="Hive 数据源"></a>Hive 数据源</h3><ul>
<li>直接测试hive数据源是没有问题的，这一功能比较完善，也是主打功能。</li>
</ul>
<h3 id="kafka数据源"><a href="#kafka数据源" class="headerlink" title="kafka数据源"></a>kafka数据源</h3><p>从kylin 1.6 版本开始正式支持Kafka做数据源，将Streaming Cubes实时写入 HBase中。这一块在测试的时候也出现了问题：</p>
<ul>
<li><p>Kafka版本问题</p>
<ul>
<li>由于实验环境的CDH集群Kafka版本是0.9的，而kylin 仅支持0.10以上的版本，所以需要对CDH kafka集群进行升级。</li>
</ul>
</li>
<li><p>mapreduce运行环境无jar包</p>
<ul>
<li>kylin中提交cube build之后，map reduce任务直接抛错。错误提示是，找不到Kafka的Consumer类。根本原因是kylin默认集群上的map reduce classpath是会加载kafka-clients.jar包的，所以在提交任务的时候没有将kafka-clients.jar包打进去。这时可以有三种做法：</li>
<li>直接修改kylin的源码，将kafka-clients.jar包给包括进去（待尝试）。</li>
<li>可以通过修改集群的HADOOP_ClASSPATH的路径，将jar包给包括进去。</li>
<li>hadoop classpath 查看classpath目录信息 将对应jar包直接拷入map reduce classpath中，这方法简单，但是缺点就是需要逐个得对node进行操作。</li>
</ul>
</li>
<li><p>Property is not embedded format</p>
<ul>
<li><p>现在意识到，使用开源框架不会看其源码是不行的…就在我折腾俩天终于将mapreduce任务跑起来之后，新的错误出现了:”ava.lang.RuntimeException: java.io.IOException: Property ‘xxx’ is not embedded format”。莫名奇妙的错误。迫使我直接去github上看kylin kafka模块的源码。在TimedJsonStreamParser.java中发现代码逻辑中默认json数据中，如果key存在下划线就会将该key按照下划线split… 然后看key对应的value是不是map类型，如果不是直接抛出标题的错误。</p>
</li>
<li><p>明确了问题之后，如何复写默认下划线split的配置成为问题。由于官网的文档十分鸡肋，很多坑都没有涉及到，所以继续看源码。发现StreamingParser.java这个类中会去写一些默认的配置。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static final String PROPERTY_TS_COLUMN_NAME = &quot;tsColName&quot;;</span><br><span class="line">public static final String PROPERTY_TS_PARSER = &quot;tsParser&quot;;</span><br><span class="line">public static final String PROPERTY_TS_PATTERN = &quot;tsPattern&quot;;</span><br><span class="line">public static final String EMBEDDED_PROPERTY_SEPARATOR = &quot;separator&quot;;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">        derivedTimeColumns.put(&quot;minute_start&quot;, 1);</span><br><span class="line">        derivedTimeColumns.put(&quot;hour_start&quot;, 2);</span><br><span class="line">        derivedTimeColumns.put(&quot;day_start&quot;, 3);</span><br><span class="line">        derivedTimeColumns.put(&quot;week_start&quot;, 4);</span><br><span class="line">        derivedTimeColumns.put(&quot;month_start&quot;, 5);</span><br><span class="line">        derivedTimeColumns.put(&quot;quarter_start&quot;, 6);</span><br><span class="line">        derivedTimeColumns.put(&quot;year_start&quot;, 7);</span><br><span class="line">        defaultProperties.put(PROPERTY_TS_COLUMN_NAME, &quot;timestamp&quot;);</span><br><span class="line">        defaultProperties.put(PROPERTY_TS_PARSER, &quot;org.apache.kylin.source.kafka.DefaultTimeParser&quot;);</span><br><span class="line">        defaultProperties.put(PROPERTY_TS_PATTERN, DateFormat.DEFAULT_DATETIME_PATTERN_WITHOUT_MILLISECONDS);</span><br><span class="line">        defaultProperties.put(EMBEDDED_PROPERTY_SEPARATOR, &quot;_&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>自然而然会联想到，这个默认的配置肯定是可以在用户设置的时候通过key（separator）去覆盖的…于是发现在构建Streaming table的时候，可以通过Parse Properties去覆盖配置。<br>于是直接写成如下的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">tsColName=timestamp;separator=no</span><br><span class="line"></span><br><span class="line">//源码中拿到这个配置之后会做覆盖处理，然后执行 getValueByKey：</span><br><span class="line"></span><br><span class="line">protected String getValueByKey(String key, Map&lt;String, Object&gt; rootMap) throws IOException &#123;</span><br><span class="line">        if (rootMap.containsKey(key)) &#123;</span><br><span class="line">            return objToString(rootMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] names = nameMap.get(key);</span><br><span class="line">        if (names == null &amp;&amp; key.contains(separator)) &#123;</span><br><span class="line">            names = key.toLowerCase().split(separator);</span><br><span class="line">            nameMap.put(key, names);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (names != null &amp;&amp; names.length &gt; 0) &#123;</span><br><span class="line">            tempMap.clear();</span><br><span class="line">            tempMap.putAll(rootMap);</span><br><span class="line">            //这块如果复写了separator属性的话split后的names数组长度为1会跳过这一步循环，防止解析出错</span><br><span class="line">            for (int i = 0; i &lt; names.length - 1; i++) &#123;</span><br><span class="line">                Object o = tempMap.get(names[i]);</span><br><span class="line">                if (o instanceof Map) &#123;</span><br><span class="line">                    tempMap.clear();</span><br><span class="line">                    tempMap.putAll((Map&lt;String, Object&gt;) o);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new IOException(&quot;Property &apos;&quot; + names[i] + &quot;&apos; is not embedded format&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Object finalObject = tempMap.get(names[names.length - 1]);</span><br><span class="line">            return objToString(finalObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return StringUtils.EMPTY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-03-15T07:12:25.000Z">2017-03-15</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分钟 读完 (大约 1857 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/03/15/HBase学习与经验总结/">HBase学习与经验总结</a>
            
        </h1>
        <div class="content">
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为业务的关系，也零零碎碎的接触到了HBase，并对其产生了兴趣。这段时间又抽空看了一下《HBase权威指南》，于是，秉承着学习记录的习惯，把一些知识和经验写成了博客。</p>
<h3 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h3><ul>
<li>表：HBase将数据组织到自己的HTable表中，这个表是根据列族(colomn family)在物理上保存数据的，每个列族都有自己的文件夹和storefiles，不像关系型数据库那样将一个表保存成一个文件，表明也是文件系统路径的一部分。</li>
<li>行键：每行都有唯一的行键，行键没有数据类型，它内部被认为是一个字节数组。</li>
<li>列族：HBase表中的行是按一个叫colomn family的列族分组的，也是在磁盘上也是按列族存储数据的，由于这个原因，故当定义一个hbase表时，除了定义表名外，还必须定义列族。传统数据库没有列族的概念。</li>
<li>列修饰符：列簇定义真实的列，被称之为列修饰符，你可以认为列修饰符就是列本身。</li>
</ul>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><ul>
<li>数据结构：LSM树。使用日志文件和内存存储来将随机写转换成顺序写，因此也能保证稳定的数据插入速率。由于读和写独立，因此在这俩种操作之间没有冲突。由于存储数据的布局较优，查询一个键需要的磁盘寻到次数在一个可预测的范围内。并且读取与该键连续的任意数量的记录都不会引发任何额外的磁盘寻道。</li>
<li>启动HBase时。HMaster负责将所有的region分配到HRegion Server 上，其中也包括特别的-Root-和.META.表。HRegion Server负责打开region,并创建对应的HRegion实例。这些列族是用户之前创建表时定义的。每个store实例包含一个或多个storefile实例，它们实际数据存储文件HFile的轻量级封装。每个Store还有其对应的一个MemStore, 一个HregionServer分享了一个HLog实例。</li>
<li>基本的请求流程: 客户端先联系ZK子集群查找行键。此过程是通过ZK获取含有-ROOT-的region服务器名来完成的。通过含有-Root-的region服务器可以查询到含有.META表中对应的region服务器名，其中包括请求的行键信息。这俩处主要内容都被缓存起来了。并且都只查询一次。最终通过查询.META.服务器来获取客户端的行键数据所在的region的服务器名。</li>
<li>写数据的过程。第一步决定数据是否需要写到由HLog类实现的预写日志中。WAL是标准的Hadoop SequenceFile 并且存储了HlogKey实例。这些键包括序列号和实际数据。所以在服务器崩溃时可以回滚还没有持久化的数据。一旦数据被写入WAL中，数据就会被放到MemStore中，同时还会检查memstore是否已经骂了，如果满了，就会被请求刷写到磁盘中去。刷写请求由另外一个HRegionServer的线程处理，它会把数据写成一个新的HFile。同时也会保存最后写入的序号。系统就知道哪些数据现在被持久化了。</li>
</ul>
<h3 id="region拆分与合并"><a href="#region拆分与合并" class="headerlink" title="region拆分与合并"></a>region拆分与合并</h3><h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><ul>
<li>当一个region里的存储文件增长到大于配置的hbase.hregion.max.filesize大小或者在列族层面配置的大小时，region会被一分为二。这个过程通常非常迅速，因为系统只是为新region创建了俩个对应的文件，每个region是原始region的一半。</li>
<li>region服务器在父region中创建splits目录来完成这个过程。接下来关闭该region。此后这个region不再接受任何请求。然后region服务器通过在splits目录中设立必须的文件结构来准备新的子region，包括新region目录和参考文件。如果这个过程成功完成，它将把两个新region目录移到表目录中。.META.表中父region的状态会被更新，以表示其现在拆分的节点和子节点是什么。可以避免父region被意外重新打开。</li>
</ul>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><h3 id="rowKey的设计"><a href="#rowKey的设计" class="headerlink" title="rowKey的设计"></a>rowKey的设计</h3><h4 id="关于rowKey的一些认识"><a href="#关于rowKey的一些认识" class="headerlink" title="关于rowKey的一些认识"></a>关于rowKey的一些认识</h4><ul>
<li>HBase表里只有键(KeyValue对象的Key部分，包括行键、列限定符和时间戳)可以建立索引。访问一个特定行的唯一办法是通过行键。</li>
<li>设计HBase表时，行键是唯一重要的事情，因此应该按照预期的访问方式来建立行键。此结论基于俩个事实依据：<ul>
<li>region基于行键为一个区间的行提供服务，并且负责区间内每一行</li>
<li>HFile在硬盘上存储有序的行。当region刷写留在内存里的行时生成了HFile。这些行已经排过序，也会有序地刷写到硬盘上。</li>
</ul>
</li>
</ul>
<h4 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h4><ul>
<li>先定好查询方案，可以使用包含部分键的扫描机制设计出非常有效的左对齐索引（字典序从左到右排序）当一个字段被加到键中时就多了一个可以检索的维度。</li>
<li>用户需要保证行键中每个字段的值都被补齐到这个字段所设的长度，这样字典序才会按照预期排列，（按照二进制内容比较，并升序排列），用户需要为每个字段设定一个固定的长度来保证每个字段比较时只会与同字段内容从左到右比较，否则可能出现溢出的情况。</li>
<li><p>可能的起始键的含义：</p>
<ul>
<li><userid> 扫描一个给定用户ID下的所有消息</userid></li>
<li><userid>-<date> 扫描一个给定用户ID下特定日期的消息</date></userid></li>
<li><userid>-<date>-<messageid> 扫描一个用户ID和日期下的一个消息。</messageid></date></userid></li>
</ul>
</li>
<li><p>防止系统产生热读写的设计：</p>
<ul>
<li>salting方式：使用salting前缀来保证数据分散到所有的region服务器。缺点就是当用户要扫描一个连续的范围时，可能需要跨region请求，这样的话可以通过多线程读取。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte prefix=(byte)(Long.hashCode(time)%&lt;number of region servers&gt;);</span><br></pre></td></tr></table></figure>
<ul>
<li>随机化：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte rowkey=MD5(timestamp);</span><br></pre></td></tr></table></figure>
<p>利用散列函数能将行键分散到所有的region服务器上，对于时间连续的数据，这样做不好，因为散列之后无法通过时间范围扫描数据。由于用户可以用散列的方式重新生成行键，随机化的方式很适合每次读取一行数据的应用，如果用户的数据不需要连续扫描而只需要随机读取，用户可以使用这种策略。</p>
</li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-02-15T14:44:21.000Z">2017-02-15</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    43 分钟 读完 (大约 6381 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/02/15/InnoDB读书笔记/">InnoDB读书笔记</a>
            
        </h1>
        <div class="content">
            <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><p>数据库的四种隔离级别</p>
<ul>
<li>Read Uncommitted(读未提交): 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。于是事务B可能读取到了事务A未提交的数据。</li>
<li>Read -Committed(读提交): 读取数据的事务允许其他事务继续访问该行事务，但是未提交的写事务存在时禁止一切其他事务，该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</li>
<li>Repeated read （可重复读） 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。mysql的InnoDB的Repeated read 级别就可以解决幻读的问题(源自Next-Key Locking算法)，而oracle只能将隔离级别设置在Serializable才能解决幻读的问题。</li>
<li>Serializable（串行化）： 序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。</li>
</ul>
</li>
<li><p>InnoDB关键特性</p>
<ul>
<li>插入缓冲（Insert Buffer） 不可能每张表上只有一个聚集索引，在进行插入操作时候，数据页存放还是按照主键a进行顺序存放的，但是对于非聚集索引叶子节点的插入不再是顺序的了，这时会需要离散地访问非聚集索引页，需要注意，辅助索引的插入顺序依然是顺序的，或者说比较顺序的，比如用户购买表中的时间字段，通常情况下，用户购买时间是一个辅助索引，用来根据时间条件进行查询，但是在插入时却是根据时间递增而插入的，因此插入较为顺序。Insert Buffer 对于非聚集索引的插入和更新操作，不是每一次直接插入到索引页面，而是判断插入的是否在非索引页是否在缓冲池，若在，则直接插入。若不在先放入一个Insert Buffer中，好似欺骗。 因此  Insert Buffer需要满足的俩个条件： 索引是辅助索引，并且索引不是唯一的。</li>
<li>俩次写（Double Write）</li>
<li>自适应哈希索引（Adaptive Hash Index）</li>
<li>异步IO</li>
<li>刷新邻接页</li>
</ul>
</li>
</ol>
<h3 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h3><ol>
<li>InnoDB存储引擎支持的几种常见索引<ul>
<li>B+ 树索引：其下索引又分为：聚集索引，辅助索引（内部均为B+树）</li>
<li>全文索引</li>
<li>哈希索引 （哈希索引是自适应的，根据表的使用情况自动生成） 注意：B+ 树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存，再在内训中进行查找，最后得到想要查找的数据。</li>
</ul>
</li>
</ol>
<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ol>
<li>定义和性质<ul>
<li>由二叉树和平衡二叉树演化而来。是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录的节点都是按照键值的大小顺序存放在同一层的叶子节点上。由各叶子节点指针进行连接。</li>
<li>B+树的插入必须保证插入之后叶子节点的记录依然排序。</li>
<li>B+树在数据库中的有一个特点就是高扇出性，因此在数据库中B+树的高度一般都在2～4层，也就是说查找一个键值记录最多只需要2到4次IO。</li>
</ul>
</li>
<li><p>B+树定义</p>
<ul>
<li>分为聚集索引和辅助索引。俩者的不同之处在于叶子节点存放的是否是一整行的信息。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，而InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而聚集索引能够在叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地针对范围值查询，查询优化器能够快速发现某一段范围的数据页需要扫描。</li>
<li>聚集索引。由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于使用聚集索引。因为:<br>1）聚集索引能够直接在B+树索引上找到数据。<br>2）定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。能够快速的发现某一段范围的数据页需要扫描<br><strong>误区</strong>：很多书和博客都介绍，聚集索引按照顺序物理地存储数据，其实这样会导致维护成本非常高，所以聚集索引的存储并不是物理上连续的。而是逻辑连续。<strong>原因</strong>：<br>1）页通过双向链表链接，页按照主键的顺序排序；<br>2）页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</li>
</ul>
</li>
<li><p>B+树索引的分裂</p>
</li>
<li>B+树索引的管理<ul>
<li><strong>Cardinality值：</strong><br>1）并不是在所有的查询条件中出现的列都需要添加索引，一般的经验是，在访问表中很少一部分时使用B+树索引才有意义，对于性别、地区、类型字段，它们的可取值范围很小，称为低选择性，于是建索引是完全没有必要的。<br>2）对于高选择性的确定，可以通过show index结果列中的列Cardinality来观察，表示的是索引中不重复记录数量的预估值。注意：仅仅是个预估值，而不是一个准确值。</li>
</ul>
</li>
<li><p>B+索引树的使用</p>
<ul>
<li><p>分析<br>1）用Show index table 查看索引的情况<br>2）用explain+sql语句 来分析这条sql的情况，包括使用的possible_keys（可能选择的索引）与key(实际选择的索引)</p>
</li>
<li><p>联合索引<br>是指对表上的多个列进行索引，创建方法与单个索引的创建方法一样，不同之处在于有多个索引列,如对于联合索引(a,b) ,以下是关于联合索引的一些情况</p>
<ul>
<li><p>select * from table where a=x and b=x;</p>
<pre><code>显然是可以用(a,b)索引的，因为索引的顺序就是按照（a,b）来排序的
</code></pre></li>
<li><p>select * from table where a=xxx; 这个也是可以使用(a,b)索引的，只不过只能使用一部分</p>
</li>
<li>select * from table where b=xxx; 这个是不能使用索引的，因为压根就没按照b做排序。</li>
</ul>
</li>
<li><p>联合索引的好处是，在第一个索引的基础上，已经给第二个键值做了排序的处理，从而可以减少一次排序操作：比如我们要查某个用户购买商品的情况，并且按照时间排序。</p>
</li>
<li><p>覆盖索引</p>
<ul>
<li>Innodb存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，因此，大小要远小于聚集索引，可以大大减少IO操作。</li>
<li><p>对于Innodb的辅助索引而言，由于其包含了主键信息，因此其叶子节点存放的数据为(primary key1,primary key2,…)例如，下列语句都可以通过使用一次辅助索引来完成查询</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select primary key1,key2,… from table</span><br><span class="line">where</span><br><span class="line">key1=xxx;</span><br><span class="line">对于覆盖索引的另一个好处是对某些统计问题而言，</span><br><span class="line">不会选择通过聚集索引来进行统计。因为辅助索引的量远小于聚集索引，</span><br><span class="line">可以大大减少IO操作。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from order </span><br><span class="line">where orderId&gt;10000 and orderId&lt;102000; </span><br><span class="line">（从orderId的基数看来非常大，这是前提）</span><br></pre></td></tr></table></figure>
<ul>
<li>这句sql按道理来说可以使用辅助索引的，可选的 KEYS有primary orderId, 等索引，然而最后选择了primary聚集索引，也就是全表扫描。</li>
<li>原因在于用户要选取的数据是整行信息，而orderId索引不能覆盖到我们要查询的信息，因此在对orderId索引查询到指定的数据之后，还需要一次书签访问来查询整行信息，虽然orderId索引中的数据是顺序存放的，但是再一次进行书签来查找数据则是无序的，因此变为了磁盘上的离散读操作。</li>
<li>如果要求访问的数据量很小。则优化器还会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分的时候（通常是百分之二十），优化器则会选择通过聚集索引来查找数据，因此之前已经提到过，顺序读要远远快于离散读。</li>
<li><p>因此，对于不能进行索引覆盖的情况，优化器选择辅助索引的条件是占有的数据量很小。当然这是由当前传统的机械硬盘的特性决定的。</p>
</li>
<li><p>InnoDB存储引擎中的哈希算法<br>自适应哈希索引：数据库自身创建并使用的，经过哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快速。如 select * from table where index_cole=“xxx” 但是对于范围查找久无能为力了。</p>
</li>
</ul>
<h3 id="InnoDB锁机制"><a href="#InnoDB锁机制" class="headerlink" title="InnoDB锁机制"></a>InnoDB锁机制</h3><h4 id="lock-与-latch区别"><a href="#lock-与-latch区别" class="headerlink" title="lock 与 latch区别"></a>lock 与 latch区别</h4><ul>
<li>latch一般称为轻量级锁，因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以氛围mutex（互斥量）与 rwlock 读写锁。目的是用来保证并发线程的操作临界资源的正确性，并且通常没有死锁检测的机制，仅仅通过应用程序加锁的顺序来保证无死锁的情况发生。</li>
<li>lock的对象是事务，用来锁定的是数据库中的对象。如表，页，行。并且一般lock的对象仅在事务commit或rollback后进行释放。且有死锁机制</li>
<li>latch查看 show engine innodb mutex。lock查看 show engine innodb status</li>
</ul>
<h4 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h4><ul>
<li><strong>InnoDB实现了俩种标准的行级锁</strong>：<ul>
<li>共享锁：允许事务读一行数据 </li>
<li>排他锁：允许事务删除或者更新一行数据</li>
</ul>
</li>
</ul>
<p>如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行的共享锁，称这种情况为锁兼容。但若有其他事务T3想要获得这一行的排他锁，则必须等待事务T1，2释放行上的共享锁称这种情况为锁不兼容。<br>可以总结出：<strong>X锁与任何锁都不兼容。而S锁仅仅和S锁兼容。需注意的是，S和X锁都是行级锁，兼容是指对同一记录锁的兼容性情况</strong>。</p>
<ul>
<li><p><strong>意向锁的定义：</strong>InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上的枷锁操作。InnoDB存储引擎支持一种额外的枷锁方式，称为<strong>意向锁</strong>。它是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
</li>
<li><p>如需要在页上的记录r进行行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度的锁完成。举例子说明：在对记录r加X锁之前。已经有事务对表1进行了S表锁，那么表1上一存在S锁，之后事务需要对记录R表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
</li>
<li>InnoDB存储引擎支持意向锁设计比较简练。其意向锁即为表级别的锁，设计的目的主要是为了在事务中揭示下一行将被请求的锁类型。其支持俩种意向锁：<ul>
<li>意向共享锁<strong>（IS Lock）</strong>，事务想要获得一张表中某几行的共享锁。 </li>
<li>意向排他锁（<strong>IX Lock</strong>），事务想要获得一张表中某几行的排他锁。</li>
</ul>
</li>
</ul>
<p>由于InnoDB支持的是<strong>行级别的锁</strong>，因此意向锁其实不会阻塞<strong>除全表扫</strong>以外的任何请求，故而意向锁与行级别锁的兼容性<br><img src="http://jacobs.wanhb.cn/images/lock.png" alt="兼容性"></p>
<p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加<strong>排他锁（X)</strong>；对于普通SELECT语句，<strong>InnoDB不会加任何锁</strong>；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只有通过索引条件检索数据，InnoDB才使用行级锁，否则，将使用表级锁</span><br></pre></td></tr></table></figure></p>
<h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>InnoDB中通过多版本控制的方式来读取当前执行时间数据库中的行的数据。如果读取的行正在执行DELETE或者UPDATE操作，这时读取操作不会因此等待下去，相反，InnoDB存储引擎会去读取行的一个快照数据<strong>。是InnoDB默认的读取方式</strong></p>
<ul>
<li>称之为非锁定读是因为不需要等待访问的行上X锁的释放。快照数据是指该行的之前版本的数据；也称作多版本并发控制（MVCC）</li>
<li>在不同的事务隔离级别Read Committed和Repeatable read下，<strong>InnoDB使用非锁定的一致性读</strong>。但是对于快照的定义却不相同。<strong>在RC下，对于快照数据，总是读取被锁定行最新的一份快照数据，而在RR下，总是读取事务开始时的行数据版本</strong></li>
<li>快照隔离只是适用于<strong>只读事务</strong>，但是对于<strong>读-写事务</strong>，由于默认是<strong>一致性非锁定读</strong>它却无法解决棘手的<strong>写倾斜问题</strong>（具体定义看《数据密集型应用系统设计》），要想解决写倾斜问题（幻读的一种），还得在读取的时候显式加锁，即<strong>一致性锁定读方式</strong></li>
</ul>
<h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>在默认的配置下，即事务的隔离级别为Repeatable Read模式下，<strong>InnoDB存储引擎的select操作使用一致性非锁定读</strong>，锁实现采用<strong>next-key-lock算法</strong>解决幻读但是在某些情况下，用户需要显式地加锁来保证数据的一致性。InnoDB存储引擎对于SELECT语句支持俩种一致性的锁定读操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select....FOR UPDATE //对行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。</span><br><span class="line">select....LOCK IN SHARE MODE//对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加上X锁则会被阻塞。</span><br></pre></td></tr></table></figure></p>
<p>必须在一个事务中，如果事务提交，锁也就释放了。</p>
<h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><ol>
<li>外键<ul>
<li>对于外键列，如果没有显示地给这个列加索引，<strong>则InnoDB存储引擎自动对其加一个索引，因为这样可以避免默认使用表级锁的情况（在博文InnoDB行锁实现方式一小节提到）</strong></li>
<li>对于外键的插入或更新，首先需要查询父表中的记录，对于父表的SELECT操作，不是采用一致性非锁定读的方式，因为这样会发生数据不一致问题。使用的是Select … lock in share mode方式，即主动对父表加一个S锁。</li>
</ul>
</li>
</ol>
<h4 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h4><ol>
<li><p>InnoDB 3种行锁的算法</p>
<ul>
<li>RecordLock: 单个行记录上的锁。总会去锁住索引记录，如果InnoDB在建立的时候没有设置任何一个索引，那么这时，InnoDB存储引擎会使用隐士的主键来锁定<ul>
<li>Gap Lock: 间隙锁，锁定一个范围，但不包含记录本身。目的是为了解决Phantom Problem，即阻止多个事务将记录插入到同一范围内。</li>
</ul>
</li>
<li>Next-Key Lock: Gap Lock+ record Lock,锁定一个范围，并且锁定记录本身。结合了GapLock和RecordLock。在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。例如一个索引有10，11，13，20这四个值，那么该索引可能被Next-Key Locking的区间为： (-8,10)、[10,11)…。</li>
</ul>
</li>
<li><p>Next-Key Lock</p>
<ul>
<li>采用的锁定技术为Next-Key Locking,锁定的不是单个值，而是一个范围，是谓词索引的一种改进。若事务T1已经通过next-key locking锁定了范围：(10,11]、(11,13] 当插入新的记录12时，则锁定的范围会变成:(10,11]、(11,12],(12,13]。 然而当查询的索引含有<strong>唯一属性</strong>时，InnoDB会对Next-Key Lock进行优化降级为Record Lock，即仅仅锁住索引本身，而不是范围。</li>
</ul>
</li>
<li><p>解决Phantom Problem</p>
<ul>
<li><strong>Phantom Problem定义：</strong> 是指在同一事务下，连续执行俩次同样的SQL语句可能导致不同的结果，第二次执行的SQL语句可能会返回之前不存在的行。</li>
<li><strong>在默认的事务隔离级别下，即REPEATABLE READ下</strong>，InnoDB存储引擎采用Next-Key Locking机制来避免幻象问题。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例说明：表t由1，2，5三个值组成，事务T1执行：select * from t where a&gt;2 for update;</span><br><span class="line">这时，T1并没有提交操作，此时结果返回5，与此同时，另一个事务T2插入了4这个值，在执行一遍sql</span><br><span class="line">会返回4，5，即俩次的结果不一致。InnoDB的next-key locking算法避免Phantom Problem,是对（2，+8）这个范围加了X锁，因此对于任何这个范围插入的操作都是不被允许的。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h4><ol>
<li><p>脏读</p>
<ul>
<li>脏数据和脏页的关系：脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘的页的数据是不一致的。当然在刷新到磁盘之前，日志都已经被写入到了重做日志文件中，而脏数据是指<strong>事务对缓冲池中的行记录的修改，并且还没有被提交。</strong> 一个事务可以读到另一个事务中为提交的数据，这显然违反了数据库的个隔离性。</li>
</ul>
</li>
<li>不可重复读<ul>
<li>重点在于修改。是指在<strong>一个事务内</strong>多次读取同一数据集合，在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作，因此在第一个事务中的俩次读数据之间，由于第二个事务的修改，导致俩次读取到的结果集合可能出现不一致的情况。</li>
<li>不可重复读和脏读的区别是，脏读是读到未提交的数据，而不可重复读读到的却是已经提及的数据，但是其违反了数据库事务一致性的要求。</li>
<li>一般来说不可重复读还是可以接受的，不少数据库厂商（Oracle、MicroSoft SQL SERVER）将其数据库事务的默认隔离级别设置为Read COMMITTED</li>
<li>InnoDB存储引擎中，通过使用<strong>Next-Key Lock</strong>算法来避免不可重复读的问题。Mysql官方文档中将不可重复读的问题定义为Phantom Problem，即幻象问题</li>
</ul>
</li>
<li><p>幻读</p>
<ul>
<li>重点在于新增或删除。当事务不是独立执行时发生的一种现象，第一个事务对一个表中的数据进行了修改，涉及到全部的数据行。同时第二个事务也修改了这个表中的数据，这种修改是向表中插入一行新数据。那么之后第一个事务重新读取数据的时候就会出现幻读的情况</li>
<li><strong>Next-Key Lock</strong>算法解决幻读问题</li>
</ul>
</li>
<li><p>丢失更新</p>
<ul>
<li><p>丢失更新是另一个锁导致的问题，简单来说就是一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致。</p>
<ul>
<li>1）事务T1将行记录r更新为v1,但是事务T1并未提交</li>
<li>2）与此同时事务T2将行记录更新为V2，事务T2未提交</li>
<li>3）事务T1提交</li>
<li>4）事务T2提交 </li>
</ul>
<p>但是在任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题。但是生产应用中还有一种逻辑意义的丢失更新，而导致该问题的并不是因为数据库本身的问题。</p>
<ul>
<li><p>实际上，在所有多用户计算机系统环境下都有可能产生这个问题：</p>
</li>
<li><p>1) 事务T1查询一行数据，放入本地内存，并显示给一个终端用户User1</p>
</li>
<li>2) 事务T2也查询该行数据，放入本地内存，并显示给一个终端用户User2</li>
<li>3) user1修改该行记录，更新数据库并提交</li>
<li>4) User2也修改该行记录，更新数据库并提交</li>
</ul>
<p>要避免丢失更新的发生，就需要让事务在这种情况下的<strong>操作变成串行化，而不是并行操作</strong>。于是在步骤一的过程中，用户读取数据加上一个<strong>排他锁</strong>，这样用户2读取的时候也必须加上排他锁，否则就等待锁的释放。</p>
</li>
</ul>
</li>
<li><p>阻塞</p>
<ul>
<li>因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。阻塞不是一件坏事，是为了确保事务可以并发且正常地运行。</li>
<li><p>在InnoDB中，参数 <strong>innodb_lock_wait_timeout</strong>用来控制等待的时间<strong>（默认是50秒）</strong>，innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作，默认不回滚。可以通过代码调整： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set @@innodb_lock_wait_time=60</span><br><span class="line">innodb_rollback_on_timeout是静态的，不可在启动时进行修改。</span><br><span class="line">默认情况下，innoDB存储引擎不会回滚超时引发的错误异常，其实InnoDB存储引擎在大部分情况下，都不会对异常进行回滚。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ol>
<li>死锁的概念</li>
<li>死锁的概率</li>
<li>死锁的示例</li>
<li>锁升级</li>
</ol>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-02-11T16:42:30.000Z">2017-02-12</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    37 分钟 读完 (大约 5537 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/02/12/Spring源码解析-事务处理/">Spring源码解析--事务处理</a>
            
        </h1>
        <div class="content">
            <h3 id="事务处理相关类的层次结构"><a href="#事务处理相关类的层次结构" class="headerlink" title="事务处理相关类的层次结构"></a>事务处理相关类的层次结构</h3><p><img src="http://jacobs.wanhb.cn/images/2017-02-11_7.54.25.png" alt="事务处理相关类的层次结构"></p>
<p>在 Spring事务处理中，可以通过设计一个TransactionProxyFactoryBean来使用AOP功能，通过它可以生成Proxy代理对象。在代理对象中，通过TranscationInterceptor来完成对代理对象方法的拦截。实现声明式事务处理时，是AOP和IOC集成的部分，而对于具体的事物处理实现，是通过设计PlatformTransactionManager，AbstractPlatforTransactionmanager以及一系列具体事务处理器来实现的。PlatformTransactionManager又实现了TransactionInterceptor，这样就能将一系列处理给串联起来。</p>
<h3 id="Spring声明式事务处理"><a href="#Spring声明式事务处理" class="headerlink" title="Spring声明式事务处理"></a>Spring声明式事务处理</h3><h4 id="设计原理与过程"><a href="#设计原理与过程" class="headerlink" title="设计原理与过程"></a>设计原理与过程</h4><p>在实现声明式的事务处理时，常用的方式是结合IOC容器和Spring已有的TransactionProxyFactoryBean对事务管理进行配置，实现可分为以下几个步骤：</p>
<ul>
<li>读取和处理在IOC容器中配置的事务处理属性，并转化为Spring事务处理需要的内部数据结构。</li>
<li>Spring事务处理模块实现统一的事务处理过程。</li>
<li>底层的事务处理实现。Spring委托给具体的事务处理器来完成。</li>
</ul>
<p><img src="http://jacobs.wanhb.cn/images/2017-02-11_8.23.09.png" alt="建立事务处理对象时序图"></p>
<p>从TransactionProxyFactoryBean入手，通过代码来了解Spring是如何通过AOP功能来完成事务管理配置的，从图中可以看到Spring为声明式事务处理的实现所做的一些准备工作：包括为AOP配置基础设施，这些基础设施包括设置拦截器TransactionInterceptor、通过DefaultPointcutAdvisor或TransactionAttributeSourceAdvisor。同时，在TransactionProxyFactoryBean的实现中，还可以看到注入进来的PlatformTransactionManager和事务处理属性TransactionAttribute等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionProxyFactoryBean extends AbstractSingletonProxyFactoryBean implements BeanFactoryAware &#123;</span><br><span class="line">  private final TransactionInterceptor transactionInterceptor = new TransactionInterceptor();／／这个拦截器通过AOP发挥作用，通过这个拦截器的实现，Spring封装了事务处理实现</span><br><span class="line">  private Pointcut pointcut;</span><br><span class="line"></span><br><span class="line">  public TransactionProxyFactoryBean() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">    this.transactionInterceptor.setTransactionManager(transactionManager);</span><br><span class="line">  &#125;</span><br><span class="line">  //通过依赖注入的事务属性以Properties的形式出现，把BeanDefinition中读到的事务管理的属性信息注入到TransactionInterceptor中</span><br><span class="line">  public void setTransactionAttributes(Properties transactionAttributes) &#123;</span><br><span class="line">    this.transactionInterceptor.setTransactionAttributes(transactionAttributes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) &#123;</span><br><span class="line">    this.transactionInterceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setPointcut(Pointcut pointcut) &#123;</span><br><span class="line">    this.pointcut = pointcut;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setBeanFactory(BeanFactory beanFactory) &#123;</span><br><span class="line">    this.transactionInterceptor.setBeanFactory(beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line">//这里创建Spring  AOP对事务处理的Advisor</span><br><span class="line">  protected Object createMainInterceptor() &#123;</span><br><span class="line">    this.transactionInterceptor.afterPropertiesSet();//事务处理完成AOP配置的地方</span><br><span class="line">    return this.pointcut != null?new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor):new TransactionAttributeSourceAdvisor(this.transactionInterceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected void postProcessProxyFactory(ProxyFactory proxyFactory) &#123;</span><br><span class="line">    proxyFactory.addInterface(TransactionalProxy.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成了AOP配置，Spring的TransactionInterceptor配置是IOC容器完成Bean的依赖注入时，通过initializeBean方法被调用。</p>
<p>   在建立TransactionProxyFactoryBean的事务处理拦截器的时候， afterPropertiesSet方法首先对 ProxyFactoryBean的目标Bean设置进行检查，如果这个目标Bean的设置是正确的，就会创建ProxyFactory对象，从而实现AOP的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line">  if(this.getTransactionManager() == null &amp;&amp; this.beanFactory == null) &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;Set the \&apos;transactionManager\&apos; property or make sure to run within a BeanFactory containing a PlatformTransactionManager bean!&quot;);</span><br><span class="line">  &#125; else if(this.getTransactionAttributeSource() == null) &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;Either \&apos;transactionAttributeSource\&apos; or \&apos;transactionAttributes\&apos; is required: If there are no transactional methods, then don\&apos;t use a transaction aspect.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务处理配置的读入"><a href="#事务处理配置的读入" class="headerlink" title="事务处理配置的读入"></a>事务处理配置的读入</h4><p>在AOP配置完成的基础上，以TransactionAttributeSourceAdvisor的实现为入口，了解具体的事务属性配置是如何读入的，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private TransactionInterceptor transactionInterceptor;／／同样需要AOP中用到的Interceptro和Pointcut，通过内部类，调用TransactionInterceptor来得到事务的配置属性，在对Proxy的方法进行匹配调用时，会使用到这些配置属性。</span><br><span class="line">private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">  protected TransactionAttributeSource getTransactionAttributeSource() &#123;</span><br><span class="line">    return TransactionAttributeSourceAdvisor.this.transactionInterceptor != null?TransactionAttributeSourceAdvisor.this.transactionInterceptor.getTransactionAttributeSource():null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在声明式事务处理中，通过对目标对象的方法调用进行拦截实现，这个拦截通过AOP发挥作用。在AOP中，对于拦截的启动，首先需要对方法调用是否需要拦截进行判断，依据时那些在TransactionProxyFactoryBean中为目标对象设置的事务属性。这个匹配判断在TransactionAttributeSourcePointcut中完成。实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">  if(TransactionalProxy.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    TransactionAttributeSource tas = this.getTransactionAttributeSource();</span><br><span class="line">    return tas == null || tas.getTransactionAttribute(method, targetClass) != null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法中，首先把事务方法的属性配置读取到TransactionAttributeSource对象中，有了这些事务处理的配置以后，根据当前方法调用的method对象和目标对象，对是否需要启动事务处理拦截器进行判断。</p>
<p>在Pointcut的matches判断过程中，会用到transactionAttributeSource对象，这个transactionAttributeSource对象是在对TransactionInterceptor进行依赖注入时就配置好的，它的设置是在TransactionInterceptor的基类TransactionAspectSupport中完成的。配置的是一个NameMatchTransactionAttributeSouce对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setTransactionAttributes(Properties transactionAttributes) &#123;</span><br><span class="line">  NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();</span><br><span class="line">  tas.setProperties(transactionAttributes);</span><br><span class="line">  this.transactionAttributeSource = tas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知，NameMatchTransactionAttributeSouce作为TransacionAttributeSource的具体实现，是实际完成事务处理属性读入和匹配的地方。对于NameMatchTransactionAttributeSouce是怎样实现事务处理属性的读入和匹配的，可看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void setProperties(Properties transactionAttributes) &#123;//设置配置的事务方法</span><br><span class="line">  TransactionAttributeEditor tae = new TransactionAttributeEditor();</span><br><span class="line">  Enumeration propNames = transactionAttributes.propertyNames();</span><br><span class="line"></span><br><span class="line">  while(propNames.hasMoreElements()) &#123;</span><br><span class="line">    String methodName = (String)propNames.nextElement();</span><br><span class="line">    String value = transactionAttributes.getProperty(methodName);</span><br><span class="line">    tae.setAsText(value);</span><br><span class="line">    TransactionAttribute attr = (TransactionAttribute)tae.getValue();</span><br><span class="line">    this.addTransactionalMethod(methodName, attr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private Map&lt;String, TransactionAttribute&gt; nameMap = new HashMap();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void addTransactionalMethod(String methodName, TransactionAttribute attr) &#123;</span><br><span class="line">  if(logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(&quot;Adding transactional method [&quot; + methodName + &quot;] with attribute [&quot; + attr + &quot;]&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.nameMap.put(methodName, attr);</span><br><span class="line">&#125;</span><br><span class="line">／／对调用的方法进行判断，判断它是否是事务方法，如果是，那么取出相应的事务配置属性</span><br><span class="line">public TransactionAttribute getTransactionAttribute(Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">  if(!ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    String methodName = method.getName();／／判断当前目标调用的方法与配置的事务方法是否直接匹配</span><br><span class="line">    TransactionAttribute attr = (TransactionAttribute)this.nameMap.get(methodName);</span><br><span class="line">    if(attr == null) &#123;//如果不能直接匹配，就通过调用PatternMatchUtils的simpleMatch方法来进行匹配判断。</span><br><span class="line">      String bestNameMatch = null;</span><br><span class="line">      Iterator var6 = this.nameMap.keySet().iterator();</span><br><span class="line"></span><br><span class="line">      while(true) &#123;</span><br><span class="line">        String mappedName;</span><br><span class="line">        do &#123;</span><br><span class="line">          do &#123;</span><br><span class="line">            if(!var6.hasNext()) &#123;</span><br><span class="line">              return attr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mappedName = (String)var6.next();</span><br><span class="line">          &#125; while(!this.isMatch(methodName, mappedName));</span><br><span class="line">        &#125; while(bestNameMatch != null &amp;&amp; bestNameMatch.length() &gt; mappedName.length());</span><br><span class="line"></span><br><span class="line">        attr = (TransactionAttribute)this.nameMap.get(mappedName);</span><br><span class="line">        bestNameMatch = mappedName;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return attr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">／／事务方法的匹配判断，详细的匹配过程在PatternMatchUtils中实现</span><br><span class="line">protected boolean isMatch(String methodName, String mappedName) &#123;</span><br><span class="line">  return PatternMatchUtils.simpleMatch(mappedName, methodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务处理拦截器的设计与实现："><a href="#事务处理拦截器的设计与实现：" class="headerlink" title="事务处理拦截器的设计与实现："></a>事务处理拦截器的设计与实现：</h4><p>经过TransactionProxyFactoryBean的AOP包装，此时如果对目标对象进行方法调用，起作用的对象实际傻姑娘是一个Proxy代理对象。对目标对象方法的调用，不会直接作用在TransactionProxyFactoryBean设置的目标对象上。而是会被设置的事务处理器拦截。而在TransactionProxyFactoryBean的AOP实现中，获取Proxy对象的过程并不复杂，TransactionProxyFactoryBean作为一个FactoryBean，对Bean对象的引用通过getObejct方法来得到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject() &#123; ／／TransactionProxyFactoryBean 的父类 AbstractSingletonProxyFactoryBean中</span><br><span class="line">／／返回的是一个Proxy，是ProxyFactory生成的AOP代理，已经封装了对事务处理的拦截器设置</span><br><span class="line">  if(this.proxy == null) &#123;</span><br><span class="line">    throw new FactoryBeanNotInitializedException();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return this.proxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于AOP代理对象的作用方法入口，我们一般都知道invoke方法，这个invke方法在事务处理拦截器TransactionInterceptor中，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">  Class targetClass = invocation.getThis() != null?AopUtils.getTargetClass(invocation.getThis()):null;</span><br><span class="line">  return this.invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123;</span><br><span class="line">    public Object proceedWithInvocation() throws Throwable &#123;</span><br><span class="line">      return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final TransactionAspectSupport.InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line">  final TransactionAttribute txAttr = this.getTransactionAttributeSource().getTransactionAttribute(method, targetClass);／／这里读取事务的属性配置，通过TransactionAttributeSource对象取得</span><br><span class="line">  final PlatformTransactionManager tm = this.determineTransactionManager(txAttr);／／根据TransactionProxyFactoryBean的配置信息获得具体的事务处理器</span><br><span class="line">  final String joinpointIdentification = this.methodIdentification(method, targetClass, txAttr);</span><br><span class="line">  if(txAttr != null &amp;&amp; tm instanceof CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Object ex1 = ((CallbackPreferringPlatformTransactionManager)tm).execute(txAttr, new TransactionCallback() &#123;</span><br><span class="line">        public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">          TransactionAspectSupport.TransactionInfo txInfo = TransactionAspectSupport.this.prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);／／创建事务，同时把事务过程中得到的信息放到TransactionInfo中去，TransactionInfo是保存当前事务状态的对象。</span><br><span class="line"></span><br><span class="line">          TransactionAspectSupport.ThrowableHolder var4;</span><br><span class="line">          try &#123;</span><br><span class="line">            Object ex = invocation.proceedWithInvocation();</span><br><span class="line">            return ex;</span><br><span class="line">          &#125; catch (Throwable var8) &#123;</span><br><span class="line">            if(txAttr.rollbackOn(var8)) &#123;</span><br><span class="line">              if(var8 instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException)var8;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              throw new TransactionAspectSupport.ThrowableHolderException(var8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var4 = new TransactionAspectSupport.ThrowableHolder(var8);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">            TransactionAspectSupport.this.cleanupTransactionInfo(txInfo);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return var4;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      if(ex1 instanceof TransactionAspectSupport.ThrowableHolder) &#123;</span><br><span class="line">        throw ((TransactionAspectSupport.ThrowableHolder)ex1).getThrowable();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return ex1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (TransactionAspectSupport.ThrowableHolderException var14) &#123;</span><br><span class="line">      throw var14.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    TransactionAspectSupport.TransactionInfo ex = this.createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">    Object retVal = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      retVal = invocation.proceedWithInvocation();／／这里的调用使处理沿着拦截器链进行，使最后目标对象的方法得到调用</span><br><span class="line">    &#125; catch (Throwable var15) &#123;</span><br><span class="line">      this.completeTransactionAfterThrowing(ex, var15);／／如果事务处理方法中调用出现了异常，事务处理如何进行需要根据具体情况考虑是否会滚或者提交</span><br><span class="line">      throw var15;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      this.cleanupTransactionInfo(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.commitTransactionAfterReturning(ex);//这里通过事务处理器来对事务进行提交</span><br><span class="line">    return retVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Spring而言，事务管理实际上是通过一个TransactionInfo对象来完成的，在该对象中，封装了事务对象和事务处理的状态信息，这是事务处理的抽象。在这一步完成以后，会对拦截器链进行处理，因为有可能在该事务对象中还配置了除事务处理AOP之外的其他拦截器，在结束对拦截器链处理之后，会对 TransactionInfo中的信息进行更新，以反映最近的事务处理情况，在这个时候，也就完成了事务提交的准备，通过调用事务处理器PlatformTransactionManager的commitTransactionAfterReturning方法来完成事务的提交。这个提交的处理过程已经封装在事务处理器中了，而与具体数据源相关的处理过程，最终委托给相关的事务处理器完成，如：DataSourceTransactionManager、HibernateTransactionManager等。</p>
<p><img src="http://jacobs.wanhb.cn/images/aop_10.51.15.png" alt="事务提交时序图"></p>
<p>这个invoke方法的实现中，可以看到整个事务处理在AOP拦截器中实现的全过程。同时，它也是Spring采用AOP封装事务处理和实现声明式事务处理的核心部分。</p>
<h3 id="Spring事务处理的设计与实现"><a href="#Spring事务处理的设计与实现" class="headerlink" title="Spring事务处理的设计与实现"></a>Spring事务处理的设计与实现</h3><h4 id="Spring事务传播属性"><a href="#Spring事务传播属性" class="headerlink" title="Spring事务传播属性"></a>Spring事务传播属性</h4><blockquote>
<p>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。<br>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。  PROPAGATION_NESTED –<br>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。<br>前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。</p>
</blockquote>
<h4 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h4><p>声明式事务中，TransactionInterceptor拦截器的invoke方法作为事务处理实现的起点，invoke方法中createTransactionIfNeccessary方法作为事务创建的入口。以下是createTransactionIfNeccessary方法的时序图</p>
<p><img src="http://jacobs.wanhb.cn/images/2017-02-11_11.09.41.png" alt="createTransactionIfNeccessary方法的时序图"></p>
<p>在createTransactionIfNeccessary中首先会向AbstractTransactionManager执行getTransaction，这个获取Transaction事务对象的过程，在AbstractTransactionManager中需要对事务不同的情况作出处理，然后创建一个TransactionStatus，并把这个TransactionStatus设置到对应的TransactionInfo中去，同时将TransactionInfo和当前的线程绑定，从而完成事务的创建过程。TransactionStatus和TransactionInfo这俩个对象持有的数据是事务处理器对事务进行处理的主要依据。对这俩个对象的使用贯穿整个事务处理的全过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">protected TransactionAspectSupport.TransactionInfo createTransactionIfNecessary(PlatformTransactionManager tm, final TransactionAttribute txAttr, final String joinpointIdentification) &#123;</span><br><span class="line">  if(txAttr != null &amp;&amp; ((TransactionAttribute)txAttr).getName() == null) &#123;</span><br><span class="line">    txAttr = new DelegatingTransactionAttribute((TransactionAttribute)txAttr) &#123;</span><br><span class="line">      public String getName() &#123;</span><br><span class="line">        return joinpointIdentification;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TransactionStatus status = null;</span><br><span class="line">  if(txAttr != null) &#123;</span><br><span class="line">    if(tm != null) &#123;</span><br><span class="line">      status = tm.getTransaction((TransactionDefinition)txAttr);／／这里使用了定义好的事务方法的配置信息。事务创建由事务处理器来完成，同时返回TransactionStatus来记录当前的事务状态，包括已经创建的事务。</span><br><span class="line">    &#125; else if(this.logger.isDebugEnabled()) &#123;</span><br><span class="line">      this.logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification + &quot;] because no transaction manager has been configured&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return this.prepareTransactionInfo(tm, (TransactionAttribute)txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected TransactionAspectSupport.TransactionInfo prepareTransactionInfo(PlatformTransactionManager tm, TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) &#123;</span><br><span class="line">  TransactionAspectSupport.TransactionInfo txInfo = new TransactionAspectSupport.TransactionInfo(tm, txAttr, joinpointIdentification);</span><br><span class="line">  if(txAttr != null) &#123;</span><br><span class="line">    if(this.logger.isTraceEnabled()) &#123;</span><br><span class="line">      this.logger.trace(&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    txInfo.newTransactionStatus(status);</span><br><span class="line">  &#125; else if(this.logger.isTraceEnabled()) &#123;</span><br><span class="line">    this.logger.trace(&quot;Don\&apos;t need to create transaction for [&quot; + joinpointIdentification + &quot;]: This method isn\&apos;t transactional.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  txInfo.bindToThread();</span><br><span class="line">  return txInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getTansaction实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException &#123;</span><br><span class="line">       Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">       // Cache debug flag to avoid repeated checks.</span><br><span class="line">       boolean debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">       if (definition == null) &#123;</span><br><span class="line">              // Use defaults if no transaction definition given.</span><br><span class="line">              definition = new DefaultTransactionDefinition();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (isExistingTransaction(transaction)) &#123;</span><br><span class="line">              // Existing transaction found -&gt; check propagation behavior to find out how to behave.</span><br><span class="line">              return handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Check definition settings for new transaction.</span><br><span class="line">       if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">              throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());</span><br><span class="line">       &#125;</span><br><span class="line">／／没有事务存在，需要根据事务传播属性设置来创建事务，这里会看到事务传播属性的设置：mandatory、required required_new nested等</span><br><span class="line">       // No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span><br><span class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">              throw new IllegalTransactionStateException(</span><br><span class="line">                            &quot;No existing transaction found for transaction marked with propagation &apos;mandatory&apos;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">                     definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">                     definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">              SuspendedResourcesHolder suspendedResources = suspend(null);</span><br><span class="line">              if (debugEnabled) &#123;</span><br><span class="line">                     logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);</span><br><span class="line">              &#125;</span><br><span class="line">              try &#123;</span><br><span class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">                     DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">                     doBegin(transaction, definition);</span><br><span class="line">                     prepareSynchronization(status, definition);</span><br><span class="line">                     return status;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (RuntimeException ex) &#123;</span><br><span class="line">                     resume(null, suspendedResources);</span><br><span class="line">                     throw ex;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (Error err) &#123;</span><br><span class="line">                     resume(null, suspendedResources);</span><br><span class="line">                     throw err;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">              // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span><br><span class="line">              if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                     logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +</span><br><span class="line">                                   &quot;isolation level will effectively be ignored: &quot; + definition);</span><br><span class="line">              &#125;</span><br><span class="line">              boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">              return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handleExsitingTransaction方法是理解Spring事务传播属性的关键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Create a TransactionStatus for an existing transaction.</span><br><span class="line">*/</span><br><span class="line">private TransactionStatus handleExistingTransaction(</span><br><span class="line">              TransactionDefinition definition, Object transaction, boolean debugEnabled)</span><br><span class="line">              throws TransactionException &#123;</span><br><span class="line"></span><br><span class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">              throw new IllegalTransactionStateException(</span><br><span class="line">                            &quot;Existing transaction found for transaction marked with propagation &apos;never&apos;&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">              if (debugEnabled) &#123;</span><br><span class="line">                     logger.debug(&quot;Suspending current transaction&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              Object suspendedResources = suspend(transaction);</span><br><span class="line">              boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">              return prepareTransactionStatus(</span><br><span class="line">                            definition, null, false, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">              if (debugEnabled) &#123;</span><br><span class="line">                     logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; +</span><br><span class="line">                                   definition.getName() + &quot;]&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">              try &#123;</span><br><span class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">                     DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">                     doBegin(transaction, definition);</span><br><span class="line">                     prepareSynchronization(status, definition);</span><br><span class="line">                     return status;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (RuntimeException beginEx) &#123;</span><br><span class="line">                     resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">                     throw beginEx;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (Error beginErr) &#123;</span><br><span class="line">                     resumeAfterBeginException(transaction, suspendedResources, beginErr);</span><br><span class="line">                     throw beginErr;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">              if (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">                     throw new NestedTransactionNotSupportedException(</span><br><span class="line">                                   &quot;Transaction manager does not allow nested transactions by default - &quot; +</span><br><span class="line">                                   &quot;specify &apos;nestedTransactionAllowed&apos; property with value &apos;true&apos;&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              if (debugEnabled) &#123;</span><br><span class="line">                     logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              if (useSavepointForNestedTransaction()) &#123;／／在Spring管理的事务中，创建事务保存点</span><br><span class="line">                     // Create savepoint within existing Spring-managed transaction,</span><br><span class="line">                     // through the SavepointManager API implemented by TransactionStatus.</span><br><span class="line">                     // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span><br><span class="line">                     DefaultTransactionStatus status =</span><br><span class="line">                                   prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);</span><br><span class="line">                     status.createAndHoldSavepoint();</span><br><span class="line">                     return status;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">                     // Nested transaction through nested begin and commit/rollback calls.</span><br><span class="line">                     // Usually only for JTA: Spring synchronization might get activated here</span><br><span class="line">                     // in case of a pre-existing JTA transaction.</span><br><span class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">                     DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, null);</span><br><span class="line">                     doBegin(transaction, definition);</span><br><span class="line">                     prepareSynchronization(status, definition);</span><br><span class="line">                     return status;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span><br><span class="line">       if (debugEnabled) &#123;</span><br><span class="line">              logger.debug(&quot;Participating in existing transaction&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (isValidateExistingTransaction()) &#123;</span><br><span class="line">              if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">                     Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">                     if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">                            Constants isoConstants = DefaultTransactionDefinition.constants;</span><br><span class="line">                            throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</span><br><span class="line">                                          definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; +</span><br><span class="line">                                          (currentIsolationLevel != null ?</span><br><span class="line">                                                        isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">                                                        &quot;(unknown)&quot;));</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              if (!definition.isReadOnly()) &#123;</span><br><span class="line">                     if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">                            throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</span><br><span class="line">                                          definition + &quot;] is not marked as read-only but existing transaction is&quot;);</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">       return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务挂起"><a href="#事务挂起" class="headerlink" title="事务挂起"></a>事务挂起</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException &#123;／／返回的SuspendedResourcesHolder会作为参数传给TransactionStatus</span><br><span class="line">       if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">              List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">              try &#123;</span><br><span class="line">                     Object suspendedResources = null;／／把挂起事务的处理交给具体事务处理器去完成，如果具体的事务处理器不支持事务挂起，则默认抛出TransactionSuspensionNotSupportedException</span><br><span class="line">                     if (transaction != null) &#123;</span><br><span class="line">                            suspendedResources = doSuspend(transaction);</span><br><span class="line">                     &#125;//这里在线程中保存与事务处理有关的信息，并重置线程中相关的ThreadLocal变量</span><br><span class="line">                     String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">                     TransactionSynchronizationManager.setCurrentTransactionName(null);</span><br><span class="line">                     boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">                     TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);</span><br><span class="line">                     Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">                     TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);</span><br><span class="line">                     boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">                     TransactionSynchronizationManager.setActualTransactionActive(false);</span><br><span class="line">                     return new SuspendedResourcesHolder(</span><br><span class="line">                                   suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">              &#125;</span><br><span class="line">              catch (RuntimeException ex) &#123;</span><br><span class="line">                     // doSuspend failed - original transaction is still active… 如果处理失败，则恢复原始的事务</span><br><span class="line">                     doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">                     throw ex;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (Error err) &#123;</span><br><span class="line">                     // doSuspend failed - original transaction is still active...</span><br><span class="line">                     doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">                     throw err;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else if (transaction != null) &#123;</span><br><span class="line">              // Transaction active but no synchronization active.</span><br><span class="line">              Object suspendedResources = doSuspend(transaction);</span><br><span class="line">              return new SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">              // Neither transaction nor synchronization active.</span><br><span class="line">              return null;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Reactivate transaction synchronization for the current thread</span><br><span class="line"> * and resume all given synchronizations.</span><br><span class="line"> * @param suspendedSynchronizations List of TransactionSynchronization objects</span><br><span class="line"> */doSuspend 失败则恢复事务</span><br><span class="line">private void doResumeSynchronization(List&lt;TransactionSynchronization&gt; suspendedSynchronizations) &#123;</span><br><span class="line">       TransactionSynchronizationManager.initSynchronization();／／维护着ThreadLocal变量</span><br><span class="line">       for (TransactionSynchronization synchronization : suspendedSynchronizations) &#123;</span><br><span class="line">              synchronization.resume();</span><br><span class="line">              TransactionSynchronizationManager.registerSynchronization(synchronization);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务的提交"><a href="#事务的提交" class="headerlink" title="事务的提交"></a>事务的提交</h4><p>在声明式事务处理中，事务的提交在TransactionInteceptor的invoke方法中实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitTransactionAfterReturning(txInfo)</span><br></pre></td></tr></table></figure></p>
<p>txInfo是TransactionInfo对象，是创建事务时生成的。同时，Spring的事务管理框架的生成的TransactionStatus对象就包含在TransactionInfo对象中。commitTransactionAfterReturning具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void commitTransactionAfterReturning(TransactionAspectSupport.TransactionInfo txInfo) &#123;</span><br><span class="line">  if(txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">    if(this.logger.isTraceEnabled()) &#123;</span><br><span class="line">      this.logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用具体的事务管理器实现。而在事务管理器中的实现在AbstractPlatformTransactionManager中存在一个模版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* This implementation of commit handles participating in existing</span><br><span class="line">* transactions and programmatic rollback requests.</span><br><span class="line">* Delegates to &#123;@code isRollbackOnly&#125;, &#123;@code doCommit&#125;</span><br><span class="line">* and &#123;@code rollback&#125;.</span><br><span class="line">* @see org.springframework.transaction.TransactionStatus#isRollbackOnly()</span><br><span class="line">* @see #doCommit</span><br><span class="line">* @see #rollback</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public final void commit(TransactionStatus status) throws TransactionException &#123;</span><br><span class="line">       if (status.isCompleted()) &#123;</span><br><span class="line">              throw new IllegalTransactionStateException(</span><br><span class="line">                            &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">       if (defStatus.isLocalRollbackOnly()) &#123;／／如果事务处理过程中发生了异常，调用回滚。</span><br><span class="line">              if (defStatus.isDebug()) &#123;</span><br><span class="line">                     logger.debug(&quot;Transactional code has requested rollback&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              processRollback(defStatus);</span><br><span class="line">              return;</span><br><span class="line">       &#125;</span><br><span class="line">       if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">              if (defStatus.isDebug()) &#123;</span><br><span class="line">                     logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);</span><br><span class="line">              &#125;／／处理回滚</span><br><span class="line">              processRollback(defStatus);</span><br><span class="line">              // Throw UnexpectedRollbackException only at outermost transaction boundary</span><br><span class="line">              // or if explicitly asked to.</span><br><span class="line">              if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                     throw new UnexpectedRollbackException(</span><br><span class="line">                                   &quot;Transaction rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              return;</span><br><span class="line">       &#125;</span><br><span class="line">       ／／处理提交入口</span><br><span class="line">       processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出rollback和commit都在这个方法中实现。看看 processCommit的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">              boolean beforeCompletionInvoked = false;</span><br><span class="line">              try &#123;／／事务的提交准备工作由具体的事务处理器来完成</span><br><span class="line">                     prepareForCommit(status);</span><br><span class="line">                     triggerBeforeCommit(status);</span><br><span class="line">                     triggerBeforeCompletion(status);</span><br><span class="line">                     beforeCompletionInvoked = true;</span><br><span class="line">                     boolean globalRollbackOnly = false;</span><br><span class="line">                     if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                            globalRollbackOnly = status.isGlobalRollbackOnly();</span><br><span class="line">                     &#125;／／嵌套事务的处理过程。</span><br><span class="line">                     if (status.hasSavepoint()) &#123;</span><br><span class="line">                            if (status.isDebug()) &#123;</span><br><span class="line">                                   logger.debug(&quot;Releasing transaction savepoint&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            status.releaseHeldSavepoint();</span><br><span class="line">                     &#125;</span><br><span class="line">                     else if (status.isNewTransaction()) &#123;／／根据当前线程中保存的事务状态进行处理，如果当前的事务是一个新的事务，调用具体事务处理器的完成提交，如果当前所持有的事务不是一个新事务，则不提交，由已经存在的事务来完成提交</span><br><span class="line">                            if (status.isDebug()) &#123;</span><br><span class="line">                                   logger.debug(&quot;Initiating transaction commit&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            doCommit(status);</span><br><span class="line">                     &#125;</span><br><span class="line">                     // Throw UnexpectedRollbackException if we have a global rollback-only</span><br><span class="line">                     // marker but still didn&apos;t get a corresponding exception from commit.</span><br><span class="line">                     if (globalRollbackOnly) &#123;</span><br><span class="line">                            throw new UnexpectedRollbackException(</span><br><span class="line">                                          &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (UnexpectedRollbackException ex) &#123;</span><br><span class="line">                     // can only be caused by doCommit</span><br><span class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">                     throw ex;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (TransactionException ex) &#123;</span><br><span class="line">                     // can only be caused by doCommit</span><br><span class="line">                     if (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">                            doRollbackOnCommitException(status, ex);</span><br><span class="line">                     &#125;</span><br><span class="line">                     else &#123;</span><br><span class="line">                            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">                     &#125;</span><br><span class="line">                     throw ex;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (RuntimeException ex) &#123;</span><br><span class="line">                     if (!beforeCompletionInvoked) &#123;</span><br><span class="line">                            triggerBeforeCompletion(status);</span><br><span class="line">                     &#125;</span><br><span class="line">                     doRollbackOnCommitException(status, ex);</span><br><span class="line">                     throw ex;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (Error err) &#123;</span><br><span class="line">                     if (!beforeCompletionInvoked) &#123;</span><br><span class="line">                            triggerBeforeCompletion(status);</span><br><span class="line">                     &#125;</span><br><span class="line">                     doRollbackOnCommitException(status, err);</span><br><span class="line">                     throw err;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // Trigger afterCommit callbacks, with an exception thrown there</span><br><span class="line">              // propagated to callers but the transaction still considered as committed.</span><br><span class="line">              try &#123;</span><br><span class="line">                     triggerAfterCommit(status);</span><br><span class="line">              &#125;</span><br><span class="line">              finally &#123;</span><br><span class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       finally &#123;</span><br><span class="line">              cleanupAfterCompletion(status);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，对事务的提交处理都是紧紧围绕TransactionStatus保存的事务处理相关状态进行判断。具体的提交处理过程都设计成抽象方法，交由具体的事务处理器来完成。</p>
<h4 id="事务的回滚"><a href="#事务的回滚" class="headerlink" title="事务的回滚"></a>事务的回滚</h4><p>在事务的提交方法中看到了事务的回滚入口，即processRollback方法，其实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void processRollback(DefaultTransactionStatus status) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                     triggerBeforeCompletion(status);</span><br><span class="line">                     if (status.hasSavepoint()) &#123;／／嵌套事务的回滚处理</span><br><span class="line">                            if (status.isDebug()) &#123;</span><br><span class="line">                                   logger.debug(&quot;Rolling back transaction to savepoint&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            status.rollbackToHeldSavepoint();</span><br><span class="line">                     &#125;／／当前事务调用方法中新建事务的回滚处理</span><br><span class="line">                     else if (status.isNewTransaction()) &#123;</span><br><span class="line">                            if (status.isDebug()) &#123;</span><br><span class="line">                                   logger.debug(&quot;Initiating transaction rollback&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            doRollback(status);</span><br><span class="line">                     &#125;／／如果在当前事务调用方法中没有新建事务的回滚处理</span><br><span class="line">                     else if (status.hasTransaction()) &#123;</span><br><span class="line">                            if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">                                   if (status.isDebug()) &#123;</span><br><span class="line">                                          logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   doSetRollbackOnly(status);</span><br><span class="line">                            &#125;／／由线程的前一个事务来处理回滚，这里不执行任何操作。</span><br><span class="line">                            else &#123;</span><br><span class="line">                                   if (status.isDebug()) &#123;</span><br><span class="line">                                          logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);</span><br><span class="line">                                   &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     else &#123;</span><br><span class="line">                            logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (RuntimeException ex) &#123;</span><br><span class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">                     throw ex;</span><br><span class="line">              &#125;</span><br><span class="line">              catch (Error err) &#123;</span><br><span class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">                     throw err;</span><br><span class="line">              &#125;</span><br><span class="line">              triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">       &#125;</span><br><span class="line">       finally &#123;</span><br><span class="line">              cleanupAfterCompletion(status);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，看了代码我们很快就能理解，Spring 事务传播属性中的 Required_New和NESTED（嵌套事务）的本质区别</p>
<ol>
<li>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行. </li>
<li>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,它将取得一个 savepoint. 如果这个嵌套事务失败,我们将回滚到此savepoint潜套事务是外部事务的一部分,只有外部事务结束后它才会被提交。</li>
<li>由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back. </li>
</ol>
<p>也就是说：</p>
<ol>
<li>PROPAGATION_REQUIRES_NEW事务不受外部事务的影响，是隔离的。</li>
<li>PROPAGATION_NESTED，如果内部事务失败且内部，它会回到savepoint之前的状态不会产生脏数据，而外部事务catch住异常后可以选择回滚或者提交；如果外部事务失败，由于嵌套事务是外部事务的一部分，则会导致外部事务与嵌套事务一起回滚。</li>
</ol>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-02-07T05:08:40.000Z">2017-02-07</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    21 分钟 读完 (大约 3147 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/02/07/Spring源码解读/">Spring源码解读(-)</a>
            
        </h1>
        <div class="content">
            <h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a><strong>设计理念</strong></h4><p>先来看看接口设计预览图：<br><img src="http://jacobs.wanhb.cn/images/ioc1.jpg" alt="IOC接口设计规范"></p>
<p> bean 实例化总体步骤<br><img src="http://jacobs.wanhb.cn/images/bean_initialization.jpg" alt="bean initialization"></p>
<h4 id="资源定位与注册"><a href="#资源定位与注册" class="headerlink" title="资源定位与注册"></a>资源定位与注册</h4><p>容器的初始化过程是IOC实现的入口，过程如下：</p>
<ol>
<li>Resource定位。BeanDefitioin的资源定位，由ResourceLoader通过统一的Resource接口完成<br>，这个Resource对各种形式的BeanDefinition使用都提供了统一接口。</li>
<li>BeanDefition的载入。这个载入过程是用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器的数据结构就是BeanDefition。BeanDefition实际上就是POJO对象在IOC容器中的抽象，通过这个BeanDefition定义的数据结构，使得IOC容器能够方便地对POJO对象也就是Bean进行管理。</li>
<li>向IOC容器注册这些BeanDefition的过程。调用BeanDefitionRegistry接口的实现来完成。把解析得到的BeanDefition向容器中进行注册。在IOC内部将BeanDefition注入到一个HasMap中去(BeanDefitionHolder),IOC容器就是通过这个HashMap来持有这些BeanDefition数据的。</li>
<li><strong>值得注意：</strong>容器初始化过程不包括依赖注入的实现，Bean定义的载入和依赖注入是俩个独立的过程。依赖注入一般发生在第一次getBean的时候或者通过设置lazyinit实现预先注入Bean。 </li>
</ol>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>AbstractApplicationContext定义了基本的refresh方法，其他的由子类去实现扩展,即AbstractApplicationContext是容器初始化的入口</p>
</li>
<li><p>DefaultListableBeanFactory是IOC容器的基础，FileSystemXmlApplicationContext、WebXmlApplicationContext都是建立在DefaultListableBeanFactory之上，实现自定义BeanDefinition的载入方式</p>
</li>
</ul>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p><img src="http://jacobs.wanhb.cn/images/ioc3.jpg" alt="注入过程"></p>
<ul>
<li>初始化过程完成的主要工作是在IOC容器中建立BeanDefinition数据映射。此过程中并没有实现IOC容器对Bean依赖关系进行注入。</li>
<li>对于依赖注入，其触发条件是用户第一次向IOC容器索要Bean时触发的。当然也可以通过控制lazy-init属性来让容器完成对bean的预实例化。</li>
<li><strong>依赖注入的起点：</strong> IOC容器接口BeanFactory中定义了一个getBean接口，这个接口的实现就是触发依赖注入的地方。可以在DefaultListableBeanFactory的类AbstractBeanFactory入手看看getBean的实现。</li>
<li>SimpleInstsntiationStrategy类，这个Strategy是Spring用来生成Bean对象的默认类，提供了俩种实例化Java对象的方法，一种是通过BeanUtils，它使用了JVM的反射功能，一种是CGLIB来生成，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</span><br><span class="line">		// Don&apos;t override the class with CGLIB if no overrides.</span><br><span class="line">		if (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">			Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">			synchronized (bd.constructorArgumentLock) &#123;</span><br><span class="line">				constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">				if (constructorToUse == null) &#123;</span><br><span class="line">					final Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">					if (clazz.isInterface()) &#123;</span><br><span class="line">						throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					try &#123;</span><br><span class="line">						if (System.getSecurityManager() != null) &#123;</span><br><span class="line">							constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">								@Override</span><br><span class="line">								public Constructor&lt;?&gt; run() throws Exception &#123;</span><br><span class="line">									return clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;);</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							constructorToUse =	clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">						&#125;</span><br><span class="line">						bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Throwable ex) &#123;</span><br><span class="line">						throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Must generate CGLIB subclass.</span><br><span class="line">			return instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>依赖注入最终步骤</strong>：在实例化Bean对象生成的基础上，对于Bean对象生成以后，怎样对这些Bean对象的依赖关系处理好，完成整个依赖注入过程？即通过populateBean方法完成，这个方法在AbstractAutowireCapableBeanFactory中实现，AutoWire的依赖注入等，都做了集中处理。</p>
</li>
<li><p><strong>Bean的初始化(InitializeBean)：</strong>：在initializeBean方法中，需要使用Bean的名字，完成依赖注入以后的Bean对象，以及这个Bean对应的BeanDefinition。然后开始初始化工作：</p>
<ol>
<li>为类型是BeanNameAware的Bean设置Bean的名字</li>
<li>为类型是BeanClassLoaderAware的Bean设置类装载器，</li>
<li>类型是BeanFactoryAware的Bean设置自身所在的IOC容器以供回调使用，对PostProcessBeforeInitialization/postAfterInitialization的回调和初始化属性init-method的处理等。</li>
<li>最后，就可以正常的使用由IOC容器托管的Bean了</li>
</ol>
</li>
</ul>
<h4 id="讲讲预先注入"><a href="#讲讲预先注入" class="headerlink" title="讲讲预先注入"></a>讲讲预先注入</h4><p>我们讲过依赖注入一般发生在用户第一次请求，但是也可以设置lazy-init属性实现预先依赖注入。这部分过程依然属于AbstractApplicationContext的 refresh方法中。在finishBeanFactoryInitialization的方法中，封装了lazy-init属性的处理，实际的处理是在DefaultListableBeanFactory这个基本容器的preInstantiateSingletons方法中完成的。该方法对单件Bean完成预先实例化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   Object var1 = this.startupShutdownMonitor;</span><br><span class="line">   synchronized(this.startupShutdownMonitor) &#123;</span><br><span class="line">     this.prepareRefresh();</span><br><span class="line">     ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</span><br><span class="line">     this.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">       this.postProcessBeanFactory(beanFactory);</span><br><span class="line">       this.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">       this.registerBeanPostProcessors(beanFactory);</span><br><span class="line">       this.initMessageSource();</span><br><span class="line">       this.initApplicationEventMulticaster();</span><br><span class="line">       this.onRefresh();</span><br><span class="line">       this.registerListeners();</span><br><span class="line">       //预先实例化入口</span><br><span class="line">       this.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">       this.finishRefresh();</span><br><span class="line">     &#125; catch (BeansException var9) &#123;</span><br><span class="line">       if(this.logger.isWarnEnabled()) &#123;</span><br><span class="line">         this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);</span><br><span class="line">       &#125;</span><br><span class="line">       this.destroyBeans();</span><br><span class="line">       this.cancelRefresh(var9);</span><br><span class="line">       throw var9;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       this.resetCommonCaches();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //在finishBeanFactoryInitialization方法中进行具体的处理过程</span><br><span class="line"> protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   ...</span><br><span class="line">   beanFactory.setTempClassLoader((ClassLoader)null);</span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">	List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">	// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">	for (String beanName : beanNames) &#123;</span><br><span class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			if (isFactoryBean(beanName)) &#123;</span><br><span class="line">				final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				boolean isEagerInit;</span><br><span class="line">				if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">					isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Boolean run() &#123;</span><br><span class="line">							return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">							((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">				&#125;</span><br><span class="line">				if (isEagerInit) &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">	for (String beanName : beanNames) &#123;</span><br><span class="line">		Object singletonInstance = getSingleton(beanName);</span><br><span class="line">		if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">			final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">					@Override</span><br><span class="line">					public Object run() &#123;</span><br><span class="line">						smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">						return null;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>存疑：</strong> spring 2 中preInstantiateSingletons的实现是加了个Synchronized内置锁，而在当前版本中，这一步去掉了锁，why?</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="AOP名词解释"><a href="#AOP名词解释" class="headerlink" title="AOP名词解释"></a>AOP名词解释</h4><ul>
<li><strong>方面（Aspect）</strong>：<br>一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用spring的 Advisor或拦截器实现。</li>
<li><strong>连接点（Joinpoint）:</strong> 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</li>
<li><strong>通知（Advice）:</strong> 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice</li>
<li><strong>切入点（Pointcut 一系列连接点的集合）:</strong> 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</li>
<li><strong>引入（Introduction）:</strong> 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</li>
<li><strong>目标对象（Target Object）:</strong> 包含连接点的对象。也被称作被通知或被代理对象。POJO</li>
<li><strong>AOP代理（AOP Proxy）:</strong> AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li>
<li><strong>织入（Weaving）:</strong> 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入</li>
</ul>
<h4 id="设计原理及流程"><a href="#设计原理及流程" class="headerlink" title="设计原理及流程"></a><strong>设计原理及流程</strong></h4><p>Advice、PointCut、Advisor(通知器，组织起Advice与PointCut)</p>
<p><img src="http://jacobs.wanhb.cn/images/aopinterface.jpg" alt="接口设计"><br>AopProxy代理对象生成过程：ProxyFactoryBean和ProxyFactory都提供了AOP的功能封装，但是ProxyFactoryBean与IOC进行了结合，利用BeanFactoryAware获取ApplicationContext,从而可以利用context对IOC注入的bean进行获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化通知链—— &gt;获取单例，没有的话去创建——&gt;判断是否为接口，如果为接口使用JDK,如果不是使用CGlib最后返回AopProxy</span><br></pre></td></tr></table></figure>
<h4 id="AOP调用"><a href="#AOP调用" class="headerlink" title="AOP调用"></a><strong>AOP调用</strong></h4><p>invoke方法，里面逐个去应用配置好的拦截器链,在逐个应用之前先进行一系列的判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">／／如果目标对象没有实现object的基本法方法：equals、如果目标对象没有实现object的基本方法： hashcode、根据代理对象的配置来调用服务</span><br><span class="line">if(!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">  Boolean retVal3 = Boolean.valueOf(this.equals(args[0]));</span><br><span class="line">  return retVal3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">  Integer retVal2 = Integer.valueOf(this.hashCode());</span><br><span class="line">  return retVal2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">  Class retVal1 = AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">  return retVal1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line">if(!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">  retVal = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">  return retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(this.advised.exposeProxy) &#123;</span><br><span class="line">  oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">  setProxyContext = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line">if(target != null) &#123;</span><br><span class="line">  targetClass = target.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后获取配置好的拦截器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br></pre></td></tr></table></figure>
<p>判断是否为空，为空的话直接调用invokeJoinpointUsingReflection方法。这个方法直接调用目标方法的实现，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(method);</span><br><span class="line">    return method.invoke(target, args);</span><br><span class="line">  &#125; catch (InvocationTargetException var4) &#123;</span><br><span class="line">    throw var4.getTargetException();</span><br><span class="line">  &#125; catch (IllegalArgumentException var5) &#123;</span><br><span class="line">    throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; + method + &quot;] on target [&quot; + target + &quot;]&quot;, var5);</span><br><span class="line">  &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">    throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, var6);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果不为空，则创建ReflectiveMethodInvocation传入chain（拦截器链）,然后调用proceed方法，这个方法去递归调用拦截器链中的invoke方法，代码如下（在拦截器的调用一节还会详细展开介绍）：</span><br><span class="line">ReflectiveMethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line"></span><br><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">  if(this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">    return this.invokeJoinpoint();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">    if(interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">      InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;</span><br><span class="line">      return dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)?dm.interceptor.invoke(this):this.proceed();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于最后的目标对象的调用：JDK 直接通过AopUtils的反射机制而cglib则是通过 MethodProxy完成调用，这是cglib自己封住好的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval=methodProxy.invoke(target,args);</span><br></pre></td></tr></table></figure>
<h4 id="AOP拦截器链的调用"><a href="#AOP拦截器链的调用" class="headerlink" title="AOP拦截器链的调用"></a><strong>AOP拦截器链的调用</strong></h4><p>了解了AOP的调用之后，再来看看AOP是怎么实现对目标对象增强的。<br>在运行拦截器链的拦截方法时，需要对代理方法完成一个匹配判断，通过这个匹配判断来决定是否满足切面增强的要求。确定是否执行拦截方法。<br>获取interceptors的操作是由advised的对象完成的。是一个AdvisedSupport对象。AdvisedSupport是ProxyFactoryBean的基类。在其中，我们可以看到getInterceptorsAndDynamicInterceptionAdvice 方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">  AdvisedSupport.MethodCacheKey cacheKey = new AdvisedSupport.MethodCacheKey(method);</span><br><span class="line">  List cached = (List)this.methodCache.get(cacheKey);</span><br><span class="line">  if(cached == null) &#123;</span><br><span class="line">    cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);</span><br><span class="line">    this.methodCache.put(cacheKey, cached);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里AdvisedSupport被配置成一个DefaultAdvisedSupport对象，里面实现了具体的getInterceptorsAndDynamicInterceptionAdvice方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">  ArrayList interceptorList = new ArrayList(config.getAdvisors().length);</span><br><span class="line">  Class actualClass = targetClass != null?targetClass:method.getDeclaringClass();</span><br><span class="line">  boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">  AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">  Advisor[] var8 = config.getAdvisors();</span><br><span class="line">  int var9 = var8.length;</span><br><span class="line"></span><br><span class="line">  for(int var10 = 0; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">    Advisor advisor = var8[var10];</span><br><span class="line">    MethodInterceptor[] interceptors1;</span><br><span class="line">    if(advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">      PointcutAdvisor var20 = (PointcutAdvisor)advisor;</span><br><span class="line">      if(config.isPreFiltered() || var20.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">        interceptors1 = registry.getInterceptors(advisor);</span><br><span class="line">        MethodMatcher mm = var20.getPointcut().getMethodMatcher();</span><br><span class="line">        if(MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">          if(mm.isRuntime()) &#123;</span><br><span class="line">            MethodInterceptor[] var15 = interceptors1;</span><br><span class="line">            int var16 = interceptors1.length;</span><br><span class="line"></span><br><span class="line">            for(int var17 = 0; var17 &lt; var16; ++var17) &#123;</span><br><span class="line">              MethodInterceptor interceptor = var15[var17];</span><br><span class="line">              interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            interceptorList.addAll(Arrays.asList(interceptors1));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">      IntroductionAdvisor var19 = (IntroductionAdvisor)advisor;</span><br><span class="line">      if(config.isPreFiltered() || var19.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">        interceptors1 = registry.getInterceptors(advisor);</span><br><span class="line">        interceptorList.addAll(Arrays.asList(interceptors1));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">      interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultAdvisorChainFactory 会通过一个AdvisorDapterRegister实现拦截器的注册，注册完成之后,List中的拦截器会被JDK生成的AopProxy中的代理对象的invoke调用，这里通过配置的Intercepters获得拦截器列表然后逐一应用在目标方法上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123;</span><br><span class="line">    ArrayList interceptors = new ArrayList(3);</span><br><span class="line">    Advice advice = advisor.getAdvice();</span><br><span class="line">    if(advice instanceof MethodInterceptor) &#123;</span><br><span class="line">      interceptors.add((MethodInterceptor)advice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator var4 = this.adapters.iterator();</span><br><span class="line"></span><br><span class="line">    while(var4.hasNext()) &#123;</span><br><span class="line">      AdvisorAdapter adapter = (AdvisorAdapter)var4.next();</span><br><span class="line">      if(adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">        interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(interceptors.isEmpty()) &#123;</span><br><span class="line">      throw new UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[interceptors.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-29T16:54:43.000Z">2017-01-30</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    10 分钟 读完 (大约 1495 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/30/类函数式的sql生成工具类的封装/">类函数式的sql生成工具类的封装</a>
            
        </h1>
        <div class="content">
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自从正式工作以来，公司一直用的是Spring 原生的JDBC Template以及在其上封装的扩展的一些小工具， 而摈弃了Mybatis、ibatis等ORM框架。总的来说，这种做法对于开发效率来说提高不少，由于真正的查库操作不会直接穿透到Mysql，所以抗压性也没有太大的问题。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>虽说直接使用原生的JDBC Template比较方便，但是构造参数条件，以及生成查询语句过于简单粗暴，导致代码不简洁，复用度也不高。举个例子，根据特定的条件查询用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sqlBuilder = new StringBuffer(&quot;select * from user where &quot;);</span><br><span class="line">Map&lt;String, Object&gt; paramsMap = new HashMap&lt;&gt;();</span><br><span class="line">if (userId != null) &#123;</span><br><span class="line">  sqlBuilder.append(&quot;user_id=:userId&quot;);</span><br><span class="line">  paramsMap.put(&quot;userId&quot;, userId);</span><br><span class="line">&#125;</span><br><span class="line">if (batchNumber != null) &#123;</span><br><span class="line">  sqlBuilder.append(&quot;batch_number=:batchNumber&quot;);</span><br><span class="line">  paramsMap.put(&quot;batchNumber&quot;, batchNumber);</span><br><span class="line">&#125;</span><br><span class="line">if (status != null) &#123;</span><br><span class="line">  sqlBuilder.append(&quot;status=:status&quot;);</span><br><span class="line">  paramsMap.put(&quot;stats&quot;, status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (page &gt; 0 &amp;&amp; count &gt; 0) &#123;</span><br><span class="line">  sqlBuilder.append(&quot; limit &quot;)</span><br><span class="line">      .append(page * count)</span><br><span class="line">      .append(&quot;, &quot;)</span><br><span class="line">      .append(count);</span><br><span class="line">&#125;</span><br><span class="line">//生成sql语句</span><br><span class="line">sqlBuilder.toString();</span><br></pre></td></tr></table></figure></p>
<p>可以看到上面的代码大部分在重复同样的逻辑，20多行的代码仅仅只是在构造sql语句以及收集参数，而且这些重复的代码将充斥项目所有的DAO层，导致代码非常不整洁。维护困难。</p>
<h3 id="sql生成工具类封装"><a href="#sql生成工具类封装" class="headerlink" title="sql生成工具类封装"></a>sql生成工具类封装</h3><p>秉承着恶心重复的代码要重构抽象的态度，对sql生成的步骤，做了一次简单的封装：</p>
<ul>
<li>先介绍接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface Order &#123;</span><br><span class="line">    Where desc();</span><br><span class="line"></span><br><span class="line">    Where asc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">public interface Where &#123;</span><br><span class="line">    Where ifPresent(Object value, String sql);</span><br><span class="line"></span><br><span class="line">    Order orderBy(String field);</span><br><span class="line"></span><br><span class="line">    Where limit(int begin, int end);</span><br><span class="line"></span><br><span class="line">    Where in(List&lt;Object&gt; values, String sql);</span><br><span class="line"></span><br><span class="line">    String sql();//构造的sql</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; params();//参数值</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>根据sql语句的特点，抽出子句部分的生成单独构造，涵盖Where, in(暂未实现)，limit 以及 order 排序规则。</p>
<ul>
<li>来看看接口的实现<br>将所有相关的类通过内部静态类封装入SqlWhereBuffer类中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public class SqlWhereBuffer &#123;</span><br><span class="line"></span><br><span class="line">  public static SqlWhereBuffer.Where builder() &#123;</span><br><span class="line">    return new Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static class Builder implements SqlWhereBuffer.Order, SqlWhereBuffer.Where &#123;</span><br><span class="line">    private List&lt;String&gt; sql = new ArrayList&lt;&gt;();</span><br><span class="line">    private Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span><br><span class="line">    private String orderBy = &quot; &quot;;</span><br><span class="line">    private String limit = &quot; &quot;;</span><br><span class="line">    private String in = &quot; &quot;;</span><br><span class="line">    private List&lt;SqlMapperPlugin&gt; sqlMapperPlugins;</span><br><span class="line"></span><br><span class="line">    public Builder() &#123;</span><br><span class="line">      //添加基本类型默认的插件</span><br><span class="line">      sqlMapperPlugins = Lists.newArrayList();</span><br><span class="line">      this.mapperPlugins(SqlMapperPlugin.EnumSqlPlugin)</span><br><span class="line">          .mapperPlugins(SqlMapperPlugin.BooleanSqlPlugin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder mapperPlugins(SqlMapperPlugin sqlMapperPlugin) &#123;</span><br><span class="line">      if (CollectionUtils.isEmpty(sqlMapperPlugins)) &#123;</span><br><span class="line">        sqlMapperPlugins = Lists.newArrayList();</span><br><span class="line">      &#125;</span><br><span class="line">      sqlMapperPlugins.add(sqlMapperPlugin);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SqlWhereBuffer.Where ifPresent(Object value, String sql) &#123;</span><br><span class="line">      Optional.ofNullable(value)</span><br><span class="line">          .ifPresent(val -&gt; &#123;</span><br><span class="line">            this.sql.add(sql);</span><br><span class="line">            Pattern pattern = Pattern.compile(&quot;:([a-z,A-Z,\\w,_]*)&quot;); //固定的sql参数模式</span><br><span class="line">            Matcher matcher = pattern.matcher(sql);</span><br><span class="line">            if (!matcher.find()) &#123;</span><br><span class="line">              throw new IllegalArgumentException(sql + &quot; don&apos;t include :name&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Optional&lt;SqlMapperPlugin&gt; mapper = sqlMapperPlugins.stream()</span><br><span class="line">                .filter(sqlMapperPlugin -&gt; sqlMapperPlugin.test(val))</span><br><span class="line">                .findFirst();</span><br><span class="line">            if (mapper.isPresent()) &#123;</span><br><span class="line">              params.putAll(mapper.get()</span><br><span class="line">                  .getParams(matcher.group(1), value));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              //匹配不到走默认的插件</span><br><span class="line">              params.put(matcher.group(1), value);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SqlWhereBuffer.Order orderBy(String field) &#123;</span><br><span class="line">      orderBy += &quot;ORDER BY &quot; + field;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SqlWhereBuffer.Where limit(int offset, int count) &#123;</span><br><span class="line">      limit += &quot;limit &quot; + offset + &quot;,&quot; + count;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String sql() &#123;</span><br><span class="line">      if (sql.isEmpty() || params.isEmpty()) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &quot; WHERE &quot; + sql.stream()</span><br><span class="line">            .collect(Collectors.joining(&quot; AND &quot;)) + orderBy + limit;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ImmutableMap&lt;String, Object&gt; params() &#123;</span><br><span class="line">      return ImmutableMap.copyOf(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SqlWhereBuffer.Where desc() &#123;</span><br><span class="line">      orderBy += &quot; DESC&quot;;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SqlWhereBuffer.Where asc() &#123;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>静态类Builder实现了SqlWhereBuffer.Order, SqlWhereBuffer.Where这俩个接口的方法。ifPresent是主入口。流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、在ifPresent中参数先进行非空判断，如果是空则直接过滤掉；</span><br><span class="line">2、然后通过一个正则表达式（**:([a-z,A-Z,\\w,_]*)**）对参数sql进行规则校验，如果不符合也将过滤；</span><br><span class="line">3、最后value通过一系列的自定义的注册插件的匹配判断，得出sql以及params。</span><br></pre></td></tr></table></figure></p>
<ul>
<li>关于自定义插件，本没想做这么复杂，然而在实际的使用过程中，JDBC Template对Enum的支持不够…不过想也是，Enum大多是自定义的，没法做到一套约定的接口满足所有需求。于是封装了一个插件类，方便以后扩展：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public static class SqlMapperPlugin &#123;</span><br><span class="line">    private final Predicate&lt;Object&gt; predicate;</span><br><span class="line">    private final ParamValue paramValue;</span><br><span class="line"></span><br><span class="line">    private SqlMapperPlugin(Predicate&lt;Object&gt; predicate,</span><br><span class="line">        ParamValue paramValue) &#123;</span><br><span class="line">      this.predicate = predicate;</span><br><span class="line">      this.paramValue = paramValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //定义枚举插件</span><br><span class="line">    static SqlMapperPlugin EnumSqlPlugin = of(Enum.class).paramValue((value, sql) -&gt;</span><br><span class="line">        Collections.singletonMap(sql, getEnumValue(value))</span><br><span class="line">    );</span><br><span class="line">    //定义Boolean插件</span><br><span class="line">    static SqlMapperPlugin BooleanSqlPlugin = of(Boolean.class).paramValue((value, sql) -&gt;</span><br><span class="line">        Collections.singletonMap(sql, ((boolean) value) ? 1 : 0)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    public static SqlMapperPlugin.MapperPluginsBuilder of(Predicate&lt;Object&gt; predicate) &#123;</span><br><span class="line">      return new MapperPluginsBuilder(predicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SqlMapperPlugin.MapperPluginsBuilder of(Class clazz) &#123;</span><br><span class="line">      return of((pd) -&gt; &#123;</span><br><span class="line">        return clazz.isAssignableFrom(pd.getClass());</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean test(Object pd) &#123;</span><br><span class="line">      return this.predicate.test(pd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; getParams(String sql, Object value) &#123;</span><br><span class="line">      return paramValue.getParams(value, sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class MapperPluginsBuilder &#123;</span><br><span class="line"></span><br><span class="line">      Predicate&lt;Object&gt; predicate;</span><br><span class="line"></span><br><span class="line">      public MapperPluginsBuilder(Predicate&lt;Object&gt; predicate) &#123;</span><br><span class="line">        this.predicate = predicate;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public SqlMapperPlugin paramValue(SqlMapperPlugin.ParamValue paramValue) &#123;</span><br><span class="line">        return new SqlMapperPlugin(this.predicate, paramValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @FunctionalInterface</span><br><span class="line">    public interface ParamValue &#123;</span><br><span class="line">      Map&lt;String, Object&gt; getParams(Object var1, String var2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static String getEnumValue(Object value) &#123;</span><br><span class="line">    Method method;</span><br><span class="line">    try &#123;</span><br><span class="line">      method = value.getClass()</span><br><span class="line">          .getMethod(&quot;name&quot;);</span><br><span class="line">      return String.valueOf(method.invoke(value));</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;NoSuchMethodException&quot;, e);</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;IllegalAccessException&quot;, e);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;InvocationTargetException&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>主要用到了java8中新增的Predicate接口，用于判断value的Class类型，以及自己定义了一个FunctionalInterface 用于获取查询参数。这里先实现了EnumSqlPlugin，BooleanSqlPlugin俩个插件，之后有其他类型的需求，也可以通过类似的形式加入。对EnumSqlPlugin实现进行解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义枚举插件</span><br><span class="line">    static SqlMapperPlugin EnumSqlPlugin = of(Enum.class).paramValue((value, sql) -&gt;</span><br><span class="line">        Collections.singletonMap(sql, getEnumValue(value))</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>通过定义的of方法定义赋值Predicate,作为判断value是否为指定类型的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static SqlMapperPlugin.MapperPluginsBuilder of(Class clazz) &#123;</span><br><span class="line">      return of((pd) -&gt; &#123;</span><br><span class="line">        return clazz.isAssignableFrom(pd.getClass());</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>of方法返回了MapperPluginsBuilder类，紧接着定义函数式接口paramValue的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.singletonMap(sql, getEnumValue(value))</span><br></pre></td></tr></table></figure></p>
<p>最后返回EnumSqlPlugin对应的新实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new SqlMapperPlugin(this.predicate, paramValue);</span><br></pre></td></tr></table></figure></p>
<p>使用的时候，在Builder的构造函数中注入默认的插件即可，如日后有扩展，也可调用mapperPlugins方法动态加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> private List&lt;SqlMapperPlugin&gt; sqlMapperPlugins;</span><br><span class="line"> public Builder() &#123;</span><br><span class="line">      //添加基本类型默认的插件</span><br><span class="line">      sqlMapperPlugins = Lists.newArrayList();</span><br><span class="line">      this.mapperPlugins(SqlMapperPlugin.EnumSqlPlugin)</span><br><span class="line">          .mapperPlugins(SqlMapperPlugin.BooleanSqlPlugin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public Builder mapperPlugins(SqlMapperPlugin sqlMapperPlugin)    &#123;</span><br><span class="line">      if (CollectionUtils.isEmpty(sqlMapperPlugins)) &#123;</span><br><span class="line">        sqlMapperPlugins = Lists.newArrayList();</span><br><span class="line">      &#125;</span><br><span class="line">      sqlMapperPlugins.add(sqlMapperPlugin);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h3><p>现在，我们可以使用封装好的工具了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SqlWhereBuffer.Where where = SqlWhereBuffer.builder()</span><br><span class="line">        .ifPresent(batchNumber, &quot;batch_number=:batchNumber&quot;)</span><br><span class="line">        .ifPresent(status, &quot;upload_result=:uploadResult&quot;)</span><br><span class="line">        .ifPresent(userId, &quot;user_id=:userId&quot;)</span><br><span class="line">        .limit(page * count, count)</span><br><span class="line">        .orderBy(&quot;id&quot;)</span><br><span class="line">        .asc();</span><br></pre></td></tr></table></figure></p>
<p>这样，代码变得整洁多了，也符合java8函数式风格的效果。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-20T08:02:15.000Z">2017-01-20</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    10 分钟 读完 (大约 1549 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/20/ReentrantLock与condition应用后的思考/">ReentrantLock与condition应用后的思考</a>
            
        </h1>
        <div class="content">
            <p>一直在断断续续看《java并发编程实战》这本书，每次看都有不一样的体会，前些日子在知乎上回答了一个关于ReentrantLock的问题<a href="https://www.zhihu.com/question/52273413" target="_blank" rel="noopener">java里是怎么通过condition接口是获取监视器方法的</a> ,那次回答之后也引发了我对其实现的进一步探究。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>举一个简单的例子，是基本上各个公司招聘的时候都会出现的关于多线程间通信的问题：利用多线程循环打印n次”ABC”。当然，这个题目有很多实现方法，有经典的wait和notify的原生方法,也有时髦一点的ReentrantLock写法，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by lichao on 2016/1/20.</span><br><span class="line"> */</span><br><span class="line">public class PrintABC &#123;</span><br><span class="line"></span><br><span class="line">  static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">  static Condition conditionA = lock.newCondition();</span><br><span class="line">  static Condition conditionB = lock.newCondition();</span><br><span class="line">  static Condition conditionC = lock.newCondition();</span><br><span class="line">  static int signal = 1;//1=&gt;A, 2=&gt;B 3=&gt;C</span><br><span class="line">  static int loopValue = 10;</span><br><span class="line"></span><br><span class="line">  class taskA implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">        for (int i = 0; i &lt; loopValue; i++) &#123;</span><br><span class="line">          if (signal != 1) &#123;</span><br><span class="line">            conditionA.await();</span><br><span class="line">            conditionB.signalAll();</span><br><span class="line">            conditionC.signalAll();</span><br><span class="line">          &#125;</span><br><span class="line">          signal = 2;</span><br><span class="line">          System.out.print(&quot;A&quot;);</span><br><span class="line">          conditionB.signal();</span><br><span class="line">          conditionA.await();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class taskB implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">        for (int i = 0; i &lt; loopValue; i++) &#123;</span><br><span class="line">          if (signal != 2) &#123;</span><br><span class="line">            conditionB.await();</span><br><span class="line">            conditionA.signalAll();</span><br><span class="line">            conditionC.signalAll();</span><br><span class="line">          &#125;</span><br><span class="line">          signal = 3;</span><br><span class="line">          System.out.print(&quot;B&quot;);</span><br><span class="line">          conditionC.signal();</span><br><span class="line">          conditionB.await();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class taskC implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">        for (int i = 0; i &lt; loopValue; i++) &#123;</span><br><span class="line">          if (signal != 3) &#123;</span><br><span class="line">            conditionC.await();</span><br><span class="line">            conditionB.signalAll();</span><br><span class="line">            conditionA.signalAll();</span><br><span class="line">          &#125;</span><br><span class="line">          signal = 1;</span><br><span class="line">          System.out.print(&quot;C&quot;);</span><br><span class="line">          conditionA.signal();</span><br><span class="line">          conditionC.await();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">    executorService.submit(new PrintABC().new taskC());</span><br><span class="line">    executorService.submit(new PrintABC().new taskB());</span><br><span class="line">    executorService.submit(new PrintABC().new taskA());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先定义了一个可重入锁，然后起了三个监视器用于控制任务a,b,c的状态，signal作为信号量用于表明当前应该哪个线程执行打印操作，实现无论任务往线程池中提交的顺序如何都能正确打印ABC的顺序</p>
<h3 id="讲讲原理"><a href="#讲讲原理" class="headerlink" title="讲讲原理"></a>讲讲原理</h3><ul>
<li>ReentrantLock（重入锁）是jdk的concurrent包提供的一种独占锁的实现。它继承自Dong Lea的 AbstractQueuedSynchronizer（同步器）。回到上面的代码，我们提交任务是按照CBA的次序来提交的，也就是打印C的任务会先开始执行，而当前的信号量signal为1,也就是A而不是3，所以通过conditonC.await()来释放锁，同时线程休眠等待唤醒，这时A拿到了，并且打印后将signal置为2即B，同时通过conditionA.await()方法使自己休眠，并唤醒B进行打印。以此类推，总的来说，ReentrantLock�与condition配合，优雅的完成了wait和notify做的事情。</li>
<li>我们来看看其中是如何实现这种线程的调度过程的：reentrantLock.newCondition() 返回的是Condition的一个实现，该类在AbstractQueuedSynchronizer中被实现，可以访问AbstractQueuedSynchronizer中的方法和其余内部类,await被调用时的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">if (Thread.interrupted())</span><br><span class="line"> throw new InterruptedException();</span><br><span class="line"> //将当前线程包装下后，添加到Condition自己维护的一个链表中。</span><br><span class="line"> Node node = addConditionWaiter(); </span><br><span class="line"> //释放当前线程占有的锁</span><br><span class="line">int savedState = fullyRelease(node);</span><br><span class="line">int interruptMode = 0;</span><br><span class="line"> while (!isOnSyncQueue(node)) &#123;</span><br><span class="line"> //释放完毕后，不断AQS的队列，看当前节点是否在队列中，不在 说明它还没有竞争锁的资格，所以继续将自己沉睡。直到它被重新加入到队列中.</span><br><span class="line"> LockSupport.park(this);</span><br><span class="line"> if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line"> break;</span><br><span class="line"> &#125;</span><br><span class="line">//被唤醒后，重新开始正式竞争锁，同样，如果竞争不到还是会将自己沉睡，等待唤醒重新开始竞争。</span><br><span class="line">if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line"> interruptMode = REINTERRUPT;</span><br><span class="line"> if (node.nextWaiter != null)</span><br><span class="line"> unlinkCancelledWaiters();</span><br><span class="line"> if (interruptMode != 0)</span><br><span class="line"> reportInterruptAfterWait(interruptMode);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>signal方法的调用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line"> if (!isHeldExclusively())</span><br><span class="line"> throw new IllegalMonitorStateException();</span><br><span class="line"> Node first = firstWaiter; //firstWaiter为condition自己维护的一个链表的头结点，</span><br><span class="line">                          //取出第一个节点后开始唤醒操作</span><br><span class="line"> if (first != null)</span><br><span class="line"> doSignal(first);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> private void doSignal(Node first) &#123;</span><br><span class="line"> do &#123;</span><br><span class="line"> if ( (firstWaiter = first.nextWaiter) == null) //修改头结点，完成旧头结点的移出工作</span><br><span class="line"> lastWaiter = null;</span><br><span class="line"> first.nextWaiter = null;</span><br><span class="line"> &#125; while (!transferForSignal(first) &amp;&amp;//将老的头结点，加入到AQS的等待队列中</span><br><span class="line"> (first = firstWaiter) != null);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line"> /*</span><br><span class="line"> * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line"> */</span><br><span class="line"> if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line"> return false;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line"> * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line"> * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line"> * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line"> */</span><br><span class="line"> Node p = enq(node);</span><br><span class="line"> int ws = p.waitStatus;</span><br><span class="line">//如果该结点的状态为cancel 或者修改waitStatus失败，则直接唤醒。</span><br><span class="line"> if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line"> LockSupport.unpark(node.thread);</span><br><span class="line"> return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>其实condition内部维护了一个等待队列，用于存放等待signal的任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 1173984872572414699L;</span><br><span class="line">        /** First node of condition queue. */</span><br><span class="line">        private transient Node firstWaiter;</span><br><span class="line">        /** Last node of condition queue. */</span><br><span class="line">        private transient Node lastWaiter;</span><br><span class="line">        </span><br><span class="line">**</span><br><span class="line">         * Adds a new waiter to wait queue.</span><br><span class="line">         * @return its new wait node</span><br><span class="line">         */</span><br><span class="line">        private Node addConditionWaiter() &#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            // If lastWaiter is cancelled, clean out.</span><br><span class="line">            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            if (t == null)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            else</span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而AbstractQueuedSynchronizer中也维护了一个队列，就是获取当前资源的等待队列，当资源释放掉之后，会依次从队列中恢复线程，直至为空。每个线程会在这俩个队列中来回切换，但同一时刻仅存在于一个队列中。<br><img src="http://jacobs.wanhb.cn/images/reentrantLock.jpg" alt="ReentrantLock流程"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程1-&gt;AQS: ReentrantLock.lock（加入AQS队列，获取资源）</span><br><span class="line">线程1-&gt;AQS: condition.await()（移除队列，释放资源）</span><br><span class="line">AQS-&gt;condition队列: 线程1加入condition等待队列</span><br><span class="line">线程2-&gt;AQS: 线程2加入AQS队列并获取资源</span><br><span class="line">线程2-&gt;AQS: condition2.await()（移除AQS队列，释放资源）</span><br><span class="line">线程2-&gt;线程1: condition.signal()（线程2调用signal唤醒线程1）</span><br><span class="line">线程1-&gt;AQS: ReentrantLock.lock(重新加入AQS队列，获取资源)</span><br></pre></td></tr></table></figure></p>
<p>###总结<br>还是得深入源码去看问题，不能只关注业务，否则会成为彻头彻尾的搬砖工，不仅要会用轮子，还要会造轮子。最后分享一片陈浩写的技术人员的职业生涯文章，共勉。<a href="http://coolshell.cn/articles/17583.html" target="_blank" rel="noopener">技术人员的发展之路</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-19T03:24:31.000Z">2017-01-19</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5 分钟 读完 (大约 678 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/19/记一次失败的debug经历/">记一次失败的debug经历</a>
            
        </h1>
        <div class="content">
            <p>昨天使用spring aop的事务注解出现了业务中主动抛出异常却无法回滚脏数据的情形，然后崩溃的debug了一天，最后猛然发现不能通过this去掉加了增强的方法否则将拿不到代理对象。归根结底还是自己不甚理解事务实现的其中原理，才导致了bug的出现而不自知。</p>
<h3 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h3><p>如果对java如何实现底层的事务机制不太熟悉的话可以看看<a href="http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html" target="_blank" rel="noopener">java事务处理系列文章</a> 自己手动实现事务处理。</p>
<p>来看看我调用事务的错误示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">class DemoService&#123;</span><br><span class="line"></span><br><span class="line">   public List&lt;ExpressExportRow&gt; notExpressedRecord() &#123;</span><br><span class="line">    ...</span><br><span class="line">    changeOrderStatusToExpressing();</span><br><span class="line">    ...</span><br><span class="line">    return expressExportRowList;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  @Transactional(value = &quot;apolloTransactionManager&quot;,rollbackFor = Exception.class)</span><br><span class="line">  public boolean changeOrderStatusToExpressing(Long orderId, Long orderGroupId) &#123;</span><br><span class="line">    boolean isSuccess = updateExpressRecordStatus(orderId, orderGroupId,</span><br><span class="line">        OrderStatus.EXPRESSING.getValue());</span><br><span class="line">    if (isSuccess) &#123;</span><br><span class="line">      isSuccess = apolloService.updateOrderStatus(orderId, orderGroupId,</span><br><span class="line">          OrderStatus.EXPRESSING.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isSuccess) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;更改订单状态失败,订单号为: &quot; + orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return isSuccess;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>首先DemoService通过@Component注解在容器加载的时候是确实注入进去了， 由于AOP 结合了IOC 的一部分功能（ProxyFactoryBean中实现）也就是在容器启动的过程中跟着在Demoservice封装成了aop代理对象保存在容器中。上面的代码错在直接在service 里面通过this引用去调增强的方法，结果导致方法不会应用相应的增强处理。来看看aop的处理流程图<br><img src="http://jacobs.wanhb.cn/images/aop1.jpg" alt="aop事务处理流程"></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul>
<li>清楚了导出bug的原因和spring事务的基本原理之后，相应的解决办法就很简单，即我们只需要确保我们拿到的demoservice实例是通过容器注入进来的即可，于是可以以下解法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">class Resource&#123;</span><br><span class="line">@Resource</span><br><span class="line">  DemoServcie demoService;</span><br><span class="line">  </span><br><span class="line">  public changeStatus()&#123;</span><br><span class="line">    demoService.changeOrderStatusToExpressing(...);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过@Resource注入进来的demoService必然式容器中的已经加载配置好的代理对象。这样就能成功应用事务增强。</p>
<ul>
<li>或者也可以通过后置器BeanPostProcessor将自身注入进来，即在自身的service里完成调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component  </span><br><span class="line">public class DemoService implements BeanPostProcessor &#123;  </span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;  </span><br><span class="line">        return bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;  </span><br><span class="line">        if(bean instanceof BeanSelfAware) &#123; </span><br><span class="line">            ((BeanSelfAware) bean).setSelf(bean);</span><br><span class="line">        &#125;  </span><br><span class="line">        return bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是这样会出现循环依赖问题。所以第一种方法最为合适。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这次的低级bug再一次发现自己对源码不够深入，虽然前前后后看过了不少spring源码，但是也没有立即发现bug的存在，各方面理解还有待提高。继续努力吧</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2016-11-30T17:23:15.000Z">2016-12-01</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分钟 读完 (大约 1727 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2016/12/01/python-爬取新浪微博/">python 爬取新浪微博</a>
            
        </h1>
        <div class="content">
            <p>最近因为课设的要求，开始了对新浪微博数据的爬取研究，看了不少博客文章，也试了不少方法，原理无非就是模拟登录，但是感觉目前可用的方法太过分散，而且自从微博改版之后，很多以前适用的方法都基本没有用处了。这里总结一下几种可用的方法以及自己研究之后稳定可用的方法(所有的方法都是基于python2.7)：</p>
<hr>
<p>###1、绕过.com域名</p>
<p>如果没有爬取主站的刚需，只是对微博相关的数据感兴趣，可以尝试爬取微博cn域名下的内容(即<a href="http://weibo.cn)，亲测可用...最简单的办法就是先预先登录一下然后获取返回的cookie，贴入代码中作为请求的headers即可。" target="_blank" rel="noopener">http://weibo.cn)，亲测可用...最简单的办法就是先预先登录一下然后获取返回的cookie，贴入代码中作为请求的headers即可。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_header=&#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.86 Safari/537.36&quot;,</span><br><span class="line">        &quot;Cookie&quot;:&quot;_T_WM=03e77f532a8c1a437da863b36a62207d; SUB=_2A256KfecDeRxGeVP61MX9yzKyT-IHXVZ1ZnUrDV6PUNbvtANLRTVkW1LHesQJOUc8nbbLnoALvjmulMBSwDnAw..; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9WhPUuFTXg4zll8rx_8Ap-XA5JpX5KMhUgL.Foepeh2cS0zceoet; SUHB=0cSXC9tcKk2RM7; SSOLoginState=1462601676; gsid_CTandWM=4uTtCpOz5hhWcws1tVSIdd0SYa3&quot;    &#125;</span><br><span class="line"> request = urllib2.Request(url=url, headers=self._header)</span><br><span class="line"> response = urllib2.urlopen(request)</span><br><span class="line"> html = response.read()</span><br></pre></td></tr></table></figure>
<p>接下来对爬取下来的html就可以通过xpath,或者bs来完成数据提取了。</p>
<hr>
<p>###2、使用urllib模拟登录微博.com主站</p>
<p>这个过程比较麻烦，前人有了很多铺垫做相应的改动直接拿来用就好啦，以下代码亲测可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">-*- coding: utf-8 -*-import urllib2</span><br><span class="line">import re</span><br><span class="line">import rsa</span><br><span class="line">import cookielib  #从前的cookielibimport base64</span><br><span class="line">import json</span><br><span class="line">import urllib</span><br><span class="line">import binascii</span><br><span class="line">from lxml import etree</span><br><span class="line">import json</span><br><span class="line"> 用于模拟登陆新浪微博class launcher():</span><br><span class="line"> </span><br><span class="line">    cookieContainer=None    _headers=&#123;</span><br><span class="line">            &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36&quot;        &#125;</span><br><span class="line">    def __init__(self,username, password):</span><br><span class="line">        self.password = password</span><br><span class="line">        self.username = username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def get_prelogin_args(self):</span><br><span class="line">        json_pattern = re.compile(&apos;\((.*)\)&apos;)</span><br><span class="line">        url = &apos;http://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=&amp;&apos; + self.get_encrypted_name() + &apos;&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.18)&apos;        try:</span><br><span class="line">            request = urllib2.Request(url)</span><br><span class="line">            response = urllib2.urlopen(request)</span><br><span class="line">            raw_data = response.read().decode(&apos;utf-8&apos;)</span><br><span class="line">            print &quot;get_prelogin_args&quot;+raw_data;</span><br><span class="line">            json_data = json_pattern.search(raw_data).group(1)</span><br><span class="line">            data = json.loads(json_data)</span><br><span class="line">            return data</span><br><span class="line">        except urllib2.HTTPError as e:</span><br><span class="line">            print(&quot;%d&quot;%e.code)</span><br><span class="line">            return None    def get_encrypted_pw(self,data):</span><br><span class="line">        rsa_e = 65537 #0x10001        pw_string = str(data[&apos;servertime&apos;]) + &apos;\t&apos; + str(data[&apos;nonce&apos;]) + &apos;\n&apos; + str(self.password)</span><br><span class="line">        key = rsa.PublicKey(int(data[&apos;pubkey&apos;],16),rsa_e)</span><br><span class="line">        pw_encypted = rsa.encrypt(pw_string.encode(&apos;utf-8&apos;), key)</span><br><span class="line">        self.password = &apos;&apos;   #清空password        passwd = binascii.b2a_hex(pw_encypted)</span><br><span class="line">        print(passwd)</span><br><span class="line">        return passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def get_encrypted_name(self):</span><br><span class="line">        username_urllike   = urllib.quote(self.username)</span><br><span class="line">        byteStr=bytes(username_urllike)</span><br><span class="line">        byteStrEncod=byteStr.encode(encoding=&quot;utf-8&quot;)</span><br><span class="line">        username_encrypted = base64.b64encode(byteStrEncod)</span><br><span class="line">        return username_encrypted.decode(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def enableCookies(self):</span><br><span class="line">            #建立一个cookies 容器            self.cookieContainer = cookielib.MozillaCookieJar(&quot;/Users/lichao/desktop/weibo/cookie/cookie.txt&quot;);</span><br><span class="line">            # ckjar=cookielib.MozillaCookieJar(&quot;/Users/Apple/Desktop/cookie.txt&quot;)            #将一个cookies容器和一个HTTP的cookie的处理器绑定            cookie_support = urllib2.HTTPCookieProcessor(self.cookieContainer)</span><br><span class="line">            #创建一个opener,设置一个handler用于处理http的url打开            opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler)</span><br><span class="line">            #安装opener，此后调用urlopen()时会使用安装过的opener对象            # proxy_handler = urllib2.ProxyHandler(&#123;&quot;http&quot;: &apos;http://localhost:5000&apos;&#125;)            # opener=urllib2.build_opener(proxy_handler)            urllib2.install_opener(opener)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def build_post_data(self,raw):</span><br><span class="line">        post_data = &#123;</span><br><span class="line">            &quot;entry&quot;:&quot;weibo&quot;,</span><br><span class="line">            &quot;gateway&quot;:&quot;1&quot;,</span><br><span class="line">            &quot;from&quot;:&quot;&quot;,</span><br><span class="line">            &quot;savestate&quot;:&quot;7&quot;,</span><br><span class="line">            &quot;useticket&quot;:&quot;1&quot;,</span><br><span class="line">            &quot;pagerefer&quot;:&quot;Sina Visitor System&quot;,</span><br><span class="line">            &quot;vsnf&quot;:&quot;1&quot;,</span><br><span class="line">            &quot;su&quot;:self.get_encrypted_name(),</span><br><span class="line">            &quot;service&quot;:&quot;miniblog&quot;,</span><br><span class="line">            &quot;servertime&quot;:raw[&apos;servertime&apos;],</span><br><span class="line">            &quot;nonce&quot;:raw[&apos;nonce&apos;],</span><br><span class="line">            &quot;pwencode&quot;:&quot;rsa2&quot;,</span><br><span class="line">            &quot;rsakv&quot;:raw[&apos;rsakv&apos;],</span><br><span class="line">            &quot;sp&quot;:self.get_encrypted_pw(raw),</span><br><span class="line">            &quot;sr&quot;:&quot;1280*800&quot;,</span><br><span class="line">            &quot;encoding&quot;:&quot;UTF-8&quot;,</span><br><span class="line">            &quot;prelt&quot;:&quot;77&quot;,</span><br><span class="line">            &quot;url&quot;:&quot;http://weibo.com/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack&quot;,</span><br><span class="line">            &quot;returntype&quot;:&quot;META&quot;        &#125;</span><br><span class="line">        data = urllib.urlencode(post_data).encode(&apos;utf-8&apos;)</span><br><span class="line">        return data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def login(self):</span><br><span class="line">        url = &apos;新浪通行证&apos;        self.enableCookies()</span><br><span class="line">        data = self.get_prelogin_args()</span><br><span class="line">        post_data = self.build_post_data(data)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36&quot;        &#125;</span><br><span class="line">        try:</span><br><span class="line">            request = urllib2.Request(url=url,data=post_data,headers=headers)</span><br><span class="line">            response = urllib2.urlopen(request)</span><br><span class="line">            html = response.read().decode(&apos;GBK&apos;)</span><br><span class="line">            #print(html)        except urllib2.HTTPError as e:</span><br><span class="line">            print(e.code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p = re.compile(&apos;location\.replace\(\&apos;(.*?)\&apos;\)&apos;)</span><br><span class="line">        p2 = re.compile(r&apos;&quot;userdomain&quot;:&quot;(.*?)&quot;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            login_url = p.search(html).group(1)</span><br><span class="line">            print(login_url)</span><br><span class="line">            request = urllib2.Request(login_url)</span><br><span class="line">            response = urllib2.urlopen(request)</span><br><span class="line">            page = response.read().decode(&apos;utf-8&apos;)</span><br><span class="line">            print(page)</span><br><span class="line">            login_url = &apos;http://weibo.com/&apos; + p2.search(page).group(1)</span><br><span class="line">            request = urllib2.Request(login_url)</span><br><span class="line">            response = urllib2.urlopen(request)</span><br><span class="line">            final = response.read().decode(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            print(&quot;Login success!&quot;)</span><br><span class="line">            self.cookieContainer.save(ignore_discard=True, ignore_expires=True)</span><br><span class="line">        except Exception, e:</span><br><span class="line">            print(&apos;Login error!&apos;)</span><br><span class="line">            print e</span><br><span class="line">            return 0</span><br></pre></td></tr></table></figure>
<p>###3、使用selenium实现模拟登录</p>
<ul>
<li>selenium +phantomjs</li>
</ul>
<p>第二种方法有一个问题，因为目前新版的微博页面的渲染方式采用的是分片渲染的，这就导致我们通过第二种静态方式爬取到的页面并不是最终的页面，而是内容嵌在 js里的中间页面，这肯定不是我们想看到的结果。于是，考虑模拟浏览器渲染页面的方式获取到最终的呈现页面。selenium这个工具正好完美的解决了我们的问题，它可以模拟浏览器的行为，并且我们拿到的source可以向jquery操作dom对象那样查找定位元素，非常方便，实现的核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from selenium import webdriver</span><br><span class="line">import urllib2</span><br><span class="line">import selenium.webdriver.support.ui as ui</span><br><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding( &quot;utf-8&quot; )</span><br><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line">Chrome PhantomJS#driver = webdriver.PhantomJS(&quot;/Users/test/documents/phantomjs/bin/phantomjs&quot;)</span><br><span class="line">driver.get(&apos;http://weibo.com/&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    print &quot;登录开始&quot;</span><br><span class="line">    username = driver.find_element_by_xpath(&apos;//input[@name=&quot;username&quot;]&apos;)</span><br><span class="line">    password = driver.find_element_by_xpath(&apos;//input[@name=&quot;password&quot;]&apos;)</span><br><span class="line">    sbtn = driver.find_element_by_xpath(&apos;//a[@action-type=&quot;btn_submit&quot;]&apos;)</span><br><span class="line">    username.send_keys(&apos;&apos;) #send username       </span><br><span class="line">    password.send_keys(&apos;&apos;) #send password    sbtn.click()  </span><br><span class="line">    # 提交表单    </span><br><span class="line">    time.sleep(3)  # 等待页面加载   </span><br><span class="line">    # get the session cookie    </span><br><span class="line">    cookie = &#123;item[&quot;name&quot;] + &quot;:&quot; + item[&quot;value&quot;] for item in driver.get_cookies()&#125;    cookie=driver.get_cookies()</span><br><span class="line">    for item in driver.get_cookies():    cookieItem=&#123;&quot;name&quot;:item[&quot;name&quot;],&quot;value&quot;:item[&quot;value&quot;],&quot;domain&quot;:item[&quot;domain&quot;],&quot;httponly&quot;:item[&quot;httponly&quot;],&quot;path&quot;:item[&quot;path&quot;],&quot;secure&quot;:item[&quot;secure&quot;]&#125;    cookie.append(cookieItem)    cookie_file= open(&quot;/Users/test/desktop/weibo/cookie/cookie.txt&quot;,&apos;w&apos;)    cookie_file.write(str(cookie))    print str(str(cookie))</span><br><span class="line">except urllib2.HTTPError as e:</span><br><span class="line">    print e</span><br><span class="line">    print &quot;登录失败&quot;print &quot;开始爬取谣言大厅&quot;driver.get(&quot;http://service.account.weibo.com/show?rid=K1CaN7gJl8q8f&quot;)</span><br><span class="line">page = driver.page_source</span><br><span class="line">print page</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>
<p>我们将登录之后获取的cookie以键值对的形式存入文本文件中，方便下次直接load而不需要重复登录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def loadCookie(self):</span><br><span class="line">self._driver.get(&quot;http://www.sina.com.cn&quot;)</span><br><span class="line">    cookie_file=open(&quot;/Users/test/desktop/weibo/cookie/cookie.txt&quot;,&apos;r&apos;)</span><br><span class="line">    cookieStr=cookie_file.read();</span><br><span class="line">print &quot;cookie is: &quot;+cookieStr</span><br><span class="line">    cookieList=list(eval(cookieStr))</span><br><span class="line">for item in cookieList:</span><br><span class="line">cookieDic= type(eval(item))</span><br><span class="line">        self._driver.add_cookie(item)</span><br></pre></td></tr></table></figure>
<ul>
<li>selenium +chromedirver</li>
</ul>
<p>使用phantomjs存在一个问题，登录过程老是失败，因为验证码无法识别获取导致登录经常失败，这里我们使用chromedirver这工具结合selenium实现开挂级别的python数据爬取，模拟登录万无一失，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print &quot;登录开始&quot;</span><br><span class="line">username = driver.find_element_by_xpath(&apos;//input[@name=&quot;username&quot;]&apos;)</span><br><span class="line">password = driver.find_element_by_xpath(&apos;//input[@name=&quot;password&quot;]&apos;)</span><br><span class="line">sbtn = driver.find_element_by_xpath(&apos;//a[@action-type=&quot;btn_submit&quot;]&apos;)</span><br><span class="line">veryfiCode=driver.find_element_by_xpath(&apos;//input[@name=&quot;verifycode&quot;]&apos;)</span><br></pre></td></tr></table></figure>
<p> 程序启动时会自动开启一个chrome窗口，只不过这个浏览器的行为我们可以通过程序控制，这样是不是方便多了！我们在username这一行打一个断点，然后程序执行到这一步，在浏览器中输入相应的用户名，密码，验证码，然后在pycharm中点击继续，登录成功！真实浏览器结合程序，真是开挂级别的爬取微博啊…</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2016-10-08T16:24:02.000Z">2016-10-09</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    8 分钟 读完 (大约 1162 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2016/10/09/手动封装HbaseTemplate-mapper类/">手动封装HbaseTemplate mapper类</a>
            
        </h1>
        <div class="content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近因为业务关系，用到了Hbase，因为用的是Spring boot框架 ，所以自然而然就用到了spring封装的HbaseTemplate工具类。然而HbaseTemplate封装的代码实在比较糟糕，出了一些基本的CRUD操作之外并没有给我们提供太多便利之处。先来看看痛处：</p>
<h3 id="痛处一及改进"><a href="#痛处一及改进" class="headerlink" title="痛处一及改进"></a>痛处一及改进</h3><ul>
<li>我们先来看看HabaseTemplate最基本的查询操作(以下只是demo演示)：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class UserInfo&#123;</span><br><span class="line"> string name;</span><br><span class="line"> string password;</span><br><span class="line">&#125;</span><br><span class="line">public void putUserInfo(UserInfo userInfo) &#123;</span><br><span class="line">   hBaseTemplate.execute(TABLE_NAME, (table) -&gt; &#123;</span><br><span class="line">     //根据rowKey定义一个put对象，可用作插入和更新</span><br><span class="line">     Put put = new Put(Bytes.toBytes(rowKey));</span><br><span class="line">    //name是否为空</span><br><span class="line">     if(userInfo.name!=null)&#123;</span><br><span class="line">     put.addColumn(COLUMN_FAMILY_NAME.getBytes(), Bytes.toBytes(COLUMN_RAW_DATA)，Bytes.toBytes(userInfo.name));</span><br><span class="line">     &#125;</span><br><span class="line">     //password是否为空</span><br><span class="line">     if(userInfo.password!=null)&#123;</span><br><span class="line">     put.addColumn(COLUMN_FAMILY_NAME.getBytes(), Bytes.toBytes(COLUMN_RAW_DATA)，Bytes.toBytes(userInfo.password));</span><br><span class="line">     &#125;</span><br><span class="line">     table.put(put);</span><br><span class="line">     return true;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>相信大家也看出来了，如果待插入的对象有很多字段呢？还要逐个写if语句来判读非空么？这明显使得代码非常地不简洁。于是，个人封装了一个插入更新模版类（其实只是简单的对Put对象的一个扩展）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//继承并扩展Put对象</span><br><span class="line">public class PutExtension extends Put &#123;</span><br><span class="line"></span><br><span class="line">  String columnFamilyName = &quot;demo&quot;;</span><br><span class="line"></span><br><span class="line">  public PutExtension(String columnFamilyName, byte[] row) &#123;</span><br><span class="line">    super(row);</span><br><span class="line">    this.columnFamilyName = columnFamilyName;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public PutExtension build(String paramName, Object param) throws IOException &#123;</span><br><span class="line">    if (param != null) &#123;</span><br><span class="line">      this.addColumn(columnFamilyName.getBytes(), paramName.getBytes(),</span><br><span class="line">          Bytes.toBytes(param.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装之后，之前累赘的查询操作可以变得如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//然后操作如下</span><br><span class="line">hBaseTemplate.execute(TABLE_NAME, (table) -&gt; &#123;</span><br><span class="line">      PutExtension putExtension = new PutExtension(familyName, rowKey.getBytes());</span><br><span class="line">      putExtension.build(&quot;name&quot;,userInfo.name)</span><br><span class="line">          .build(&quot;password&quot;, userInfo.password);</span><br><span class="line">      table.put(putExtension);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>其实这也就是一个简单的封装，只不过把冗余的逻辑判断给丢出去了而已。</p>
<h3 id="痛处二及改进"><a href="#痛处二及改进" class="headerlink" title="痛处二及改进"></a>痛处二及改进</h3><ul>
<li>在HbaseTemplate中，根据rowKey查询出来的原始数据是字节数组，我们要将字节数组转化成业务逻辑中希望的java bean需要做很多重复的判断匹配逻辑，以下是没改进前的代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public UserInfo getUserInfo() &#123;</span><br><span class="line">    return (UserInfo) hBaseTemplate.get(TABLE_NAME, rowKey, familyName,(result, i) -&gt;&#123;</span><br><span class="line">     UserInfo userInfo=new UserInfo()</span><br><span class="line">     //重复逻辑一</span><br><span class="line">bytes[] nameBytes=result.getValue(familyName.getBytes(), &quot;name&quot;.getBytes()));</span><br><span class="line">if(nameBytes!=null)&#123;</span><br><span class="line">  userInfo.setName(Bytes.toString(nameBytes));</span><br><span class="line">&#125;</span><br><span class="line">//重复逻辑二</span><br><span class="line">bytes[] passwordBytes=result.getValue(familyName.getBytes(), &quot;password&quot;.getBytes()));</span><br><span class="line">if(passwordBytes!=null)&#123;</span><br><span class="line">  userInfo.setPassword(Bytes.toString(passwordBytes));</span><br><span class="line">&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这样做的缺点是一旦java bean的字段一多，重复的非空判断逻辑也会增多，从而使得代码变得十分累赘且不可维护。于是我参考Spring JDBC的RowMapper的封装，利用了Spring框架自带的反射工具beanUtils和beanWrapper，自己实现了如下封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class HBaseResultBuilder&lt;T&gt; &#123;</span><br><span class="line">  private Class&lt;T&gt; mappedClass;</span><br><span class="line">  private Map&lt;String, PropertyDescriptor&gt; mappedFields;</span><br><span class="line">  private Set&lt;String&gt; mappedProperties;</span><br><span class="line">  HashSet populatedProperties;</span><br><span class="line">  private BeanWrapper beanWrapper;</span><br><span class="line">  private Result result;</span><br><span class="line">  private String columnFamilyName;</span><br><span class="line">  private T t;</span><br><span class="line">  //接受一些列参数并实例化要返回的结果对象</span><br><span class="line">  public HBaseResultBuilder(String columnFamilyName, Result result, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">    this.columnFamilyName = columnFamilyName;</span><br><span class="line">    this.result = result;</span><br><span class="line">    this.mappedClass = clazz;</span><br><span class="line">    mappedFields = new HashMap&lt;&gt;();</span><br><span class="line">    mappedProperties = new HashSet&lt;&gt;();</span><br><span class="line">    populatedProperties = new HashSet&lt;&gt;();</span><br><span class="line">    this.t = BeanUtils.instantiate(clazz);</span><br><span class="line">    PropertyDescriptor[] pds = BeanUtils.getPropertyDescriptors(mappedClass);</span><br><span class="line">    PropertyDescriptor[] var3 = pds;</span><br><span class="line">    int var4 = pds.length;</span><br><span class="line">    for (int var5 = 0; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">      PropertyDescriptor pd = var3[var5];</span><br><span class="line">      if (pd.getWriteMethod() != null) &#123;</span><br><span class="line">        this.mappedFields.put(this.lowerCaseName(pd.getName()), pd);</span><br><span class="line">        String underscoredName = this.underscoreName(pd.getName());</span><br><span class="line">        if (!this.lowerCaseName(pd.getName()).equals(underscoredName)) &#123;</span><br><span class="line">          this.mappedFields.put(underscoredName, pd);</span><br><span class="line">        &#125;</span><br><span class="line">        this.mappedProperties.add(pd.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String underscoreName(String name) &#123;</span><br><span class="line">    if (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">      return &quot;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      StringBuilder result = new StringBuilder();</span><br><span class="line">      result.append(this.lowerCaseName(name.substring(0, 1)));</span><br><span class="line"></span><br><span class="line">      for (int i = 1; i &lt; name.length(); ++i) &#123;</span><br><span class="line">        String s = name.substring(i, i + 1);</span><br><span class="line">        String slc = this.lowerCaseName(s);</span><br><span class="line">        if (!s.equals(slc)) &#123;</span><br><span class="line">          result.append(&quot;_&quot;).append(slc);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          result.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String lowerCaseName(String name) &#123;</span><br><span class="line">    return name.toLowerCase(Locale.US);</span><br><span class="line">  &#125;</span><br><span class="line">  //使用时根据要解析的字段频繁调用此方法即可，仿造java8 流式操作</span><br><span class="line">  public HBaseResultBuilder build(String columnName) &#123;</span><br><span class="line">    byte[] value = result.getValue(columnFamilyName.getBytes(), columnName.getBytes());</span><br><span class="line">    if (value == null || value.length == 0) &#123;</span><br><span class="line">      return this;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      String field = this.lowerCaseName(columnName.replaceAll(&quot; &quot;, &quot;&quot;));</span><br><span class="line">      PropertyDescriptor pd = this.mappedFields.get(field);</span><br><span class="line">      if (pd == null) &#123;</span><br><span class="line">        log.error(&quot;HBaseResultBuilder error: can not find property: &quot; + field);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        beanWrapper.setPropertyValue(pd.getName(), Bytes.toString(value));</span><br><span class="line">        populatedProperties.add(pd.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //伪造Java8的即视感，“流最后的终端操作“。</span><br><span class="line">  public T fetch() &#123;</span><br><span class="line">    //只要有一个属性被解析出来就返回结果对象，毕竟hbase存的是稀疏数据，不一定全量</span><br><span class="line">    if (CollectionUtils.isNotEmpty(populatedProperties)) &#123;</span><br><span class="line">      return this.t;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过利用反射的基本原理，我们可以通过结果数据构造出我们需要的java bean。最后我们的调用过程可以简化成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public UserInfo getUserInfo() &#123;</span><br><span class="line">    return (UserInfo) hBaseTemplate.get(TABLE_NAME, rowKey,    familyName,</span><br><span class="line">        (result, i) -&gt; new HBaseResultBuilder&lt;&gt;(familyName, result, UserInfo.class).build(&quot;name&quot;).build(&quot;password&quot;).fetch());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>成功！！！是不是代码整洁多了，其实也就是将一些复杂的逻辑给抽出去了，正好最近看了Java8实战，从而萌生的一点小想法。</p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous">
            <a class="is-flex-grow has-text-black-ter" href="/page/2/">上一页</a>
        </div>
        <div class="pagination-next is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/page/4/">下一页</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link has-text-black-ter" href="/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/2/">2</a></li>
            
            <li><a class="pagination-link is-current" href="/page/3/">3</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="" src="/images/profile.jpg" alt="CHAO LI">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        CHAO LI
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Big Data
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Beijing</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            30
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            0
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            39
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">
                关注我</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Github" href="https://github.com/ppoffice/hexo-theme-icarus">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Facebook" href="https://facebook.com">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Twitter" href="https://twitter.com">
                
                <i class="fab fa-twitter"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Dribbble" href="https://dribbble.com">
                
                <i class="fab fa-dribbble"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://github.com/lichaojacobs" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">Github</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">github.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.zhihu.com/people/chao-li-11" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">知乎</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.zhihu.com</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://weibo.com/3101672623/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">微博</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">weibo.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/BigData/" style="font-size: 10px;">BigData</a> <a href="/tags/Crawler/" style="font-size: 10px;">Crawler</a> <a href="/tags/HBase/" style="font-size: 10px;">HBase</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Hbase/" style="font-size: 12.5px;">Hbase</a> <a href="/tags/InnoDB/" style="font-size: 10px;">InnoDB</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kylin/" style="font-size: 10px;">Kylin</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/ReentrantLock/" style="font-size: 10px;">ReentrantLock</a> <a href="/tags/Spark/" style="font-size: 17.5px;">Spark</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/aop/" style="font-size: 12.5px;">aop</a> <a href="/tags/data/" style="font-size: 10px;">data</a> <a href="/tags/infrastructure/" style="font-size: 12.5px;">infrastructure</a> <a href="/tags/ioc/" style="font-size: 12.5px;">ioc</a> <a href="/tags/java8/" style="font-size: 10px;">java8</a> <a href="/tags/kylin/" style="font-size: 12.5px;">kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 12.5px;">kylin - Java - 源码</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/paper/" style="font-size: 10px;">paper</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/spark/" style="font-size: 10px;">spark</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/sqlGenerator/" style="font-size: 10px;">sqlGenerator</a> <a href="/tags/superset/" style="font-size: 10px;">superset</a> <a href="/tags/事务处理/" style="font-size: 10px;">事务处理</a> <a href="/tags/二次开发/" style="font-size: 10px;">二次开发</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/大数据/" style="font-size: 20px;">大数据</a> <a href="/tags/学习/" style="font-size: 17.5px;">学习</a> <a href="/tags/成长/" style="font-size: 17.5px;">成长</a> <a href="/tags/架构/" style="font-size: 17.5px;">架构</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-06T17:42:13.000Z">2020-01-07</time></div>
                    <a href="/2020/01/07/MR任务在Hadoop子系统中状态流转/" class="title has-link-black-ter is-size-6 has-text-weight-normal">MR任务在Hadoop子系统中状态流转</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-04T17:47:46.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/Yarn-Federation源码串读/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Yarn Federation源码串读</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-04T17:38:28.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/Hadoop-Rpc源码分析/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Hadoop Rpc源码分析</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-10T05:08:55.000Z">2019-06-10</time></div>
                    <a href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/" class="title has-link-black-ter is-size-6 has-text-weight-normal">【Spark源码分析】Job提交执行过程详解</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-02T05:31:16.000Z">2019-06-02</time></div>
                    <a href="/2019/06/02/【Spark源码分析】Broadcast/" class="title has-link-black-ter is-size-6 has-text-weight-normal">【Spark源码分析】Broadcast</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/01/">
                <span class="level-start">
                    <span class="level-item">一月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">六月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/05/">
                <span class="level-start">
                    <span class="level-item">五月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/01/">
                <span class="level-start">
                    <span class="level-item">一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/10/">
                <span class="level-start">
                    <span class="level-item">十月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/08/">
                <span class="level-start">
                    <span class="level-item">八月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/04/">
                <span class="level-start">
                    <span class="level-item">四月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/03/">
                <span class="level-start">
                    <span class="level-item">三月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/10/">
                <span class="level-start">
                    <span class="level-item">十月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/09/">
                <span class="level-start">
                    <span class="level-item">九月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/08/">
                <span class="level-start">
                    <span class="level-item">八月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/07/">
                <span class="level-start">
                    <span class="level-item">七月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/06/">
                <span class="level-start">
                    <span class="level-item">六月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/05/">
                <span class="level-start">
                    <span class="level-item">五月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/03/">
                <span class="level-start">
                    <span class="level-item">三月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/02/">
                <span class="level-start">
                    <span class="level-item">二月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/01/">
                <span class="level-start">
                    <span class="level-item">一月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/10/">
                <span class="level-start">
                    <span class="level-item">十月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/BigData/">
                        <span class="tag">BigData</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Crawler/">
                        <span class="tag">Crawler</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/HBase/">
                        <span class="tag">HBase</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Hadoop/">
                        <span class="tag">Hadoop</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Hbase/">
                        <span class="tag">Hbase</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/InnoDB/">
                        <span class="tag">InnoDB</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JVM/">
                        <span class="tag">JVM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Java/">
                        <span class="tag">Java</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Kylin/">
                        <span class="tag">Kylin</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Python/">
                        <span class="tag">Python</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ReentrantLock/">
                        <span class="tag">ReentrantLock</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spark/">
                        <span class="tag">Spark</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring/">
                        <span class="tag">Spring</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Yarn/">
                        <span class="tag">Yarn</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/aop/">
                        <span class="tag">aop</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/data/">
                        <span class="tag">data</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/infrastructure/">
                        <span class="tag">infrastructure</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ioc/">
                        <span class="tag">ioc</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/java8/">
                        <span class="tag">java8</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/kylin/">
                        <span class="tag">kylin</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/kylin-Java-源码/">
                        <span class="tag">kylin - Java - 源码</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/mysql/">
                        <span class="tag">mysql</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/paper/">
                        <span class="tag">paper</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/python/">
                        <span class="tag">python</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/spark/">
                        <span class="tag">spark</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/spring/">
                        <span class="tag">spring</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/sqlGenerator/">
                        <span class="tag">sqlGenerator</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/superset/">
                        <span class="tag">superset</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/事务处理/">
                        <span class="tag">事务处理</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/二次开发/">
                        <span class="tag">二次开发</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/函数式编程/">
                        <span class="tag">函数式编程</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/分布式/">
                        <span class="tag">分布式</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/多线程/">
                        <span class="tag">多线程</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/大数据/">
                        <span class="tag">大数据</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/学习/">
                        <span class="tag">学习</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/成长/">
                        <span class="tag">成长</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/架构/">
                        <span class="tag">架构</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/源码/">
                        <span class="tag">源码</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/读书/">
                        <span class="tag">读书</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-06T17:42:13.000Z">2020-01-07</time></div>
                    <a href="/2020/01/07/MR任务在Hadoop子系统中状态流转/" class="title has-link-black-ter is-size-6 has-text-weight-normal">MR任务在Hadoop子系统中状态流转</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-04T17:47:46.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/Yarn-Federation源码串读/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Yarn Federation源码串读</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-11-04T17:38:28.000Z">2019-11-05</time></div>
                    <a href="/2019/11/05/Hadoop-Rpc源码分析/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Hadoop Rpc源码分析</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-10T05:08:55.000Z">2019-06-10</time></div>
                    <a href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/" class="title has-link-black-ter is-size-6 has-text-weight-normal">【Spark源码分析】Job提交执行过程详解</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-02T05:31:16.000Z">2019-06-02</time></div>
                    <a href="/2019/06/02/【Spark源码分析】Broadcast/" class="title has-link-black-ter is-size-6 has-text-weight-normal">【Spark源码分析】Broadcast</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/01/">
                <span class="level-start">
                    <span class="level-item">一月 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">六月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/05/">
                <span class="level-start">
                    <span class="level-item">五月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/01/">
                <span class="level-start">
                    <span class="level-item">一月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/10/">
                <span class="level-start">
                    <span class="level-item">十月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/08/">
                <span class="level-start">
                    <span class="level-item">八月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/04/">
                <span class="level-start">
                    <span class="level-item">四月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/03/">
                <span class="level-start">
                    <span class="level-item">三月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/10/">
                <span class="level-start">
                    <span class="level-item">十月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/09/">
                <span class="level-start">
                    <span class="level-item">九月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/08/">
                <span class="level-start">
                    <span class="level-item">八月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/07/">
                <span class="level-start">
                    <span class="level-item">七月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/06/">
                <span class="level-start">
                    <span class="level-item">六月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/05/">
                <span class="level-start">
                    <span class="level-item">五月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/03/">
                <span class="level-start">
                    <span class="level-item">三月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/02/">
                <span class="level-start">
                    <span class="level-item">二月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/01/">
                <span class="level-start">
                    <span class="level-item">一月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/10/">
                <span class="level-start">
                    <span class="level-item">十月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/BigData/">
                        <span class="tag">BigData</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Crawler/">
                        <span class="tag">Crawler</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/HBase/">
                        <span class="tag">HBase</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Hadoop/">
                        <span class="tag">Hadoop</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Hbase/">
                        <span class="tag">Hbase</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/InnoDB/">
                        <span class="tag">InnoDB</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/JVM/">
                        <span class="tag">JVM</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Java/">
                        <span class="tag">Java</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Kylin/">
                        <span class="tag">Kylin</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Python/">
                        <span class="tag">Python</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ReentrantLock/">
                        <span class="tag">ReentrantLock</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spark/">
                        <span class="tag">Spark</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Spring/">
                        <span class="tag">Spring</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Yarn/">
                        <span class="tag">Yarn</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/aop/">
                        <span class="tag">aop</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/data/">
                        <span class="tag">data</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/infrastructure/">
                        <span class="tag">infrastructure</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ioc/">
                        <span class="tag">ioc</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/java8/">
                        <span class="tag">java8</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/kylin/">
                        <span class="tag">kylin</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/kylin-Java-源码/">
                        <span class="tag">kylin - Java - 源码</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/mysql/">
                        <span class="tag">mysql</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/paper/">
                        <span class="tag">paper</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/python/">
                        <span class="tag">python</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/spark/">
                        <span class="tag">spark</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/spring/">
                        <span class="tag">spring</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/sqlGenerator/">
                        <span class="tag">sqlGenerator</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/superset/">
                        <span class="tag">superset</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/事务处理/">
                        <span class="tag">事务处理</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/二次开发/">
                        <span class="tag">二次开发</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/函数式编程/">
                        <span class="tag">函数式编程</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/分布式/">
                        <span class="tag">分布式</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/多线程/">
                        <span class="tag">多线程</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/大数据/">
                        <span class="tag">大数据</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/学习/">
                        <span class="tag">学习</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/成长/">
                        <span class="tag">成长</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/架构/">
                        <span class="tag">架构</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/源码/">
                        <span class="tag">源码</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/读书/">
                        <span class="tag">读书</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/hadoop_logo.jpg" alt="CHAO LI&#39;s Blog" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 John Doe&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                <br>
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'http://yoursite.com',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>