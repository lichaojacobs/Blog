<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[superset customization]]></title>
      <url>/2017/10/13/superset-customization/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>由于数据组目前重度依赖kylin，然而kylin并没有官方开源的数据可视化工具。所幸kylin提供了丰富的查询API供我们直接传入SQL进行查询，与此同时发现superset有非官方对接kylin的开源插件，虽然两年没有维护了，对代码进行了部分重构也就成功将superset和kylin对接起来了。</p>
</li>
<li><p>通常一个开源框架在使用过程中，总是会有各种各样的针对具体场景的定制化需求，superset自然不例外。于是下面简单记录一下superset定制化的过程中干的一些事情，算是做一个小的总结。</p>
</li>
</ul>
<h3 id="python2升级python3"><a href="#python2升级python3" class="headerlink" title="python2升级python3"></a>python2升级python3</h3><p>虽然python2.7是superset官方推荐的版本，但是由于python2.7默认的Encoding的问题导致使用过程中一旦出现中文就出错。为了避免这种情况，我选择将python2.7升级到python3.5。当然升级还算顺利，碰到的最大的坑就是python2中的MysqlDB模块在python3中已经不维护了，于是修改superset源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#init.py</div><div class="line">#pip install pymysql</div><div class="line"></div><div class="line">import pymysql</div><div class="line">pymysql.install_as_MySQLdb()</div></pre></td></tr></table></figure>
<h3 id="superset-ldap配置"><a href="#superset-ldap配置" class="headerlink" title="superset ldap配置"></a>superset ldap配置</h3><ul>
<li><p>基本上各大开源组件都支持ldap的配置，superset也不例外。ldap的好处就是给企业用户提供统一的账户授权，方便权限管理。</p>
</li>
<li><p>由于google上基本上查不到相关的资料或者都是配置出错了没法解决的提问，这一块踩了不少的坑。然后发现superset其实是直接用的flask-appbuilder里提供的security组件支持ldap的，通过熟悉ldap的原理以及查看flask-appbuilder的官方文档和security组件的源代码最终解决了ldap的配置问题。</p>
</li>
<li><p>先在config.py中引入flask-appbuilder的相关依赖</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#引入引用：</div><div class="line">from flask_appbuilder.security.manager import AUTH_OID,</div><div class="line">AUTH_REMOTE_USER,</div><div class="line">AUTH_DB, AUTH_LDAP,</div><div class="line">AUTH_OAUTH,</div><div class="line">AUTH_OAUTH</div></pre></td></tr></table></figure>
</li>
<li><p>再在config.py AUTH一块的区域中加入如下配置</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//最终配置（这里用到二次验证，即bind给定账户，然后根据权限去搜索输入的用户，拉	取用户的dn，最后用得到的密码和拉取到的dn去bind_user即可）</div><div class="line">#2表示使用ldap</div><div class="line">AUTH_TYPE = 2 </div><div class="line">#自己公司的ldap服务器</div><div class="line">AUTH_LDAP_SERVER = &quot;ldap://ldap.example.com&quot; </div><div class="line">#ldap有两种认证方式，这里用到二次验证，需要配置一个admin账号</div><div class="line">AUTH_LDAP_BIND_USER = &quot;cn=admin,dc=ldap,dc=mobvoi,dc=com&quot;</div><div class="line">#admin账号的密码</div><div class="line">AUTH_LDAP_BIND_PASSWORD = &quot;xxxx&quot;</div><div class="line">AUTH_LDAP_USE_TLS = False</div><div class="line">#在哪个节点查找用户</div><div class="line">AUTH_LDAP_SEARCH = &quot;ou=users,dc=ldap,dc=mobvoi,dc=com&quot;</div><div class="line">#查找用户的字段</div><div class="line">AUTH_LDAP_UID_FIELD = &quot;uid&quot;</div><div class="line">#是否允许superset数据库中没有记录的ldap用户自动注册</div><div class="line">AUTH_USER_REGISTRATION = True</div><div class="line">#注册新用户时默认分配的权限</div><div class="line">AUTH_USER_REGISTRATION_ROLE = &quot;Dashboard Readonly&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="superset-docker化"><a href="#superset-docker化" class="headerlink" title="superset docker化"></a>superset docker化</h3><p>为了减轻运维服务器升级时服务的迁移成本，决定将统一修改的源码托管起来，每一次修改重新发布docker，这样能大大降低运维成本。</p>
<ul>
<li><p>拉取ubuntu镜像，挂载本地磁盘，并进入后台运行模式</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run -it -v /home/:/home/ leemiracle/unbuntu /bin/bash</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在ubuntu中安装python3.5</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://www.python.org/ftp/python/3.5.4/Python-3.5.4rc1.tgz</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>拖下superset、pylin源代码，安装pyklin 与ldap</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git clonet git@github.com:lichaojacobs/superset.git</div><div class="line">git clone git@github.com:lichaojacobs/pykylin.git</div><div class="line">cd pykylin</div><div class="line">pip install -r ./requirements.txt</div><div class="line">  python setup.py install</div><div class="line">  pip install pyldap</div></pre></td></tr></table></figure>
</li>
<li><p>修改flask-appbuilder代码（重写了权限部分逻辑）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">flask-appbuilder/security/manager.py  auth_user_ldap (method)</div><div class="line">try:</div><div class="line">    user_db = self.auth_user_db(username,password)</div><div class="line">    if user_db!=None:</div><div class="line">       return user_db</div><div class="line"> 	except Exception:</div><div class="line">    log.info(&quot;using ldap and first try db_auth failed&quot;)</div></pre></td></tr></table></figure>
</li>
<li><p>修改superset源码（增加status接口，主要是对服务状态进行监测）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">from flask import jsonify</div><div class="line"> class MyIndexView(IndexView):</div><div class="line">   @expose(&apos;/&apos;)</div><div class="line">   def index(self):</div><div class="line">       return redirect(&apos;/superset/welcome&apos;)</div><div class="line">   @expose(&apos;/status&apos;)</div><div class="line">   def status(self):</div><div class="line">       return jsonify(status=&apos;ok&apos;)</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>修改superset config.py，加入缓存配置，ldap配置等</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">加上缓存：</div><div class="line"> CACHE_DEFAULT_TIMEOUT = 7200</div><div class="line"> CACHE_CONFIG = &#123;</div><div class="line">   &apos;CACHE_TYPE&apos;:&apos;redis&apos;,</div><div class="line">   &apos;CACHE_DEFAULT_TIMEOUT&apos;:7200,</div><div class="line">   &apos;CACHE_KEY_PREFIX&apos;:&apos;superset_&apos;,</div><div class="line">   &apos;CACHE_REDIS_HOST&apos;:&apos;xxxxxx.aliyuncs.com&apos;,</div><div class="line">   &apos;CACHE_REDIS_PORT&apos;:6379,</div><div class="line">   &apos;CACHE_REDIS_DB&apos;:&apos;&apos;,</div><div class="line">   &apos;CACHE_REDIS_PASSWORD&apos;:&apos;xxxxx&apos;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>加上GA脚本用于统计页面PV UV</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"> (function(i,s,o,g,r,a,m)&#123;i[&apos;GoogleAnalyticsObject&apos;]=r;i[r]=i[r]||function()&#123;</div><div class="line"> (i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),</div><div class="line"> m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)</div><div class="line"> &#125;)(window,document,&apos;script&apos;,&apos;https://www.google-analytics.com/analytics.js&apos;,&apos;ga&apos;);</div><div class="line"></div><div class="line"> &#123;% if g.user.get_full_name %&#125;</div><div class="line"> ga(&apos;set&apos;, &apos;userId&apos;, &apos;&#123;&#123;g.user.get_full_name()&#125;&#125;&apos;);</div><div class="line"> &#123;% endif %&#125;</div><div class="line"> ga(&apos;create&apos;, &apos;UA-64695573-19&apos;, &apos;auto&apos;);</div><div class="line"> ga(&apos;send&apos;, &apos;pageview&apos;);</div><div class="line"></div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>自编译superset</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd $SUPERSET_HOME/superset/assets</div><div class="line">./js_build.sh</div><div class="line">#由于实际编译过程中出现了各种测试异常，我将npm run test,npm run cover去掉了</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>安装superset</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">apt-get install build-essential libssl-dev libffi-dev python-dev python-pip libsasl2-dev libldap2-dev</div><div class="line">  apt-get install python3.5-dev</div><div class="line">pip install --upgrade setuptools pip</div><div class="line">#直接运行上一步编译好的文件</div><div class="line">python superset/setup.py install</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>打包镜像，重新commit修改，并打上tag</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker commit -m &quot;superset docker init&quot; -a &quot;author&quot; &lt;container id&gt; &lt;docker repository host&gt;/superset:&lt;version&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>运行docker</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run -m 1G --net=host &lt;docker repository host&gt;/superset:&lt;version&gt; superset runserver -p 8088 -t 500</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然目前步子迈得有点小，但好在还在进步。在自己努力下，从之前痛苦的数据架构升级到现在，数据组的基础架构平台也算是稳定的在提供服务了。kylin也在啃了很久的源代码，做了一些优化之后从之前每天要挂三四次，数据主从同步问题每次执行任务都要重现到现在也能平稳运行。路还很长，想往底层钻的深一点，继续加油吧～</p>
]]></content>
      
        
        <tags>
            
            <tag> superset </tag>
            
            <tag> 二次开发 </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lombok builder 泛型擦除]]></title>
      <url>/2017/09/23/lombok-builder-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>众所周知，Java长期以来比较遭业界嫌弃的是太笨重，代码冗余过大。然而依托于Java庞大健全的开源社区，这些缺点正在逐渐改善。Java 8 引进的lambda以及函数式编程的思想让我们的代码越来越简洁。lombok等各大开源神器让我们的冗余代码越来越少。</p>
</li>
<li><p>使用lombok已经很长时间了，一直很好用，然而最近发现使用lombok builder构造泛型的时候会出现泛型擦除的情况，导致得到的对象是Object类型</p>
</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>定义一个待使用builder构造的泛型类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@NoArgsConstructor</div><div class="line">@AllArgsConstructor</div><div class="line">@Builder</div><div class="line">public class PageableResponse&lt;T&gt; &#123;</div><div class="line"></div><div class="line">  List&lt;T&gt; results;</div><div class="line">  @SerializedName(&quot;total_pages&quot;)</div><div class="line">  long totalPages;</div><div class="line">  @SerializedName(&quot;total_elements&quot;)</div><div class="line">  long totalElements;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常情况下，我是可以这样使用的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public PageableResponse&lt;String&gt; getPageableResponse() &#123;</div><div class="line">  return PageableResponse</div><div class="line">      .builder()</div><div class="line">      .results(Lists.newArrayList())</div><div class="line">      .totalElements(0)</div><div class="line">      .totalPages(0)</div><div class="line">      .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而出现类型转换错误，PageableResponse.builder()生成的是PageableResponse.PageableResponseBuilder<code>&lt;Object&gt;</code> 想来也是，我这里调用builder方法时候并没有指定任何类型。</p>
<h3 id="泛型基础知识"><a href="#泛型基础知识" class="headerlink" title="泛型基础知识"></a>泛型基础知识</h3><p>那为什么会得到这样的结果？这里就要回顾一下泛型的知识了，这里我们的场景比较复杂一点，属于泛型类里面的静态泛型方法。这里提一下知识点：</p>
<h5 id="java泛型转换的几个事实："><a href="#java泛型转换的几个事实：" class="headerlink" title="java泛型转换的几个事实："></a>java泛型转换的几个事实：</h5><ul>
<li>虚拟机中没有泛型，只有普通的类和方法</li>
<li>无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，替换为限定类型（无限定的变量用Object）。当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换</li>
<li>所有的类型参数都用它们的限定类型替换 如:Pair<code>&lt;T&gt;</code> 擦除类型之后就变成了Pair<code>&lt;Object&gt;</code></li>
<li>桥方法被合成来保持多态</li>
<li>为保证类型安全性，必要时插入强制类型转换</li>
</ul>
<h5 id="泛型的约束与局限性"><a href="#泛型的约束与局限性" class="headerlink" title="泛型的约束与局限性"></a>泛型的约束与局限性</h5><ul>
<li><p>不能用基本类型实例化类型参数</p>
</li>
<li><p>运行时类型查询只适用于原始类型:</p>
<ul>
<li>if(a instanceof Pair<code>&lt;String&gt;</code>)//ERROR</li>
<li><p>同理getClass方法也总是返回原始类型:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; stringPair=...</div><div class="line">Pair&lt;Employ&gt; employPair=...</div><div class="line">if(stringPair.getClass()==employPair.getClass()) //True</div><div class="line">//两次调用都将返回Pair.class</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不能创建参数化类型数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]//ERROR</div><div class="line">//类型擦除之后，table的类型是Pair[]。可以把它转换为Object[]</div><div class="line">Object[] arr = table</div><div class="line">//数组会记住它的元素类型，如果试图存储其他类型的元素，会抛出ArrayStoreException异常</div><div class="line">//只是不允许创建这些数组，但是声明类型为Pair&lt;String&gt;[]的变量仍是合法的，只是不能用new Pair&lt;String&gt;[10]初始化这个变量</div><div class="line">//可以声明通配类型的数组，然后进行类型转换，导致的结果将是不安全的</div><div class="line">Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</div></pre></td></tr></table></figure>
</li>
<li><p>不能实例化类型变量: 不能new T(….)</p>
<ul>
<li>类型擦除会将T改变成Object，而且，本意肯定不希望调用new Object()</li>
<li><p>可以通过反射调用Class.newInstance方法来构造泛型对象，细节有点复杂</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//不能以下方式调用</div><div class="line">first = T.class.newInstance();//ERROR</div><div class="line">//表达式T.class是不合法的，必须如下方式才可以支配Class对象：</div><div class="line"></div><div class="line">public static&lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)&#123;</div><div class="line">   try &#123; return new Pair&lt;&gt;(cl.newInstance(),cl.newInstance()) &#125;</div><div class="line">   catch (Exception ex) &#123; return null; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</div><div class="line">//注意，Class类本身就是泛型，String.class是一个Class&lt;String&gt;的实例（唯一实例）。因此makePair方法能够判断出pair的类型。</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不能以如下的方式构造泛型数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//类型擦除会让这个方法永远构造Object[2]数组，而要求extends Comparable，这显然会抛出转换异常</div><div class="line">// 此时可以把 extends Comparable去掉，这样能保证强制转换的正确性</div><div class="line">public static &lt;T extends Comparable&gt; T[] minmax(T... a) &#123;</div><div class="line"></div><div class="line">   	Object[] mm = new Object[2];</div><div class="line">   	mm[0] = a[0];</div><div class="line">   	mm[1] = a[1];</div><div class="line"></div><div class="line">   	return (T[]) mm;</div><div class="line"> 	&#125;</div><div class="line"></div><div class="line"> 	或者使用反射，调用Array.newInstance:</div><div class="line"></div><div class="line"> 	public static &lt;T extends Comparable&gt; T[] minmax(T... a) &#123;</div><div class="line"></div><div class="line">   	T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), 2);</div><div class="line">   	...</div><div class="line"> 	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="泛型类里面的泛型方法和静态泛型方法是有区别的："><a href="#泛型类里面的泛型方法和静态泛型方法是有区别的：" class="headerlink" title="泛型类里面的泛型方法和静态泛型方法是有区别的："></a>泛型类里面的泛型方法和静态泛型方法是有区别的：</h5><ul>
<li>泛型类定义的泛型 在整个类中有效 如果被方法使用，当泛型类确定类型之后，泛型方法也就确定类型了</li>
<li>而对于静态泛型方法而言，其泛型的类型是不依赖于泛型类的类型，也就是这两者的类型完全不相干（依据上一条的事实一）</li>
</ul>
<h5 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h5><ul>
<li>考虑一个类和一个子类，如Employee和Manager。Pair<code>&lt;Manager&gt;</code> 却不是Pair<code>&lt;Employee&gt;</code>的子类。事实上，它们的关系如下图所示</li>
</ul>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/generics1.png" alt=""></p>
<ul>
<li>泛型类可以扩展或实现其他泛型类。这一点与普通的类没什么区别。如：ArrayList<code>&lt;T&gt;</code> 类实现List<code>&lt;T&gt;</code>接口，意味着一个ArrayList<code>&lt;Manager&gt;</code> 可以被转换为一个List<code>&lt;Manager&gt;</code>。但是一个ArrayList<code>&lt;Manager&gt;</code> 不是一个ArrayList<code>&lt;Employee&gt;</code> 或者List<code>&lt;Employee&gt;</code>，它们的关系如下图:</li>
</ul>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/generics2.png" alt=""></p>
<h3 id="案例解释"><a href="#案例解释" class="headerlink" title="案例解释"></a>案例解释</h3><ul>
<li>泛型知识作了一番复习之后，我们再回到上面的案例。之所以无法正常的使用builder，是因为静态泛型方法不继承泛型类的类型。下面是案例类生成的代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class PageableResponse&lt;T&gt; &#123;</div><div class="line">  List&lt;T&gt; results;</div><div class="line">  @JSONField(</div><div class="line">    name = &quot;total_pages&quot;</div><div class="line">  )</div><div class="line">  long totalPages;</div><div class="line">  @JSONField(</div><div class="line">    name = &quot;total_elements&quot;</div><div class="line">  )</div><div class="line">  long totalElements;</div><div class="line"></div><div class="line">  //这个T不依赖于PageableResponse&lt;T&gt;的T</div><div class="line">  public static &lt;T&gt; PageableResponse.PageableResponseBuilder&lt;T&gt; builder() &#123;</div><div class="line">    return new PageableResponse.PageableResponseBuilder();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ...</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>而正常的没有泛型的生成代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Address &#123;</div><div class="line">  private String city;</div><div class="line"></div><div class="line">  //不带泛型</div><div class="line">  public static Address.AddressBuilder builder() &#123;</div><div class="line">    return new Address.AddressBuilder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public Address() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @ConstructorProperties(&#123;&quot;city&quot;&#125;)</div><div class="line">  public Address(String city) &#123;</div><div class="line">    this.city = city;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static class AddressBuilder &#123;</div><div class="line">    private String city;</div><div class="line"></div><div class="line">    AddressBuilder() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Address.AddressBuilder city(String city) &#123;</div><div class="line">      this.city = city;</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Address build() &#123;</div><div class="line">      return new Address(this.city);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String toString() &#123;</div><div class="line">      return &quot;Address.AddressBuilder(city=&quot; + this.city + &quot;)&quot;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>所以如果必须要使用泛型且如果这种情况不是太多的话，可以自己实现lombok的builder生成的代码，以案例定义的类为例，改造完的代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@NoArgsConstructor</div><div class="line">@AllArgsConstructor</div><div class="line">public class PageableResponse&lt;T&gt; &#123;</div><div class="line"></div><div class="line">  List&lt;T&gt; results;</div><div class="line">  @SerializedName(&quot;total_pages&quot;)</div><div class="line">  long totalPages;</div><div class="line">  @SerializedName(&quot;total_elements&quot;)</div><div class="line">  long totalElements;</div><div class="line"></div><div class="line">  //这里使用非静态方法的写法可以达到继承泛型类型的目的</div><div class="line">  public PageableResponseBuilder&lt;T&gt; builder() &#123;</div><div class="line">    return new PageableResponseBuilder&lt;T&gt;();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public class PageableResponseBuilder&lt;T&gt; &#123;</div><div class="line"></div><div class="line">    List&lt;T&gt; results;</div><div class="line">    long totalPages;</div><div class="line">    long totalElements;</div><div class="line"></div><div class="line">    public PageableResponseBuilder&lt;T&gt; totalPages(long totalPages) &#123;</div><div class="line">      this.totalPages = totalPages;</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public PageableResponseBuilder&lt;T&gt; totalElements(long totalElements) &#123;</div><div class="line">      this.totalElements = totalElements;</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public PageableResponseBuilder&lt;T&gt; results(List&lt;T&gt; results) &#123;</div><div class="line">      this.results = results;</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public PageableResponse&lt;T&gt; build() &#123;</div><div class="line">      return new PageableResponse&lt;&gt;(results, totalPages, totalElements);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 成长 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kylin二次开发——测试环境搭建]]></title>
      <url>/2017/08/07/Kylin%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h3 id="调研背景"><a href="#调研背景" class="headerlink" title="调研背景"></a>调研背景</h3><p>虽然公司目前在生产环境上正式用上了kylin，但是由于其本身年龄不长，社区并不完善，难难免会暴露出各种各样的源码级别的问题(包括上一篇介绍的kylin的同步机制的问题)。这时候使用者想等着官方推出新的release未免太过于被动。于是，我们想着对kylin进行二次开发以满足我们对定制化需求。事实上，目前我们使用的所有开源框架在一定程度上都进行了多多少少的二次开发：</p>
<ul>
<li>superset接入kylin，完成了自编译集成进了docker，并修改了 flask-appbuilder的源码逻辑，兼容ldap与原本的账号系统。</li>
<li>airflow 正在考虑从输出信息中判断task是否执行成功，而不是单纯的靠进程是否异常退出判断（主要考虑到支持kylin的任务调度）</li>
</ul>
<p>其实在kylin的官网对于开发环境搭建大致的步骤都做了介绍下面描述整个过程</p>
<h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><ul>
<li><p>想应用经过自己二次开发的kylin当然必须得全覆盖的跑一遍所有的单元测试。这就意味着必须得有Hadoop+hive+hbase等一整套测试环境。这里使用kylin官方推荐的Hortonworks Sandbox。为了方便，直接使用Sandbox on docker。</p>
<ul>
<li><a href="https://hortonworks.com/tutorial/sandbox-deployment-and-install-guide/section/3/" target="_blank" rel="external">按照官网的教程（docker占用的内存至少8G以上，否则运行不了）</a></li>
<li>在执行start_sandbox-hdp.sh的时候需要往映射的端口里面加入hive metastore的thrift端口9083，否则本地跑单元测试的时候连不上metastore</li>
<li><p>ssh上运行的container，修改admin密码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ssh -p 2222 root@localhost</div><div class="line">或者http://127.0.0.1:4200/ 进入shell浏览器界面</div><div class="line">//执行</div><div class="line">  ambari-admin-password-reset</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>用修改的admin密码登录<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>，确保dashboard中hive+mapreduce+hdfs+hbase正常启动</p>
</li>
<li><p>修改kylin.properties的几个值:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//KYLIN_HOME/examples/test_case_data/sandbox/kylin.properties</div><div class="line"></div><div class="line">kylin.job.use-remote-cli=true</div><div class="line">kylin.job.remote-cli-hostname=sandbox</div><div class="line">kylin.job.remote-cli-username=root</div><div class="line">kylin.job.remote-cli-password=xxxx</div><div class="line">//这个默认是22端口，由于我本地不生效，就直接设置为2222端口</div><div class="line">kylin.job.remote-cli-port=2222</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>如果单个单元进行测试，不想每次从头开始，方便集中debug某个moudle的错误，可以注释掉pom.xml中的check-style插件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;!-- &lt;plugin&gt;</div><div class="line">                  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">                  &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;</div><div class="line">                  &lt;version&gt;2.17&lt;/version&gt;</div><div class="line">                  &lt;dependencies&gt;</div><div class="line">                      &lt;dependency&gt;</div><div class="line">                          &lt;groupId&gt;com.puppycrawl.tools&lt;/groupId&gt;</div><div class="line">                          &lt;artifactId&gt;checkstyle&lt;/artifactId&gt;</div><div class="line">                          &lt;version&gt;6.19&lt;/version&gt;</div><div class="line">                      &lt;/dependency&gt;</div><div class="line">                  &lt;/dependencies&gt;</div><div class="line">                  &lt;executions&gt;</div><div class="line">                      &lt;execution&gt;</div><div class="line">                          &lt;id&gt;check-style&lt;/id&gt;</div><div class="line">                          &lt;phase&gt;validate&lt;/phase&gt;</div><div class="line">                          &lt;configuration&gt;</div><div class="line">                              &lt;configLocation&gt;dev-support/checkstyle.xml&lt;/configLocation&gt;</div><div class="line">                              &lt;suppressionsLocation&gt;dev-support/checkstyle-suppressions.xml&lt;/suppressionsLocation&gt;</div><div class="line">                              &lt;includeTestSourceDirectory&gt;true&lt;/includeTestSourceDirectory&gt;</div><div class="line">                              &lt;consoleOutput&gt;true&lt;/consoleOutput&gt;</div><div class="line">                              &lt;failsOnError&gt;true&lt;/failsOnError&gt;</div><div class="line">                          &lt;/configuration&gt;</div><div class="line">                          &lt;goals&gt;</div><div class="line">                              &lt;goal&gt;check&lt;/goal&gt;</div><div class="line">                          &lt;/goals&gt;</div><div class="line">                      &lt;/execution&gt;</div><div class="line">                  &lt;/executions&gt;</div><div class="line">              &lt;/plugin&gt; --&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>执行测试命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//base</div><div class="line">mvn test -fae -Dhdp.version=$&#123;HDP_VERSION:-&quot;2.6.1.0-129&quot;&#125; -P sandbox -X</div><div class="line">//全覆盖</div><div class="line">mvn verify -Dhdp.version=$&#123;HDP_VERSION:-&quot;2.6.1.0-129&quot;&#125; -fae 2&gt;&amp;1 | tee mvnverify.log</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><ul>
<li><p>该暴露的端口得暴露出来，否则本地测试的时候对指定的端口无法进行tcp通信</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">9083:9083 //hive metastore</div><div class="line">8050:8050 // kylin 获取job output信息端口</div><div class="line">50010:50010 // dfs.datanode.address，这里踩坑很久,不配置的话会有：createBlockOutputStream when copying data into HDFS错误</div></pre></td></tr></table></figure>
</li>
<li><p>启动start_sandbox-hdp脚本的时候，可能会出现postgresql服务启动不了，这很可能是因为其申请的共享内存超过了系统的，只需要进入到容器里面做相关操作</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ssh -p root@localhost</div><div class="line">sudo sysctl -w kernel.shmmax=17179869184 //假设你有16G内存，按实际扩充</div><div class="line">sudo service postgresql start</div><div class="line">//postgresql启动之后在容器外重新执行</div><div class="line">./start_sandbox-hdp.sh 就可以了</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> kylin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kylin master-slave同步原理及问题排查]]></title>
      <url>/2017/07/06/kylin-master-slave%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%8F%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近俩个月，团队整个数据基础架构慢慢转移到kylin上面来。而kylin也不负众望，对于一些复杂的聚合查询响应速度远超于hive。随着数据量的上来，kylin的单体部署逐渐无法支撑大量的并行读写任务。于是，自然而然的考虑到kylin的读写分离。一写多读，正好也符合kylin官方文档上的cluster架构。然而在实际的使用中也出现了一些问题:</p>
<ul>
<li>主节点更新了schema而从节点未sync</li>
<li>从节点中部分sync成功，而不是全部</li>
</ul>
<p>而很明显的是kylin中所有的数据，包括所有元数据都是落地在HBase中的，那唯一导致节点间数据不一致的可能就只有各个节点都有本地缓存的情况了。为了理解原理方便debug，我对kylin master-slave的同步原理做了一些源代码层面的剖析。</p>
<h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><h4 id="主从配置方式"><a href="#主从配置方式" class="headerlink" title="主从配置方式"></a>主从配置方式</h4><p>关于配置的格式，不得不吐槽官方文档的滑水。并没有给出详细的节点配置格式，查阅相关源码才发现正确的配置格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//kylin.properties下面的配置，根据源码，配置的格式为：user:pwd@host:port</div><div class="line">kylin.server.cluster-servers=user:password@host:port,user:password@host:port,user:password@host:port</div></pre></td></tr></table></figure>
<h4 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h4><p><img src="http://ol7zjjc80.bkt.clouddn.com/master-slave-kylin.png" alt="流程解析"></p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><ul>
<li><p>先来看看整个同步机制的核心BroadCaster类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//Broadcaster的构造函数</div><div class="line">private Broadcaster(final KylinConfig config) &#123;</div><div class="line">      this.config = config;</div><div class="line">      //获取kylin.properties中&quot;kylin.server.cluster-servers&quot;配置的值</div><div class="line">      //也就是集群中所有节点的配置了</div><div class="line">      final String[] nodes = config.getRestServers();</div><div class="line">      if (nodes == null || nodes.length &lt; 1) &#123;</div><div class="line">          logger.warn(&quot;There is no available rest server; check the &apos;kylin.server.cluster-servers&apos; config&quot;);</div><div class="line">          broadcastEvents = null; // disable the broadcaster</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">      logger.debug(nodes.length + &quot; nodes in the cluster: &quot; + Arrays.toString(nodes));</div><div class="line"></div><div class="line">      //开一个单线程，不间断的循环从broadcastEvents队列里面获取注册的事件。</div><div class="line">      Executors.newSingleThreadExecutor(new DaemonThreadFactory()).execute(new Runnable() &#123;</div><div class="line">          @Override</div><div class="line">          public void run() &#123;</div><div class="line">              final List&lt;RestClient&gt; restClients = Lists.newArrayList();</div><div class="line">              for (String node : config.getRestServers()) &#123;</div><div class="line">                  //根据配置的节点信息注册RestClient</div><div class="line">                  restClients.add(new RestClient(node));</div><div class="line">              &#125;</div><div class="line">              final ExecutorService wipingCachePool = Executors.newFixedThreadPool(restClients.size(), new DaemonThreadFactory());</div><div class="line">              while (true) &#123;</div><div class="line">                  try &#123;</div><div class="line">                      final BroadcastEvent broadcastEvent = broadcastEvents.takeFirst();</div><div class="line">                      logger.info(&quot;Announcing new broadcast event: &quot; + broadcastEvent);</div><div class="line">                      for (final RestClient restClient : restClients) &#123;</div><div class="line">                          wipingCachePool.execute(new Runnable() &#123;</div><div class="line">                              @Override</div><div class="line">                              public void run() &#123;</div><div class="line">                                  try &#123;</div><div class="line">                                      restClient.wipeCache(broadcastEvent.getEntity(), broadcastEvent.getEvent(), broadcastEvent.getCacheKey());</div><div class="line">                                  &#125; catch (IOException e) &#123;</div><div class="line">                                      logger.warn(&quot;Thread failed during wipe cache at &quot; + broadcastEvent, e);</div><div class="line">                                  &#125;</div><div class="line">                              &#125;</div><div class="line">                          &#125;);</div><div class="line">                      &#125;</div><div class="line">                  &#125; catch (Exception e) &#123;</div><div class="line">                      logger.error(&quot;error running wiping&quot;, e);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过Broadcaster的构造函数其实就能清楚整个同步过程的大概逻辑了。无非就是启动一个线程去轮询阻塞队列里面的元素，有的话就消费下来广播到其他从节点从而达到清理缓存的目的。</p>
</li>
<li><p>再来看看广播的实际逻辑实现,基本封装在RestClient中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//此处是根据配置的节点信息正则匹配：&quot;user:pwd@host:port&quot;</div><div class="line">public RestClient(String uri) &#123;</div><div class="line">   Matcher m = fullRestPattern.matcher(uri);</div><div class="line">   if (!m.matches())</div><div class="line">       throw new IllegalArgumentException(&quot;URI: &quot; + uri + &quot; -- does not match pattern &quot; + fullRestPattern);</div><div class="line"></div><div class="line">   String user = m.group(1);</div><div class="line">   String pwd = m.group(2);</div><div class="line">   String host = m.group(3);</div><div class="line">   String portStr = m.group(4);</div><div class="line">   int port = Integer.parseInt(portStr == null ? &quot;7070&quot; : portStr);</div><div class="line"></div><div class="line">   init(host, port, user, pwd);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>根据配置的节点信息实例化RestClient，然后在init方法中，拼接wipe cache的url</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private void init(String host, int port, String userName, String password) &#123;</div><div class="line">  this.host = host;</div><div class="line">  this.port = port;</div><div class="line">  this.userName = userName;</div><div class="line">  this.password = password;</div><div class="line">  //拼接rest接口</div><div class="line">  this.baseUrl = &quot;http://&quot; + host + &quot;:&quot; + port + &quot;/kylin/api&quot;;</div><div class="line"></div><div class="line">  client = new DefaultHttpClient();</div><div class="line"></div><div class="line">  if (userName != null &amp;&amp; password != null) &#123;</div><div class="line">      CredentialsProvider provider = new BasicCredentialsProvider();</div><div class="line">      UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(userName, password);</div><div class="line">      provider.setCredentials(AuthScope.ANY, credentials);</div><div class="line">      client.setCredentialsProvider(provider);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现kylin所有的交互接口基本上底层都是调用的自己的rest接口，它自己所谓的jdbc的查询方式其实也只是在rest接口上封装了一层，底层还是http请求。可谓是挂羊头卖狗肉了。看看RestClient中怎么去通知其他节点wipe cache的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void wipeCache(String entity, String event, String cacheKey) throws IOException &#123;</div><div class="line">   String url = baseUrl + &quot;/cache/&quot; + entity + &quot;/&quot; + cacheKey + &quot;/&quot; + event;</div><div class="line">   HttpPut request = new HttpPut(url);</div><div class="line"></div><div class="line">   try &#123;</div><div class="line">       HttpResponse response = client.execute(request);</div><div class="line">       String msg = EntityUtils.toString(response.getEntity());</div><div class="line"></div><div class="line">       if (response.getStatusLine().getStatusCode() != 200)</div><div class="line">           throw new IOException(&quot;Invalid response &quot; + response.getStatusLine().getStatusCode() + &quot; with cache wipe url &quot; + url + &quot;\n&quot; + msg);</div><div class="line">   &#125; catch (Exception ex) &#123;</div><div class="line">       throw new IOException(ex);</div><div class="line">   &#125; finally &#123;</div><div class="line">       request.releaseConnection();</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>已经很明了了，就是调的rest接口：/kylin/api/cache/{entity}/{cacaheKey}/{event}</p>
</li>
<li><p>当slave节点接收到wipeCache的指令时的处理逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public void notifyMetadataChange(String entity, Event event, String cacheKey) throws IOException &#123;</div><div class="line">     Broadcaster broadcaster = Broadcaster.getInstance(getConfig());</div><div class="line"></div><div class="line">     //这里会判断当前节点是否注册为listener了，如果注册了，此逻辑会被ignored</div><div class="line">     broadcaster.registerListener(cacheSyncListener, &quot;cube&quot;);</div><div class="line"></div><div class="line">     broadcaster.notifyListener(entity, event, cacheKey);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> //注册listener的逻辑</div><div class="line"> public void registerListener(Listener listener, String... entities) &#123;</div><div class="line">  synchronized (CACHE) &#123;</div><div class="line">      // ignore re-registration</div><div class="line">      List&lt;Listener&gt; all = listenerMap.get(SYNC_ALL);</div><div class="line">      if (all != null &amp;&amp; all.contains(listener)) &#123;</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      for (String entity : entities) &#123;</div><div class="line">          if (!StringUtils.isBlank(entity))</div><div class="line">              addListener(entity, listener);</div><div class="line">      &#125;</div><div class="line">      //注册几种事件类型</div><div class="line">      addListener(SYNC_ALL, listener);</div><div class="line">      addListener(SYNC_PRJ_SCHEMA, listener);</div><div class="line">      addListener(SYNC_PRJ_DATA, listener);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>notifyListener主要就是对所有事件处理逻辑的划分，根据事件类型选择处理逻辑，一般sheme的更新走的是默认逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public void notifyListener(String entity, Event event, String cacheKey) throws IOException &#123;</div><div class="line">     synchronized (CACHE) &#123;</div><div class="line">         List&lt;Listener&gt; list = listenerMap.get(entity);</div><div class="line">         if (list == null)</div><div class="line">             return;</div><div class="line"></div><div class="line">         logger.debug(&quot;Broadcasting metadata change: entity=&quot; + entity + &quot;, event=&quot; + event + &quot;, cacheKey=&quot; + cacheKey + &quot;, listeners=&quot; + list);</div><div class="line"></div><div class="line">         // prevents concurrent modification exception</div><div class="line">         list = Lists.newArrayList(list);</div><div class="line">         switch (entity) &#123;</div><div class="line">         case SYNC_ALL:</div><div class="line">             for (Listener l : list) &#123;</div><div class="line">                 l.onClearAll(this);</div><div class="line">             &#125;</div><div class="line">             clearCache(); // clear broadcaster too in the end</div><div class="line">             break;</div><div class="line">         case SYNC_PRJ_SCHEMA:</div><div class="line">             ProjectManager.getInstance(config).clearL2Cache();</div><div class="line">             for (Listener l : list) &#123;</div><div class="line">                 l.onProjectSchemaChange(this, cacheKey);</div><div class="line">             &#125;</div><div class="line">             break;</div><div class="line">         case SYNC_PRJ_DATA:</div><div class="line">             ProjectManager.getInstance(config).clearL2Cache(); // cube&apos;s first becoming ready leads to schema change too</div><div class="line">             for (Listener l : list) &#123;</div><div class="line">                 l.onProjectDataChange(this, cacheKey);</div><div class="line">             &#125;</div><div class="line">             break;</div><div class="line">         //大部分的走向</div><div class="line">         default:</div><div class="line">             for (Listener l : list) &#123;</div><div class="line">                 l.onEntityChange(this, entity, event, cacheKey);</div><div class="line">             &#125;</div><div class="line">             break;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         logger.debug(&quot;Done broadcasting metadata change: entity=&quot; + entity + &quot;, event=&quot; + event + &quot;, cacheKey=&quot; + cacheKey);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看到default分支会执行onEntityChange这个方法，看一下这个方法干的是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private Broadcaster.Listener cacheSyncListener = new Broadcaster.Listener() &#123;</div><div class="line">   @Override</div><div class="line">   public void onClearAll(Broadcaster broadcaster) throws IOException &#123;</div><div class="line">       removeAllOLAPDataSources();</div><div class="line">       cleanAllDataCache();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void onProjectSchemaChange(Broadcaster broadcaster, String project) throws IOException &#123;</div><div class="line">       removeOLAPDataSource(project);</div><div class="line">       cleanDataCache(project);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void onProjectDataChange(Broadcaster broadcaster, String project) throws IOException &#123;</div><div class="line">       removeOLAPDataSource(project); // data availability (cube enabled/disabled) affects exposed schema to SQL</div><div class="line">       cleanDataCache(project);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void onEntityChange(Broadcaster broadcaster, String entity, Event event, String cacheKey) throws IOException &#123;</div><div class="line">       if (&quot;cube&quot;.equals(entity) &amp;&amp; event == Event.UPDATE) &#123;</div><div class="line">           final String cubeName = cacheKey;</div><div class="line">           new Thread() &#123; // do not block the event broadcast thread</div><div class="line">               public void run() &#123;</div><div class="line">                   try &#123;</div><div class="line">                       Thread.sleep(1000);</div><div class="line">                       cubeService.updateOnNewSegmentReady(cubeName);</div><div class="line">                   &#125; catch (Throwable ex) &#123;</div><div class="line">                       logger.error(&quot;Error in updateOnNewSegmentReady()&quot;, ex);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;.start();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>看到对于cache的同步是单独实现了一个listener的，Event为update的时候，会单独启动一个线程去执行刷新缓存操作</p>
</li>
</ul>
<h3 id="加入简单的重试逻辑"><a href="#加入简单的重试逻辑" class="headerlink" title="加入简单的重试逻辑"></a>加入简单的重试逻辑</h3><p>由于目前对于同步失败的猜想是目标服务短暂不可用（响应超时或者处于失败重启阶段），于是我只是单纯的将失败的任务重新塞入broadcastEvents队列尾部供再一次调用。当然这种操作过于草率和暴力，却也是验证猜想最简单快速的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for (final RestClient restClient : restClients) &#123;</div><div class="line">           wipingCachePool.execute(new Runnable() &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">               try &#123;</div><div class="line">                 restClient.wipeCache(broadcastEvent.getEntity(), broadcastEvent.getEvent(),</div><div class="line">                     broadcastEvent.getCacheKey());</div><div class="line">               &#125; catch (IOException e) &#123;</div><div class="line">                 logger</div><div class="line">                     .warn(&quot;Thread failed during wipe cache at &#123;&#125;, error msg: &#123;&#125;&quot;, broadcastEvent,</div><div class="line">                         e.getMessage());</div><div class="line">                 try &#123;</div><div class="line">                   //这里重新塞入队列尾部，等待重新执行</div><div class="line">                   broadcastEvents.putLast(broadcastEvent);</div><div class="line">                   logger.info(&quot;put failed broadcastEvent to queue. broacastEvent: &#123;&#125;&quot;,</div><div class="line">                       broadcastEvent);</div><div class="line">                 &#125; catch (InterruptedException ex) &#123;</div><div class="line">                   logger.warn(&quot;error reentry failed broadcastEvent to queue, broacastEvent:&#123;&#125;, error: &#123;&#125; &quot;,</div><div class="line">                       broadcastEvent, ex);</div><div class="line">                 &#125;</div><div class="line">               &#125;</div><div class="line">             &#125;</div><div class="line">           &#125;);</div><div class="line">         &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>编译部署之后，日志中出现了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread failed during wipe cache at java.lang.IllegalStateException: Invalid use of BasicClientConnManager: connection still allocated.</div></pre></td></tr></table></figure>
<p>比较意外，不过也终于发现了问题的所在。Kylin在启动的时候会按照配置的nodes实例化一次RestClient，之后就直接从缓存中拿了，而kylin用的DefaultHttpClient每次只允许一次请求，请求完必须释放链接，否则无法复用HttpClient。所以需要修改wipeCache方法的逻辑如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void wipeCache(String entity, String event, String cacheKey) throws IOException &#123;</div><div class="line">    String url = baseUrl + &quot;/cache/&quot; + entity + &quot;/&quot; + cacheKey + &quot;/&quot; + event;</div><div class="line">    HttpPut request = new HttpPut(url);</div><div class="line"></div><div class="line">    HttpResponse response =null;</div><div class="line">    try &#123;</div><div class="line">        response = client.execute(request);</div><div class="line">        String msg = EntityUtils.toString(response.getEntity());</div><div class="line"></div><div class="line">        if (response.getStatusLine().getStatusCode() != 200)</div><div class="line">            throw new IOException(&quot;Invalid response &quot; + response.getStatusLine().getStatusCode() + &quot; with cache wipe url &quot; + url + &quot;\n&quot; + msg);</div><div class="line">    &#125; catch (Exception ex) &#123;</div><div class="line">        throw new IOException(ex);</div><div class="line">    &#125; finally &#123;</div><div class="line">        //确保释放连接</div><div class="line">        if(response!=null) &#123;</div><div class="line">          EntityUtils.consume(response.getEntity());</div><div class="line">        &#125;</div><div class="line">        request.releaseConnection();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> infrastructure </tag>
            
            <tag> 源码 </tag>
            
            <tag> Kylin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HBase架构脑图]]></title>
      <url>/2017/06/25/HBase%E6%9E%B6%E6%9E%84%E8%84%91%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近，由于我司数据基础新架构正在陆续往以Kylin为中心的方向上走，而Kylin的底层存储又是重度依赖HBase，为了保证数据服务的稳定性，无奈最近开始研究HBase的源码以及工作原理。翻阅各种书籍博客之余，大致总结了一张初期的HBase架构脑图，之后会随着认知的深入去不断更新。结合源码方面的分析也会陆续进行…比较蛋疼的是，HBase的源码太过庞大，不如Kylin的结构清晰，慢慢看吧…</p>
<h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><p><img src="http://ol7zjjc80.bkt.clouddn.com/HBase%E6%9E%B6%E6%9E%84.png" alt="HBase 架构图"></p>
]]></content>
      
        
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> Hbase </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kylin学习笔记]]></title>
      <url>/2017/05/02/Kylin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="OLAP-on-Line-AnalysisProcessing-的实现方式"><a href="#OLAP-on-Line-AnalysisProcessing-的实现方式" class="headerlink" title="OLAP(on-Line AnalysisProcessing)的实现方式"></a>OLAP(on-Line AnalysisProcessing)的实现方式</h3><ul>
<li>ROLAP:<br>基于关系数据库的OLAP实现（Relational OLAP）。ROLAP将多维数据库的多维结构划分为两类表:一类是事实表,用来存储数据和维关键字;另一类是维表,即对每个维至少使用一个表来存放维的层次、成员类别等维的描述信息。维表和事实表通过主关键字和外关键字联系在一起,形成了”星型模式”。对于层次复杂的维,为避免冗余数据占用过大的存储空间,可以使用多个表来描述,这种星型模式的扩展称为”雪花模式”。特点是将细节数据保留在关系型数据库的事实表中，聚合后的数据也保存在关系型的数据库中。这种方式查询效率最低，不推荐使用。</li>
<li><p>MOLAP:<br>多维数据组织的OLAP实现（Multidimensional OLAP。以多维数据组织方式为核心,也就是说,MOLAP使用多维数组存储数据。多维数据在存储中将形成”立方块（Cube）”的结构,在MOLAP中对”立方块”的”旋转”、”切块”、”切片”是产生多维数据报表的主要技术。特点是将细节数据和聚合后的数据均保存在cube中，所以以空间换效率，查询时效率高，但生成cube时需要大量的时间和空间。</p>
</li>
<li><p>HOLAP: 基于混合数据组织的OLAP实现（Hybrid OLAP）。如低层是关系型的，高层是多维矩阵型的。这种方式具有更好的灵活性。特点是将细节数据保留在关系型数据库的事实表中，但是聚合后的数据保存在cube中,聚合时需要比ROLAP更多的时间,查询效率比ROLAP高，但低于MOLAP。</p>
</li>
<li><p>kylin的cube数据是作为key-value结构存储在hbase中的，key是每一个维度成员的组合值，不同的cuboid下面的key的结构是不一样的，例如cuboid={brand，product，year}下面的一个key可能是brand=’Nike’，product=’shoe’，year=2015，那么这个key就可以写成Nike:shoe:2015，但是如果使用这种方式的话会出现很多重复，所以一般情况下我们会把一个维度下的所有成员取出来，然后保存在一个数组里面，使用数组的下标组合成为一个key，这样可以大大节省key的存储空间，kylin也使用了相同的方法，只不过使用了字典树（Trie树），每一个维度的字典树作为cube的元数据以二进制的方式存储在hbase中，内存中也会一直保持一份。</p>
</li>
</ul>
<h3 id="cube-构建"><a href="#cube-构建" class="headerlink" title="cube 构建"></a>cube 构建</h3><ul>
<li>Dimension：Mandatory、hierarchy、derived</li>
<li>增量cube: kylin的核心在于预计算缓存数据，因此无法达到真正的实时查询效果。一个cube中包含了多个segment，每一个segment对应着一个物理cube，在实际存储上对应着一个hbase的一个表。每次查询的时候会查询所有的segment聚合之后的值进行返回，但是当segment数量较多时，查询效率会降低，这时会对segment进行合并。被合并的几个segment所对应的hbase表并没有被删除。</li>
<li>cube词典树：cube数据是作为key-value结构存储在HBase中的。key是每一个维度成员的组合值</li>
</ul>
<h3 id="Streaming-cubing"><a href="#Streaming-cubing" class="headerlink" title="Streaming cubing"></a>Streaming cubing</h3><ul>
<li>支持实时数据的cub。与传统的cub一样，共享storage engine(HBase)以及query engine。kylin Streaming cubing相比其他实时分析系统来说，不需要特别大的内存，也不需要实现真正的实时分析。因为在OLAP中，存在几分钟的数据延迟是完全可以接受的。于是实现手法上采用了micro batch approach。</li>
<li>micro batch approach:将监听到的数据按照时间窗口的方式划分，并且为每个窗口封装了一个微量批处理，批处理后的结果直接存到HBase。</li>
<li>Streaming cubing data 最终会慢慢转换成普通的cubes,因为所有的数据是直接保存到HBase中的，并且保存为一个新的segment，当segment数量到达一定程度时，job engine会将segment 合并起来形成一个大的cube。</li>
</ul>
<h3 id="实战问题总结"><a href="#实战问题总结" class="headerlink" title="实战问题总结"></a>实战问题总结</h3><p>由于集群环境是CDH集群，所以选择了kylin CDH 1.6的版本，支持从Kafka读取消息建立Streaming cubes直接写入HDFS中</p>
<ul>
<li>选择一个集群namenode节点，将解压包放入/opt/cloudrea/parcels/目录中。如果是部署单节点，暂时不用更改配置文件。所有的配置加载都在bin/kylin.sh中。</li>
<li>直接kylin.sh start/stop 运行脚本，服务就会在7070端口起一个web界面。这个界面是可以进行可视化操作的。</li>
</ul>
<h3 id="Hive-数据源"><a href="#Hive-数据源" class="headerlink" title="Hive 数据源"></a>Hive 数据源</h3><ul>
<li>直接测试hive数据源是没有问题的，这一功能比较完善，也是主打功能。</li>
</ul>
<h3 id="kafka数据源"><a href="#kafka数据源" class="headerlink" title="kafka数据源"></a>kafka数据源</h3><p>从kylin 1.6 版本开始正式支持Kafka做数据源，将Streaming Cubes实时写入 HBase中。这一块在测试的时候也出现了问题：</p>
<ul>
<li><p>Kafka版本问题</p>
<ul>
<li>由于实验环境的CDH集群Kafka版本是0.9的，而kylin 仅支持0.10以上的版本，所以需要对CDH kafka集群进行升级。</li>
</ul>
</li>
<li><p>mapreduce运行环境无jar包</p>
<ul>
<li>kylin中提交cube build之后，map reduce任务直接抛错。错误提示是，找不到Kafka的Consumer类。根本原因是kylin默认集群上的map reduce classpath是会加载kafka-clients.jar包的，所以在提交任务的时候没有将kafka-clients.jar包打进去。这时可以有三种做法：</li>
<li>直接修改kylin的源码，将kafka-clients.jar包给包括进去（待尝试）。</li>
<li>可以通过修改集群的HADOOP_ClASSPATH的路径，将jar包给包括进去。</li>
<li>hadoop classpath 查看classpath目录信息 将对应jar包直接拷入map reduce classpath中，这方法简单，但是缺点就是需要逐个得对node进行操作。</li>
</ul>
</li>
<li><p>Property is not embedded format</p>
<ul>
<li><p>现在意识到，使用开源框架不会看其源码是不行的…就在我折腾俩天终于将mapreduce任务跑起来之后，新的错误出现了:”ava.lang.RuntimeException: java.io.IOException: Property ‘xxx’ is not embedded format”。莫名奇妙的错误。迫使我直接去github上看kylin kafka模块的源码。在TimedJsonStreamParser.java中发现代码逻辑中默认json数据中，如果key存在下划线就会将该key按照下划线split… 然后看key对应的value是不是map类型，如果不是直接抛出标题的错误。</p>
</li>
<li><p>明确了问题之后，如何复写默认下划线split的配置成为问题。由于官网的文档十分鸡肋，很多坑都没有涉及到，所以继续看源码。发现StreamingParser.java这个类中会去写一些默认的配置。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static final String PROPERTY_TS_COLUMN_NAME = &quot;tsColName&quot;;</div><div class="line">public static final String PROPERTY_TS_PARSER = &quot;tsParser&quot;;</div><div class="line">public static final String PROPERTY_TS_PATTERN = &quot;tsPattern&quot;;</div><div class="line">public static final String EMBEDDED_PROPERTY_SEPARATOR = &quot;separator&quot;;</div><div class="line"></div><div class="line">static &#123;</div><div class="line">        derivedTimeColumns.put(&quot;minute_start&quot;, 1);</div><div class="line">        derivedTimeColumns.put(&quot;hour_start&quot;, 2);</div><div class="line">        derivedTimeColumns.put(&quot;day_start&quot;, 3);</div><div class="line">        derivedTimeColumns.put(&quot;week_start&quot;, 4);</div><div class="line">        derivedTimeColumns.put(&quot;month_start&quot;, 5);</div><div class="line">        derivedTimeColumns.put(&quot;quarter_start&quot;, 6);</div><div class="line">        derivedTimeColumns.put(&quot;year_start&quot;, 7);</div><div class="line">        defaultProperties.put(PROPERTY_TS_COLUMN_NAME, &quot;timestamp&quot;);</div><div class="line">        defaultProperties.put(PROPERTY_TS_PARSER, &quot;org.apache.kylin.source.kafka.DefaultTimeParser&quot;);</div><div class="line">        defaultProperties.put(PROPERTY_TS_PATTERN, DateFormat.DEFAULT_DATETIME_PATTERN_WITHOUT_MILLISECONDS);</div><div class="line">        defaultProperties.put(EMBEDDED_PROPERTY_SEPARATOR, &quot;_&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>自然而然会联想到，这个默认的配置肯定是可以在用户设置的时候通过key（separator）去覆盖的…于是发现在构建Streaming table的时候，可以通过Parse Properties去覆盖配置。<br>于是直接写成如下的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">tsColName=timestamp;separator=no</div><div class="line"></div><div class="line">//源码中拿到这个配置之后会做覆盖处理，然后执行 getValueByKey：</div><div class="line"></div><div class="line">protected String getValueByKey(String key, Map&lt;String, Object&gt; rootMap) throws IOException &#123;</div><div class="line">        if (rootMap.containsKey(key)) &#123;</div><div class="line">            return objToString(rootMap.get(key));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String[] names = nameMap.get(key);</div><div class="line">        if (names == null &amp;&amp; key.contains(separator)) &#123;</div><div class="line">            names = key.toLowerCase().split(separator);</div><div class="line">            nameMap.put(key, names);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (names != null &amp;&amp; names.length &gt; 0) &#123;</div><div class="line">            tempMap.clear();</div><div class="line">            tempMap.putAll(rootMap);</div><div class="line">            //这块如果复写了separator属性的话split后的names数组长度为1会跳过这一步循环，防止解析出错</div><div class="line">            for (int i = 0; i &lt; names.length - 1; i++) &#123;</div><div class="line">                Object o = tempMap.get(names[i]);</div><div class="line">                if (o instanceof Map) &#123;</div><div class="line">                    tempMap.clear();</div><div class="line">                    tempMap.putAll((Map&lt;String, Object&gt;) o);</div><div class="line">                &#125; else &#123;</div><div class="line">                    throw new IOException(&quot;Property &apos;&quot; + names[i] + &quot;&apos; is not embedded format&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Object finalObject = tempMap.get(names[names.length - 1]);</div><div class="line">            return objToString(finalObject);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return StringUtils.EMPTY;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> kylin </tag>
            
            <tag> infrastructure </tag>
            
            <tag> data </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark学习笔记]]></title>
      <url>/2017/04/11/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="Spark-基础"><a href="#Spark-基础" class="headerlink" title="Spark 基础"></a>Spark 基础</h1><h2 id="Spark-的构成"><a href="#Spark-的构成" class="headerlink" title="Spark 的构成"></a>Spark 的构成</h2><ul>
<li>ClusterManager: 在standalone模式中即为，Master主节点，控制整个集群，监控worker。在yarn模式中为资源管理器</li>
<li>worker :从节点，负责控制计算节点，启动Executro和Driver。在yarn模式中NodeManager,负责计算节点的控制。</li>
<li>Driver：运行Application的main()函数并且创建SparkContext。</li>
<li>Executor: 执行器，是为某Application运行在worker node上的一个进程，启动线程池运行任务上，每个Application拥有一组独立的executors</li>
<li>SparkContext: 整个应用程序的上下文，控制整个应用的生命周期</li>
<li>RDD：Spark的基本计算单元，一组RDD形成执行的有向无环图RDD Graph(DAG)</li>
<li>DAG Scheduler: 根据Job构建基于stage的DAG，并且提交stage给TaskScheduler</li>
<li>TaskScheduler: 可以将提交给它的stage 拆分为更多的task并分发给Executor执行</li>
<li>SparkEnv: 线程级别的上下文，存储运行时的重要组件的引用</li>
<li>DStream: 是一个RDD的序列，由若干RDD组成。在一个batchInterval中，会产生一个RDD，产生的数据统一塞入到这个RDD中，采用内存+磁盘的模式，尽可能放到内存中，当数据量太大时会spill到磁盘中。</li>
</ul>
<h2 id="spark-工作机制"><a href="#spark-工作机制" class="headerlink" title="spark 工作机制"></a>spark 工作机制</h2><ul>
<li>一个Job被拆分成若干个Stage，每个Stage执行一些计算，产生一些中间结果。它们的目的是最终生成这个Job的计算结果。而每个Stage是一个task set，包含若干个task。Task是Spark中最小的工作单元，在一个executor上完成一个特定的事情。</li>
<li>除非用户指定持久化操作，否则转换过程中产生的中间数据在计算完毕后会被丢弃，即数据是非持久化的。</li>
<li>窄依赖:父RDD中的一个分区最多只会被子RDD中的一个分区使用，父RDD中，一个分区内的数据是不能被分割的，必须整个交付给子RDD中的一个分区。</li>
<li>宽依赖（Shuffle依赖）：父RDD中的分区可能会被多个子RDD分区使用。因为父RDD中一个分区内的数据会被分割，发送给子RDD的所有分区。因此Shuffle依赖也意味着父RDD与子RDD之间存在着Shuffle过程。</li>
</ul>
<h3 id="Spark作业"><a href="#Spark作业" class="headerlink" title="Spark作业"></a>Spark作业</h3><ul>
<li>Application: 用户自定义的Spark程序，用户提交之后，Spark为App分配资源程序转换并执行。</li>
<li>Driver Program: 运行Application的main函数并且创建SparkContext</li>
<li>RDD DAG： 当RDD遇到Action算子，将之前的所有算子形成一个有向无环图（DAG）。再在Spark中转化为Job,提交到集群进行执行，一个App中可以包含多个Job</li>
<li>Job： RDD Graph触发的作业，由spark Action算子触发，在SparkContext中通过runJob方法向spark提交Job</li>
<li>stage： 每个Job会根据RDD的宽依赖关系被切分很多stage ,每个stage包含一组相同的task，这一组task也叫taskset</li>
<li>Task: 一个分区对应一个Task,Task 执行RDD中对应stage中所包含的算子，Taksk 被封装好后放入Executor的线程池中执行。</li>
</ul>
<h3 id="spark-运行流程"><a href="#spark-运行流程" class="headerlink" title="spark 运行流程"></a>spark 运行流程</h3><ul>
<li>spark程序转换</li>
<li>输入数据块</li>
<li>根据调度策略执行各个stage的task（每个stage之间要进行shuffle）</li>
<li>结果返回</li>
</ul>
<h2 id="spark调度原理"><a href="#spark调度原理" class="headerlink" title="spark调度原理"></a>spark调度原理</h2><h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><p>系统的设计很重要的一环便是资源调度。设计者将资源进行不同粒度的抽象建模，然后将资源统一放入调度器，通过一定的算法进行调度。</p>
<ul>
<li>spark的多种运行模式：Local模式，standalone模式、YARN模式，Mesos模式。</li>
</ul>
<h3 id="application调度"><a href="#application调度" class="headerlink" title="application调度"></a>application调度</h3><p>用户提交到spark中的作业集合，通过一定的算法对每个按一定次序分配集群中资源的过程。</p>
<ul>
<li>FIFO模式，用户先提交的作业1优先分配需要的资源，之后提交的作业2再分配资源，依次类推。</li>
<li>Mesos: 粗粒度模式和细粒度模式</li>
<li>YARN模式：独占模式，可以控制应用分配资源</li>
</ul>
<h3 id="Job调度"><a href="#Job调度" class="headerlink" title="Job调度"></a>Job调度</h3><p>Job调度就是在application内部的一组Job集合，在application分配到的资源量，通过一定的算法，对每个按一定次序分配Application中资源的过程。</p>
<ul>
<li>FIFO模式：先进先出模式</li>
<li>FAIR模式：spark在多个job之间以轮询的方式给任务进行资源分配，所有的任务拥有大致相当的优先级来共享集群的资源。这就意味着当一个长任务正在执行时，短任务仍可以分配到资源，提交并执行，并且获得不错的响应时间。</li>
</ul>
<h3 id="tasks延迟调度"><a href="#tasks延迟调度" class="headerlink" title="tasks延迟调度"></a>tasks延迟调度</h3><ul>
<li><p>数据本地性：尽量的避免数据在网络上的传输，传输任务为主，将任务传输到数据所在的节点</p>
</li>
<li><p>延时调度机制：拥有数据的节点当前正被其他的task占用，如果预测当前节点结束当前任务的时间要比移动数据的时间还要少，那么调度会等待，直到当前节点可用。否则移动数据到资源充足节点，分配任务执行。</p>
</li>
</ul>
<h2 id="job-小文件处理问题"><a href="#job-小文件处理问题" class="headerlink" title="job 小文件处理问题"></a>job 小文件处理问题</h2><ul>
<li>因为每次job partition数量过多，导致hive表中过多小文件产生，所以需要重新指定分区，有以下俩种方法：repartition(numPartitions:Int):RDD[T]和coalesce(numPartitions:Int，shuffle:Boolean=false):RDD[T]<br>他们两个都是RDD的分区进行重新划分，repartition只是coalesce接口中shuffle为true的简易实现，（假设RDD有N个分区，需要重新划分成M个分区）<ul>
<li>N&lt;M。一般情况下N个分区有数据分布不均匀的状况，利用HashPartitioner函数将数据重新分区为M个，这时需要将shuffle设置为true。</li>
<li>如果N&gt;M并且N和M相差不多，(假如N是1000，M是100)那么就可以将N个分区中的若干个分区合并成一个新的分区，最终合并为M个分区，这时可以将shuff设置为false，在shuffl为false的情况下，如果M&gt;N时，coalesce为无效的，不进行shuffle过程，父RDD和子RDD之间是窄依赖关系。</li>
<li>如果N&gt;M并且两者相差悬殊，这时如果将shuffle设置为false，父子ＲＤＤ是窄依赖关系，他们同处在一个Ｓｔａｇｅ中，就可能造成Spark程序的并行度不够，从而影响性能，如果在M为1的时候，为了使coalesce之前的操作有更好的并行度，可以讲shuffle设置为true。</li>
</ul>
</li>
</ul>
<p>总之：如果shuff为false时，如果传入的参数大于现有的分区数目，RDD的分区数不变，也就是说不经过shuffle，是无法将RDD的分区数变多的。</p>
<h2 id="spark-优化与参数调优"><a href="#spark-优化与参数调优" class="headerlink" title="spark 优化与参数调优"></a><a href="http://tech.meituan.com/spark-tuning-basic.html" target="_blank" rel="external">spark 优化与参数调优</a></h2><ul>
<li><p>最重要的是数据序列化和内存调优。对于大多数程序选择Kyro序列化器并持久化序列后的数据能解决常见的性能问题。</p>
</li>
<li><p>Executor</p>
<ul>
<li>每个节点可以起一个或多个Executor。每个Executor上的一个核只能同时执行一个task,如果一个Executor被分到了多个task只能排队依次执行</li>
<li>Executor内存主要分三块：1、让task执行我们自己编写的代码，默认占总内存的20%。2、让rask通过shuffle过程拉取了上一个stage的task输出后，进行聚合等操作时，默认占用总内存20%；3、让RDD持久化使用，默认60%</li>
<li>task的执行速度是跟每个Executor进程的CPU core数量有直接关系的。一个CPU core同一时间只能执行一个线程。而每个Executor进程上分配到的多个task，都是以每个task一条线程的方式，多线程并发运行的。如果CPU core数量比较充足，而且分配到的task数量比较合理，那么通常来说，可以比较快速和高效地执行完这些task线程。</li>
</ul>
</li>
<li><p>广播大变量</p>
<ul>
<li>当需要用到外部变量时，默认每个task都会存一份，这样会增加GC次数，使用广播变量能确保一个Executor中只有一份</li>
</ul>
</li>
<li><p>使用Kryo优化序列化性能(如果希望RDD序列化存储在内存中，面临GC问题的时候，优先使用序列化缓存技术)</p>
<ul>
<li>spark没有默认使用Kryo作为序列化类库，是因为Kryo要求注册所有需要序列化的自定义类型，这对开发比较麻烦</li>
</ul>
</li>
<li><p>spark submit示例:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sudo -u mobvoidata spark-submit \</div><div class="line">		--class com.mobvoi.data.analytics.Main \</div><div class="line">		--num-executors 25 \</div><div class="line">		--executor-cores 1 \</div><div class="line">		--driver-memory 4G \</div><div class="line">		--conf spark.kryoserializer.buffer.max=256m \</div><div class="line">		mobvoi-analytics-job-assembly-1.0.1.jar &quot;all&quot; &quot;true/false&quot;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HBase学习与经验总结]]></title>
      <url>/2017/03/15/HBase%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为业务的关系，也零零碎碎的接触到了HBase，并对其产生了兴趣。这段时间又抽空看了一下《HBase权威指南》，于是，秉承着学习记录的习惯，把一些知识和经验写成了博客。</p>
<h3 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h3><ul>
<li>表：HBase将数据组织到自己的HTable表中，这个表是根据列族(colomn family)在物理上保存数据的，每个列族都有自己的文件夹和storefiles，不像关系型数据库那样将一个表保存成一个文件，表明也是文件系统路径的一部分。</li>
<li>行键：每行都有唯一的行键，行键没有数据类型，它内部被认为是一个字节数组。</li>
<li>列族：HBase表中的行是按一个叫colomn family的列族分组的，也是在磁盘上也是按列族存储数据的，由于这个原因，故当定义一个hbase表时，除了定义表名外，还必须定义列族。传统数据库没有列族的概念。</li>
<li>列修饰符：列簇定义真实的列，被称之为列修饰符，你可以认为列修饰符就是列本身。</li>
</ul>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><ul>
<li>数据结构：LSM树。使用日志文件和内存存储来将随机写转换成顺序写，因此也能保证稳定的数据插入速率。由于读和写独立，因此在这俩种操作之间没有冲突。由于存储数据的布局较优，查询一个键需要的磁盘寻到次数在一个可预测的范围内。并且读取与该键连续的任意数量的记录都不会引发任何额外的磁盘寻道。</li>
<li>启动HBase时。HMaster负责将所有的region分配到HRegion Server 上，其中也包括特别的-Root-和.META.表。HRegion Server负责打开region,并创建对应的HRegion实例。这些列族是用户之前创建表时定义的。每个store实例包含一个或多个storefile实例，它们实际数据存储文件HFile的轻量级封装。每个Store还有其对应的一个MemStore, 一个HregionServer分享了一个HLog实例。</li>
<li>基本的请求流程: 客户端先联系ZK子集群查找行键。此过程是通过ZK获取含有-ROOT-的region服务器名来完成的。通过含有-Root-的region服务器可以查询到含有.META表中对应的region服务器名，其中包括请求的行键信息。这俩处主要内容都被缓存起来了。并且都只查询一次。最终通过查询.META.服务器来获取客户端的行键数据所在的region的服务器名。</li>
<li>写数据的过程。第一步决定数据是否需要写到由HLog类实现的预写日志中。WAL是标准的Hadoop SequenceFile 并且存储了HlogKey实例。这些键包括序列号和实际数据。所以在服务器崩溃时可以回滚还没有持久化的数据。一旦数据被写入WAL中，数据就会被放到MemStore中，同时还会检查memstore是否已经骂了，如果满了，就会被请求刷写到磁盘中去。刷写请求由另外一个HRegionServer的线程处理，它会把数据写成一个新的HFile。同时也会保存最后写入的序号。系统就知道哪些数据现在被持久化了。</li>
</ul>
<h3 id="region拆分与合并"><a href="#region拆分与合并" class="headerlink" title="region拆分与合并"></a>region拆分与合并</h3><h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><ul>
<li>当一个region里的存储文件增长到大于配置的hbase.hregion.max.filesize大小或者在列族层面配置的大小时，region会被一分为二。这个过程通常非常迅速，因为系统只是为新region创建了俩个对应的文件，每个region是原始region的一半。</li>
<li>region服务器在父region中创建splits目录来完成这个过程。接下来关闭该region。此后这个region不再接受任何请求。然后region服务器通过在splits目录中设立必须的文件结构来准备新的子region，包括新region目录和参考文件。如果这个过程成功完成，它将把两个新region目录移到表目录中。.META.表中父region的状态会被更新，以表示其现在拆分的节点和子节点是什么。可以避免父region被意外重新打开。</li>
</ul>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><h3 id="rowKey的设计"><a href="#rowKey的设计" class="headerlink" title="rowKey的设计"></a>rowKey的设计</h3><h4 id="关于rowKey的一些认识"><a href="#关于rowKey的一些认识" class="headerlink" title="关于rowKey的一些认识"></a>关于rowKey的一些认识</h4><ul>
<li>HBase表里只有键(KeyValue对象的Key部分，包括行键、列限定符和时间戳)可以建立索引。访问一个特定行的唯一办法是通过行键。</li>
<li>设计HBase表时，行键是唯一重要的事情，因此应该按照预期的访问方式来建立行键。此结论基于俩个事实依据：<ul>
<li>region基于行键为一个区间的行提供服务，并且负责区间内每一行</li>
<li>HFile在硬盘上存储有序的行。当region刷写留在内存里的行时生成了HFile。这些行已经排过序，也会有序地刷写到硬盘上。</li>
</ul>
</li>
</ul>
<h4 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h4><ul>
<li>先定好查询方案，可以使用包含部分键的扫描机制设计出非常有效的左对齐索引（字典序从左到右排序）当一个字段被加到键中时就多了一个可以检索的维度。</li>
<li>用户需要保证行键中每个字段的值都被补齐到这个字段所设的长度，这样字典序才会按照预期排列，（按照二进制内容比较，并升序排列），用户需要为每个字段设定一个固定的长度来保证每个字段比较时只会与同字段内容从左到右比较，否则可能出现溢出的情况。</li>
<li><p>可能的起始键的含义：</p>
<ul>
<li><userid> 扫描一个给定用户ID下的所有消息</userid></li>
<li><userid>-<date> 扫描一个给定用户ID下特定日期的消息</date></userid></li>
<li><userid>-<date>-<messageid> 扫描一个用户ID和日期下的一个消息。</messageid></date></userid></li>
</ul>
</li>
<li><p>防止系统产生热读写的设计：</p>
<ul>
<li>salting方式：使用salting前缀来保证数据分散到所有的region服务器。缺点就是当用户要扫描一个连续的范围时，可能需要跨region请求，这样的话可以通过多线程读取。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byte prefix=(byte)(Long.hashCode(time)%&lt;number of region servers&gt;);</div></pre></td></tr></table></figure>
<ul>
<li>随机化：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byte rowkey=MD5(timestamp);</div></pre></td></tr></table></figure>
<p>利用散列函数能将行键分散到所有的region服务器上，对于时间连续的数据，这样做不好，因为散列之后无法通过时间范围扫描数据。由于用户可以用散列的方式重新生成行键，随机化的方式很适合每次读取一行数据的应用，如果用户的数据不需要连续扫描而只需要随机读取，用户可以使用这种策略。</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> HBase </tag>
            
            <tag> BigData </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[InnoDB读书笔记]]></title>
      <url>/2017/02/15/InnoDB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li><p>数据库的四种隔离级别</p>
<ul>
<li>Read Uncommitted(读未提交): 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。于是事务B可能读取到了事务A未提交的数据。</li>
<li>Read -Committed(读提交): 读取数据的事务允许其他事务继续访问该行事务，但是未提交的写事务存在时禁止一切其他事务，该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</li>
<li>Repeated read （可重复读） 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。mysql的InnoDB的Repeated read 级别就可以解决幻读的问题(源自Next-Key Locking算法)，而oracle只能将隔离级别设置在Serializable才能解决幻读的问题。</li>
<li>Serializable（串行化）： 序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。</li>
</ul>
</li>
<li><p>InnoDB关键特性</p>
<ul>
<li>插入缓冲（Insert Buffer） 不可能每张表上只有一个聚集索引，在进行插入操作时候，数据页存放还是按照主键a进行顺序存放的，但是对于非聚集索引叶子节点的插入不再是顺序的了，这时会需要离散地访问非聚集索引页，需要注意，辅助索引的插入顺序依然是顺序的，或者说比较顺序的，比如用户购买表中的时间字段，通常情况下，用户购买时间是一个辅助索引，用来根据时间条件进行查询，但是在插入时却是根据时间递增而插入的，因此插入较为顺序。Insert Buffer 对于非聚集索引的插入和更新操作，不是每一次直接插入到索引页面，而是判断插入的是否在非索引页是否在缓冲池，若在，则直接插入。若不在先放入一个Insert Buffer中，好似欺骗。 因此  Insert Buffer需要满足的俩个条件： 索引是辅助索引，并且索引不是唯一的。</li>
<li>俩次写（Double Write）</li>
<li>自适应哈希索引（Adaptive Hash Index）</li>
<li>异步IO</li>
<li>刷新邻接页</li>
</ul>
</li>
</ol>
<h3 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h3><ol>
<li>InnoDB存储引擎支持的几种常见索引<ul>
<li>B+ 树索引：其下索引又分为：聚集索引，辅助索引（内部均为B+树）</li>
<li>全文索引</li>
<li>哈希索引 （哈希索引是自适应的，根据表的使用情况自动生成） 注意：B+ 树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存，再在内训中进行查找，最后得到想要查找的数据。</li>
</ul>
</li>
</ol>
<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ol>
<li>定义和性质<ul>
<li>由二叉树和平衡二叉树演化而来。是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录的节点都是按照键值的大小顺序存放在同一层的叶子节点上。由各叶子节点指针进行连接。</li>
<li>B+树的插入必须保证插入之后叶子节点的记录依然排序。</li>
<li>B+树在数据库中的有一个特点就是高扇出性，因此在数据库中B+树的高度一般都在2～4层，也就是说查找一个键值记录最多只需要2到4次IO。</li>
</ul>
</li>
<li><p>B+树定义</p>
<ul>
<li>分为聚集索引和辅助索引。俩者的不同之处在于叶子节点存放的是否是一整行的信息。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，而InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而聚集索引能够在叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地针对范围值查询，查询优化器能够快速发现某一段范围的数据页需要扫描。</li>
<li>聚集索引。由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于使用聚集索引。因为:<br>1）聚集索引能够直接在B+树索引上找到数据。<br>2）定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。能够快速的发现某一段范围的数据页需要扫描<br>误区：很多书和博客都介绍，聚集索引按照顺序物理地存储数据，其实这样会导致维护成本非常高，所以聚集索引的存储并不是物理上连续的。而是逻辑连续。原因：<br>1）页通过双向链表链接，页按照主键的顺序排序；<br>2）页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</li>
</ul>
</li>
<li><p>B+树索引的分裂</p>
</li>
<li>B+树索引的管理<ul>
<li><strong>Cardinality值：</strong><br>1）并不是在所有的查询条件中出现的列都需要添加索引，一般的经验是，在访问表中很少一部分时使用B+树索引才有意义，对于性别、地区、类型字段，它们的可取值范围很小，称为低选择性，于是建索引是完全没有必要的。<br>2）对于高选择性的确定，可以通过show index结果列中的列Cardinality来观察，表示的是索引中不重复记录数量的预估值。注意：仅仅是个预估值，而不是一个准确值。</li>
</ul>
</li>
<li><p>B+索引树的使用</p>
<ul>
<li><p>分析<br>1）用Show index table 查看索引的情况<br>2）用explain+sql语句 来分析这条sql的情况，包括使用的possible_keys（可能选择的索引）与key(实际选择的索引)</p>
</li>
<li><p>联合索引<br>是指对表上的多个列进行索引，创建方法与单个索引的创建方法一样，不同之处在于有多个索引列,如对于联合索引(a,b) ,以下是关于联合索引的一些情况</p>
<blockquote>
<p>1）select * from table where a=x and b=x;<br>显然是可以用(a,b)索引的，因为索引的顺序就是按照（a,b）来排序的</p>
<p>2）select * from table where a=xxx; 这个也是可以使用(a,b)索引的，只不过只能使用一部分</p>
<p>3) select * from table where b=xxx; 这个是不能使用索引的，因为压根就没按照b做排序。<br>联合索引的好处是，在第一个索引的基础上，已经给第二个键值做了排序的处理，从而可以减少一次排序操作：比如我们要查某个用户购买商品的情况，并且按照时间排序。</p>
</blockquote>
</li>
<li><p>覆盖索引</p>
<blockquote>
<p>1) Innodb存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，因此，大小要远小于聚集索引，可以大大减少IO操作。</p>
<p>2) 对于Innodb的辅助索引而言，由于其包含了主键信息，因此其叶子节点存放的数据为(primary key1,primary<br>key2,…)例如，下列语句都可以通过使用一次辅助索引来完成查询select primary key1,key2,… from table<br>where<br>key1=xxx;对于覆盖索引的另一个好处是对某些统计问题而言，不会选择通过聚集索引来进行统计。因为辅助索引的量远小于聚集索引，可以大大减少IO操作。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<pre><code>- 优化器选择不使用索引的情况
**如：select * from order where orderId&gt;10000 and orderId&lt;102000;  （从orderId的基数看来非常大，这是前提）**
这句sql按道理来说可以使用辅助索引的，可选的 KEYS有primary orderId, 等索引，然而最后选择了primary聚集索引，也就是全表扫描。原因在于用户要选取的数据是整行信息，而orderId索引不能覆盖到我们要查询的信息，因此在对orderId索引查询到指定的数据之后，还需要一次书签访问来查询整行信息，虽然orderId索引中的数据是顺序存放的，但是再一次进行书签来查找数据则是无序的，因此变为了磁盘上的离散读操作。如果要求访问的数据量很小。则优化器还会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分的时候（通常是百分之二十），优化器则会选择通过聚集索引来查找数据，因此之前已经提到过，顺序读要远远快于离散读。
因此，对于不能进行索引覆盖的情况，优化器选择辅助索引的条件是占有的数据量很小。当然这是由当前传统的机械硬盘的特性决定的。

- InnoDB存储引擎中的哈希算法
</code></pre><p>自适应哈希索引：数据库自身创建并使用的，经过哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快速。如 select * from table where index_cole=“xxx” 但是对于范围查找久无能为力了。</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><h4 id="lock-与-latch"><a href="#lock-与-latch" class="headerlink" title="lock 与 latch"></a>lock 与 latch</h4><ul>
<li>latch一般称为轻量级锁，因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以氛围mutex（互斥量）与 rwlock 读写锁。目的是用来保证并发线程的操作临界资源的正确性，并且通常没有死锁检测的机制，仅仅通过应用程序加锁的顺序来保证无死锁的情况发生。</li>
<li>lock的对象是事务，用来锁定的是数据库中的对象。如表，页，行。并且一般lock的对象仅在事务commit或rollback后进行释放。且有死锁机制</li>
<li>latch查看 show engine innodb mutex。lock查看 show engine innodb status</li>
</ul>
<h4 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h4><ul>
<li>InnoDB实现了俩种标准的行级锁：<ul>
<li>共享锁：允许事务读一行数据 </li>
<li>排他锁：允许事务删除或者更新一行数据</li>
</ul>
</li>
</ul>
<p>如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行的共享锁，称这种情况为锁兼容。但若有其他事务T3想要获得这一行的排他锁，则必须等待事务T1，2释放行上的共享锁称这种情况为锁不兼容。<br>可以总结出：X锁与任何锁都不兼容。而S锁仅仅和S锁兼容。需注意的是，S和X锁都是行级锁，兼容是指对同一记录锁的兼容性情况。</p>
<ul>
<li><p>意向锁： InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上的枷锁操作。InnoDB存储引擎支持一种额外的枷锁方式，称为意向锁。它是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p>
</li>
<li><p>如需要在页上的记录r进行行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度的锁完成。举例子说明：在对记录r加X锁之前。已经有事务对表1进行了S表锁，那么表1上一存在S锁，之后事务需要对记录R表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
</li>
<li>InnoDB存储引擎支持意向锁设计比较简练。其意向锁即为表级别的锁，设计的目的主要是为了在事务中揭示下一行将被请求的锁类型。其支持俩种意向锁：<ul>
<li>意向共享锁，事务想要获得一张表中某几行的共享锁。 </li>
<li>意向排他锁，事务想要获得一张表中某几行的排他锁。</li>
</ul>
</li>
</ul>
<p>由于InnoDB支持的是<strong>行级别的锁</strong>，因此意向锁其实不会阻塞<strong>除全表扫</strong>以外的任何请求，故而意向锁与行级别锁的兼容性<br><img src="http://ol7zjjc80.bkt.clouddn.com/lock.png" alt="兼容性"></p>
<p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">只有通过索引条件检索数据，InnoDB才使用行级锁，否则，将使用表级锁</div></pre></td></tr></table></figure></p>
<h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>InnoDB中通过多版本控制的方式来读取当前执行时间数据库中的行的数据。如果读取的行正在执行DELETE或者UPDATE操作，这时读取操作不会因此等待下去，�相反，InnoDB存储引擎会去读取行的一个快照数据<strong>。是InnoDB默认的读取方式</strong></p>
<h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>在默认的配置下，即事务的隔离级别为Repeatable Read模式下，InnoDB存储引擎的select操作使用一致性非锁定读，但是在某些情况下，用户需要显式地枷锁来保证数据的一致性。InnoDB存储引擎对于SELECT语句支持俩种一致性的锁定读操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select....FOR UPDATE //对行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。</div><div class="line">select....LOCK IN SHARE MODE//对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加上X锁则会被阻塞。</div></pre></td></tr></table></figure></p>
<p>必须在一个事务中，如果事务提交，锁也就释放了。</p>
<h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><ol>
<li>外键<ul>
<li>对于外键列，如果没有显示地给这个列加索引，<strong>则InnoDB存储引擎自动对其加一个索引，因为这样可以避免默认使用表级锁的情况（在博文InnoDB行锁实现方式一小节提到）</strong></li>
<li>对于外键的插入或更新，首先需要查询父表中的记录，对于父表的SELECT操作，不是采用一致性非锁定读的方式，因为这样会发生数据不一致问题。使用的是Select … lock in share mode方式，即主动对父表加一个S锁。</li>
</ul>
</li>
</ol>
<h4 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h4><ol>
<li><p>InnoDB 3种行锁的算法</p>
<ul>
<li>RecordLock: 单个行记录上的锁。总会去锁住索引记录，如果InnoDB在建立的时候没有设置任何一个索引，那么这时，InnoDB存储引擎会使用隐士的主键来锁定<ul>
<li>Gap Lock: 间隙锁，锁定一个范围，但不包含记录本身。目的是为了解决Phantom Problem，即阻止多个事务将记录插入到同一范围内。</li>
</ul>
</li>
<li>Next-Key Lock: Gap Lock+ record Lock,锁定一个范围，并且锁定记录本身。结合了GapLock和RecordLock。在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。例如一个索引有10，11，13，20这四个值，那么该索引可能被Next-Key Locking的区间为： (-8,10)、[10,11)…。</li>
</ul>
</li>
<li><p>Next-Key Lock</p>
<ul>
<li>采用的锁定技术为Next-Key Locking,锁定的不是单个值，而是一个范围，是谓词索引的一种改进。若事务T1已经通过next-key locking锁定了范围：(10,11]、(11,13] 当插入新的记录12时，则锁定的范围会变成:(10,11]、(11,12],(12,13]。 然而当查询的索引含有<strong>唯一属性</strong>时，InnoDB会对Next-Key Lock进行优化降级为Record Lock，即仅仅锁住索引本身，而不是范围。</li>
</ul>
</li>
<li>解决Phantom Problem<ul>
<li><strong>Phantom Problem定义：</strong> 是指在同一事务下，连续执行俩次同样的SQL语句可能导致不同的结果，第二次执行的SQL语句可能会返回之前不存在的行。</li>
<li><strong>在默认的事务隔离级别下，即REPEATABLE READ下</strong>，InnoDB存储引擎采用Next-Key Locking机制来避免幻象问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">举例说明：表t由1，2，5三个值组成，事务T1执行：select * from t where a&gt;2 for update;</div><div class="line">这时，T1并没有提交操作，此时结果返回5，与此同时，另一个事务T2插入了4这个值，在执行一遍sql</div><div class="line">会返回4，5，即俩次的结果不一致。InnoDB的next-key locking算法避免Phantom Problem,是对（2，+8）这个范围加了X锁，因此对于任何这个范围插入的操作都是不被允许的。</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h4><ol>
<li>脏读<ul>
<li>脏数据和脏页的关系：脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘的页的数据是不一致的。当然在刷新到磁盘之前，日志都已经被写入到了重做日志文件中，而脏数据是指<strong>事务对缓冲池中的行记录的修改，并且还没有被提交。</strong> 一个事务可以读到另一个事务中为提交的数据，这显然违反了数据库的个隔离性。</li>
</ul>
</li>
<li><p>不可重复读</p>
<ul>
<li>重点在于修改。是指在一个事务内多次读取同一数据集合，在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作，因此在第一个事务中的俩次读数据之间，由于第二个事务的修改，导致俩次读取到的结果集合可能出现不一致的情况。</li>
<li>不可重复读和脏读的区别是，脏读是读到未提交的数据，而不可重复读读到的却是已经提及的数据，但是其违反了数据库事务一致性的要求。</li>
<li>一般来说不可重复读还是可以接受的，不少数据库厂商（Oracle、MicroSoft SQL SERVER）将其数据库事务的默认隔离级别设置为Read COMMITTED</li>
</ul>
</li>
<li><p>幻读</p>
<ul>
<li>重点在于新增或删除。当事务不是独立执行时发生的一种现象，第一个事务对一个表中的数据进行了修改，涉及到全部的数据行。同时第二个事务也修改了这个表中的数据，这种修改是向表中插入一行新数据。那么之后第一个事务重新读取数据的时候就会出现幻读的情况</li>
</ul>
</li>
<li><p>丢失更新</p>
<ul>
<li>丢失更新是另一个锁导致的问题，简单来说就是一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致。<ul>
<li>1）事务T1将行记录r更新为v1,但是事务T1并未提交</li>
<li>2）与此同时事务T2将行记录更新为V2，事务T2未提交</li>
<li>3）事务T1提交</li>
<li>4）事务T2提交</li>
</ul>
</li>
</ul>
<p>但是在任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题。但是生产应用中还有一种逻辑意义的丢失更新，而导致该问题的并不是因为数据库本身的问题。</p>
<ul>
<li><p>实际上，在所有多用户计算机系统环境下都有可能产生这个问题：</p>
<ul>
<li>1) 事务T1查询一行数据，放入本地内存，并显示给一个终端用户User1</li>
<li>2) 事务T2也查询该行数据，放入本地内存，并显示给一个终端用户User2</li>
<li>3) user1修改该行记录，更新数据库并提交</li>
<li>4) User2也修改该行记录，更新数据库并提交</li>
</ul>
<p>要避免丢失更新的发生，就需要让事务在这种情况下的<strong>操作变成串行化，而不是并行操作</strong>。于是在步骤一的过程中，用户读取数据加上一个排他锁，这样用户2读取的时候也必须加上排他锁，否则就等待锁的释放。</p>
</li>
</ul>
</li>
<li>阻塞<ul>
<li>因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。阻塞不是一件坏事，是为了确保事务可以并发且正常地运行。</li>
<li>在InnoDB中，参数 <strong>innodb_lock_wait_timeout</strong>用来控制等待的时间<strong>（默认是50秒）</strong>，innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作，默认不回滚。可以通过代码调整： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set @@innodb_lock_wait_time=60</div><div class="line">innodb_rollback_on_timeout是静态的，不可在启动时进行修改。</div><div class="line">默认情况下，innoDB存储引擎不会回滚超时引发的错误异常，其实InnoDB存储引擎在大部分情况下，都不会对异常进行回滚。</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ol>
<li>死锁的概念</li>
<li>死锁的概率</li>
<li>死锁的示例</li>
<li>锁升级</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> InnoDB </tag>
            
            <tag> mysql </tag>
            
            <tag> 成长 </tag>
            
            <tag> 读书 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring源码解析--事务处理]]></title>
      <url>/2017/02/12/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="事务处理相关类的层次结构"><a href="#事务处理相关类的层次结构" class="headerlink" title="事务处理相关类的层次结构"></a>事务处理相关类的层次结构</h3><p><img src="http://ol7zjjc80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-11%20%E4%B8%8B%E5%8D%887.54.25.png" alt="事务处理相关类的层次结构"></p>
<p>在 Spring事务处理中，可以通过设计一个TransactionProxyFactoryBean来使用AOP功能，通过它可以生成Proxy代理对象。在代理对象中，通过TranscationInterceptor来完成对代理对象方法的拦截。实现声明式事务处理时，是AOP和IOC集成的部分，而对于具体的事物处理实现，是通过设计PlatformTransactionManager，AbstractPlatforTransactionmanager以及一系列具体事务处理器来实现的。PlatformTransactionManager又实现了TransactionInterceptor，这样就能将一系列处理给串联起来。</p>
<h3 id="Spring声明式事务处理"><a href="#Spring声明式事务处理" class="headerlink" title="Spring声明式事务处理"></a>Spring声明式事务处理</h3><h4 id="设计原理与过程"><a href="#设计原理与过程" class="headerlink" title="设计原理与过程"></a>设计原理与过程</h4><p>在实现声明式的事务处理时，常用的方式是结合IOC容器和Spring已有的TransactionProxyFactoryBean对事务管理进行配置，实现可分为以下几个步骤：</p>
<ul>
<li>读取和处理在IOC容器中配置的事务处理属性，并转化为Spring事务处理需要的内部数据结构。</li>
<li>Spring事务处理模块实现统一的事务处理过程。</li>
<li>底层的事务处理实现。Spring委托给具体的事务处理器来完成。</li>
</ul>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-11%20%E4%B8%8B%E5%8D%888.23.09.png" alt="建立事务处理对象时序图"></p>
<p>从TransactionProxyFactoryBean入手，通过代码来了解Spring是如何通过AOP功能来完成事务管理配置的，从图中可以看到Spring为声明式事务处理的实现所做的一些准备工作：包括为AOP配置基础设施，这些基础设施包括设置拦截器TransactionInterceptor、通过DefaultPointcutAdvisor或TransactionAttributeSourceAdvisor。同时，在TransactionProxyFactoryBean的实现中，还可以看到注入进来的PlatformTransactionManager和事务处理属性TransactionAttribute等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TransactionProxyFactoryBean extends AbstractSingletonProxyFactoryBean implements BeanFactoryAware &#123;</div><div class="line">  private final TransactionInterceptor transactionInterceptor = new TransactionInterceptor();／／这个拦截器通过AOP发挥作用，通过这个拦截器的实现，Spring封装了事务处理实现</div><div class="line">  private Pointcut pointcut;</div><div class="line"></div><div class="line">  public TransactionProxyFactoryBean() &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;</div><div class="line">    this.transactionInterceptor.setTransactionManager(transactionManager);</div><div class="line">  &#125;</div><div class="line">  //通过依赖注入的事务属性以Properties的形式出现，把BeanDefinition中读到的事务管理的属性信息注入到TransactionInterceptor中</div><div class="line">  public void setTransactionAttributes(Properties transactionAttributes) &#123;</div><div class="line">    this.transactionInterceptor.setTransactionAttributes(transactionAttributes);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) &#123;</div><div class="line">    this.transactionInterceptor.setTransactionAttributeSource(transactionAttributeSource);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setPointcut(Pointcut pointcut) &#123;</div><div class="line">    this.pointcut = pointcut;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void setBeanFactory(BeanFactory beanFactory) &#123;</div><div class="line">    this.transactionInterceptor.setBeanFactory(beanFactory);</div><div class="line">  &#125;</div><div class="line">//这里创建Spring  AOP对事务处理的Advisor</div><div class="line">  protected Object createMainInterceptor() &#123;</div><div class="line">    this.transactionInterceptor.afterPropertiesSet();//事务处理完成AOP配置的地方</div><div class="line">    return this.pointcut != null?new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor):new TransactionAttributeSourceAdvisor(this.transactionInterceptor);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  protected void postProcessProxyFactory(ProxyFactory proxyFactory) &#123;</div><div class="line">    proxyFactory.addInterface(TransactionalProxy.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成了AOP配置，Spring的TransactionInterceptor配置是IOC容器完成Bean的依赖注入时，通过initializeBean方法被调用。</p>
<p>   在建立TransactionProxyFactoryBean的事务处理拦截器的时候， afterPropertiesSet方法首先对 ProxyFactoryBean的目标Bean设置进行检查，如果这个目标Bean的设置是正确的，就会创建ProxyFactory对象，从而实现AOP的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void afterPropertiesSet() &#123;</div><div class="line">  if(this.getTransactionManager() == null &amp;&amp; this.beanFactory == null) &#123;</div><div class="line">    throw new IllegalStateException(&quot;Set the \&apos;transactionManager\&apos; property or make sure to run within a BeanFactory containing a PlatformTransactionManager bean!&quot;);</div><div class="line">  &#125; else if(this.getTransactionAttributeSource() == null) &#123;</div><div class="line">    throw new IllegalStateException(&quot;Either \&apos;transactionAttributeSource\&apos; or \&apos;transactionAttributes\&apos; is required: If there are no transactional methods, then don\&apos;t use a transaction aspect.&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事务处理配置的读入"><a href="#事务处理配置的读入" class="headerlink" title="事务处理配置的读入"></a>事务处理配置的读入</h4><p>在AOP配置完成的基础上，以TransactionAttributeSourceAdvisor的实现为入口，了解具体的事务属性配置是如何读入的，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private TransactionInterceptor transactionInterceptor;／／同样需要AOP中用到的Interceptro和Pointcut，通过内部类，调用TransactionInterceptor来得到事务的配置属性，在对Proxy的方法进行匹配调用时，会使用到这些配置属性。</div><div class="line">private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() &#123;</div><div class="line">  protected TransactionAttributeSource getTransactionAttributeSource() &#123;</div><div class="line">    return TransactionAttributeSourceAdvisor.this.transactionInterceptor != null?TransactionAttributeSourceAdvisor.this.transactionInterceptor.getTransactionAttributeSource():null;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在声明式事务处理中，通过对目标对象的方法调用进行拦截实现，这个拦截通过AOP发挥作用。在AOP中，对于拦截的启动，首先需要对方法调用是否需要拦截进行判断，依据时那些在TransactionProxyFactoryBean中为目标对象设置的事务属性。这个匹配判断在TransactionAttributeSourcePointcut中完成。实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123;</div><div class="line">  if(TransactionalProxy.class.isAssignableFrom(targetClass)) &#123;</div><div class="line">    return false;</div><div class="line">  &#125; else &#123;</div><div class="line">    TransactionAttributeSource tas = this.getTransactionAttributeSource();</div><div class="line">    return tas == null || tas.getTransactionAttribute(method, targetClass) != null;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在方法中，首先把事务方法的属性配置读取到TransactionAttributeSource对象中，有了这些事务处理的配置以后，根据当前方法调用的method对象和目标对象，对是否需要启动事务处理拦截器进行判断。</p>
<p>在Pointcut的matches判断过程中，会用到transactionAttributeSource对象，这个transactionAttributeSource对象是在对TransactionInterceptor进行依赖注入时就配置好的，它的设置是在TransactionInterceptor的基类TransactionAspectSupport中完成的。配置的是一个NameMatchTransactionAttributeSouce对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void setTransactionAttributes(Properties transactionAttributes) &#123;</div><div class="line">  NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();</div><div class="line">  tas.setProperties(transactionAttributes);</div><div class="line">  this.transactionAttributeSource = tas;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可知，NameMatchTransactionAttributeSouce作为TransacionAttributeSource的具体实现，是实际完成事务处理属性读入和匹配的地方。对于NameMatchTransactionAttributeSouce是怎样实现事务处理属性的读入和匹配的，可看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public void setProperties(Properties transactionAttributes) &#123;//设置配置的事务方法</div><div class="line">  TransactionAttributeEditor tae = new TransactionAttributeEditor();</div><div class="line">  Enumeration propNames = transactionAttributes.propertyNames();</div><div class="line"></div><div class="line">  while(propNames.hasMoreElements()) &#123;</div><div class="line">    String methodName = (String)propNames.nextElement();</div><div class="line">    String value = transactionAttributes.getProperty(methodName);</div><div class="line">    tae.setAsText(value);</div><div class="line">    TransactionAttribute attr = (TransactionAttribute)tae.getValue();</div><div class="line">    this.addTransactionalMethod(methodName, attr);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">private Map&lt;String, TransactionAttribute&gt; nameMap = new HashMap();</div><div class="line"></div><div class="line"></div><div class="line">public void addTransactionalMethod(String methodName, TransactionAttribute attr) &#123;</div><div class="line">  if(logger.isDebugEnabled()) &#123;</div><div class="line">    logger.debug(&quot;Adding transactional method [&quot; + methodName + &quot;] with attribute [&quot; + attr + &quot;]&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  this.nameMap.put(methodName, attr);</div><div class="line">&#125;</div><div class="line">／／对调用的方法进行判断，判断它是否是事务方法，如果是，那么取出相应的事务配置属性</div><div class="line">public TransactionAttribute getTransactionAttribute(Method method, Class&lt;?&gt; targetClass) &#123;</div><div class="line">  if(!ClassUtils.isUserLevelMethod(method)) &#123;</div><div class="line">    return null;</div><div class="line">  &#125; else &#123;</div><div class="line">    String methodName = method.getName();／／判断当前目标调用的方法与配置的事务方法是否直接匹配</div><div class="line">    TransactionAttribute attr = (TransactionAttribute)this.nameMap.get(methodName);</div><div class="line">    if(attr == null) &#123;//如果不能直接匹配，就通过调用PatternMatchUtils的simpleMatch方法来进行匹配判断。</div><div class="line">      String bestNameMatch = null;</div><div class="line">      Iterator var6 = this.nameMap.keySet().iterator();</div><div class="line"></div><div class="line">      while(true) &#123;</div><div class="line">        String mappedName;</div><div class="line">        do &#123;</div><div class="line">          do &#123;</div><div class="line">            if(!var6.hasNext()) &#123;</div><div class="line">              return attr;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mappedName = (String)var6.next();</div><div class="line">          &#125; while(!this.isMatch(methodName, mappedName));</div><div class="line">        &#125; while(bestNameMatch != null &amp;&amp; bestNameMatch.length() &gt; mappedName.length());</div><div class="line"></div><div class="line">        attr = (TransactionAttribute)this.nameMap.get(mappedName);</div><div class="line">        bestNameMatch = mappedName;</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      return attr;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">／／事务方法的匹配判断，详细的匹配过程在PatternMatchUtils中实现</div><div class="line">protected boolean isMatch(String methodName, String mappedName) &#123;</div><div class="line">  return PatternMatchUtils.simpleMatch(mappedName, methodName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事务处理拦截器的设计与实现："><a href="#事务处理拦截器的设计与实现：" class="headerlink" title="事务处理拦截器的设计与实现："></a>事务处理拦截器的设计与实现：</h4><p>经过TransactionProxyFactoryBean的AOP包装，此时如果对目标对象进行方法调用，起作用的对象实际傻姑娘是一个Proxy代理对象。对目标对象方法的调用，不会直接作用在TransactionProxyFactoryBean设置的目标对象上。而是会被设置的事务处理器拦截。而在TransactionProxyFactoryBean的AOP实现中，获取Proxy对象的过程并不复杂，TransactionProxyFactoryBean作为一个FactoryBean，对Bean对象的引用通过getObejct方法来得到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public Object getObject() &#123; ／／TransactionProxyFactoryBean 的父类 AbstractSingletonProxyFactoryBean中</div><div class="line">／／返回的是一个Proxy，是ProxyFactory生成的AOP代理，已经封装了对事务处理的拦截器设置</div><div class="line">  if(this.proxy == null) &#123;</div><div class="line">    throw new FactoryBeanNotInitializedException();</div><div class="line">  &#125; else &#123;</div><div class="line">    return this.proxy;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于AOP代理对象的作用方法入口，我们一般都知道invoke方法，这个invke方法在事务处理拦截器TransactionInterceptor中，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</div><div class="line">  Class targetClass = invocation.getThis() != null?AopUtils.getTargetClass(invocation.getThis()):null;</div><div class="line">  return this.invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123;</div><div class="line">    public Object proceedWithInvocation() throws Throwable &#123;</div><div class="line">      return invocation.proceed();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final TransactionAspectSupport.InvocationCallback invocation) throws Throwable &#123;</div><div class="line">  final TransactionAttribute txAttr = this.getTransactionAttributeSource().getTransactionAttribute(method, targetClass);／／这里读取事务的属性配置，通过TransactionAttributeSource对象取得</div><div class="line">  final PlatformTransactionManager tm = this.determineTransactionManager(txAttr);／／根据TransactionProxyFactoryBean的配置信息获得具体的事务处理器</div><div class="line">  final String joinpointIdentification = this.methodIdentification(method, targetClass, txAttr);</div><div class="line">  if(txAttr != null &amp;&amp; tm instanceof CallbackPreferringPlatformTransactionManager) &#123;</div><div class="line">    try &#123;</div><div class="line">      Object ex1 = ((CallbackPreferringPlatformTransactionManager)tm).execute(txAttr, new TransactionCallback() &#123;</div><div class="line">        public Object doInTransaction(TransactionStatus status) &#123;</div><div class="line">          TransactionAspectSupport.TransactionInfo txInfo = TransactionAspectSupport.this.prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);／／创建事务，同时把事务过程中得到的信息放到TransactionInfo中去，TransactionInfo是保存当前事务状态的对象。</div><div class="line"></div><div class="line">          TransactionAspectSupport.ThrowableHolder var4;</div><div class="line">          try &#123;</div><div class="line">            Object ex = invocation.proceedWithInvocation();</div><div class="line">            return ex;</div><div class="line">          &#125; catch (Throwable var8) &#123;</div><div class="line">            if(txAttr.rollbackOn(var8)) &#123;</div><div class="line">              if(var8 instanceof RuntimeException) &#123;</div><div class="line">                throw (RuntimeException)var8;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              throw new TransactionAspectSupport.ThrowableHolderException(var8);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            var4 = new TransactionAspectSupport.ThrowableHolder(var8);</div><div class="line">          &#125; finally &#123;</div><div class="line">            TransactionAspectSupport.this.cleanupTransactionInfo(txInfo);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          return var4;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">      if(ex1 instanceof TransactionAspectSupport.ThrowableHolder) &#123;</div><div class="line">        throw ((TransactionAspectSupport.ThrowableHolder)ex1).getThrowable();</div><div class="line">      &#125; else &#123;</div><div class="line">        return ex1;</div><div class="line">      &#125;</div><div class="line">    &#125; catch (TransactionAspectSupport.ThrowableHolderException var14) &#123;</div><div class="line">      throw var14.getCause();</div><div class="line">    &#125;</div><div class="line">  &#125; else &#123;</div><div class="line">    TransactionAspectSupport.TransactionInfo ex = this.createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</div><div class="line">    Object retVal = null;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">      retVal = invocation.proceedWithInvocation();／／这里的调用使处理沿着拦截器链进行，使最后目标对象的方法得到调用</div><div class="line">    &#125; catch (Throwable var15) &#123;</div><div class="line">      this.completeTransactionAfterThrowing(ex, var15);／／如果事务处理方法中调用出现了异常，事务处理如何进行需要根据具体情况考虑是否会滚或者提交</div><div class="line">      throw var15;</div><div class="line">    &#125; finally &#123;</div><div class="line">      this.cleanupTransactionInfo(ex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.commitTransactionAfterReturning(ex);//这里通过事务处理器来对事务进行提交</div><div class="line">    return retVal;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于Spring而言，事务管理实际上是通过一个TransactionInfo对象来完成的，在该对象中，封装了事务对象和事务处理的状态信息，这是事务处理的抽象。在这一步完成以后，会对拦截器链进行处理，因为有可能在该事务对象中还配置了除事务处理AOP之外的其他拦截器，在结束对拦截器链处理之后，会对 TransactionInfo中的信息进行更新，以反映最近的事务处理情况，在这个时候，也就完成了事务提交的准备，通过调用事务处理器PlatformTransactionManager的commitTransactionAfterReturning方法来完成事务的提交。这个提交的处理过程已经封装在事务处理器中了，而与具体数据源相关的处理过程，最终委托给相关的事务处理器完成，如：DataSourceTransactionManager、HibernateTransactionManager等。</p>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-11%20%E4%B8%8B%E5%8D%8810.51.15.png" alt="事务提交时序图"></p>
<p>这个invoke方法的实现中，可以看到整个事务处理在AOP拦截器中实现的全过程。同时，它也是Spring采用AOP封装事务处理和实现声明式事务处理的核心部分。</p>
<h3 id="Spring事务处理的设计与实现"><a href="#Spring事务处理的设计与实现" class="headerlink" title="Spring事务处理的设计与实现"></a>Spring事务处理的设计与实现</h3><h4 id="Spring事务传播属性"><a href="#Spring事务传播属性" class="headerlink" title="Spring事务传播属性"></a>Spring事务传播属性</h4><blockquote>
<p>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。<br>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。  PROPAGATION_NESTED –<br>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。<br>前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。</p>
</blockquote>
<h4 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h4><p>声明式事务中，TransactionInterceptor拦截器的invoke方法作为事务处理实现的起点，invoke方法中createTransactionIfNeccessary方法作为事务创建的入口。以下是createTransactionIfNeccessary方法的时序图</p>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-11%20%E4%B8%8B%E5%8D%8811.09.41.png" alt="createTransactionIfNeccessary方法的时序图"></p>
<p>在createTransactionIfNeccessary中首先会向AbstractTransactionManager执行getTransaction，这个获取Transaction事务对象的过程，在AbstractTransactionManager中需要对事务不同的情况作出处理，然后创建一个TransactionStatus，并把这个TransactionStatus设置到对应的TransactionInfo中去，同时将TransactionInfo和当前的线程绑定，从而完成事务的创建过程。TransactionStatus和TransactionInfo这俩个对象持有的数据是事务处理器对事务进行处理的主要依据。对这俩个对象的使用贯穿整个事务处理的全过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">protected TransactionAspectSupport.TransactionInfo createTransactionIfNecessary(PlatformTransactionManager tm, final TransactionAttribute txAttr, final String joinpointIdentification) &#123;</div><div class="line">  if(txAttr != null &amp;&amp; ((TransactionAttribute)txAttr).getName() == null) &#123;</div><div class="line">    txAttr = new DelegatingTransactionAttribute((TransactionAttribute)txAttr) &#123;</div><div class="line">      public String getName() &#123;</div><div class="line">        return joinpointIdentification;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  TransactionStatus status = null;</div><div class="line">  if(txAttr != null) &#123;</div><div class="line">    if(tm != null) &#123;</div><div class="line">      status = tm.getTransaction((TransactionDefinition)txAttr);／／这里使用了定义好的事务方法的配置信息。事务创建由事务处理器来完成，同时返回TransactionStatus来记录当前的事务状态，包括已经创建的事务。</div><div class="line">    &#125; else if(this.logger.isDebugEnabled()) &#123;</div><div class="line">      this.logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification + &quot;] because no transaction manager has been configured&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return this.prepareTransactionInfo(tm, (TransactionAttribute)txAttr, joinpointIdentification, status);</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected TransactionAspectSupport.TransactionInfo prepareTransactionInfo(PlatformTransactionManager tm, TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) &#123;</div><div class="line">  TransactionAspectSupport.TransactionInfo txInfo = new TransactionAspectSupport.TransactionInfo(tm, txAttr, joinpointIdentification);</div><div class="line">  if(txAttr != null) &#123;</div><div class="line">    if(this.logger.isTraceEnabled()) &#123;</div><div class="line">      this.logger.trace(&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    txInfo.newTransactionStatus(status);</div><div class="line">  &#125; else if(this.logger.isTraceEnabled()) &#123;</div><div class="line">    this.logger.trace(&quot;Don\&apos;t need to create transaction for [&quot; + joinpointIdentification + &quot;]: This method isn\&apos;t transactional.&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  txInfo.bindToThread();</div><div class="line">  return txInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getTansaction实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException &#123;</div><div class="line">       Object transaction = doGetTransaction();</div><div class="line"></div><div class="line">       // Cache debug flag to avoid repeated checks.</div><div class="line">       boolean debugEnabled = logger.isDebugEnabled();</div><div class="line"></div><div class="line">       if (definition == null) &#123;</div><div class="line">              // Use defaults if no transaction definition given.</div><div class="line">              definition = new DefaultTransactionDefinition();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (isExistingTransaction(transaction)) &#123;</div><div class="line">              // Existing transaction found -&gt; check propagation behavior to find out how to behave.</div><div class="line">              return handleExistingTransaction(definition, transaction, debugEnabled);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Check definition settings for new transaction.</div><div class="line">       if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</div><div class="line">              throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());</div><div class="line">       &#125;</div><div class="line">／／没有事务存在，需要根据事务传播属性设置来创建事务，这里会看到事务传播属性的设置：mandatory、required required_new nested等</div><div class="line">       // No existing transaction found -&gt; check propagation behavior to find out how to proceed.</div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</div><div class="line">              throw new IllegalTransactionStateException(</div><div class="line">                            &quot;No existing transaction found for transaction marked with propagation &apos;mandatory&apos;&quot;);</div><div class="line">       &#125;</div><div class="line">       else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</div><div class="line">                     definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</div><div class="line">                     definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</div><div class="line">              SuspendedResourcesHolder suspendedResources = suspend(null);</div><div class="line">              if (debugEnabled) &#123;</div><div class="line">                     logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);</div><div class="line">              &#125;</div><div class="line">              try &#123;</div><div class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">                     DefaultTransactionStatus status = newTransactionStatus(</div><div class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</div><div class="line">                     doBegin(transaction, definition);</div><div class="line">                     prepareSynchronization(status, definition);</div><div class="line">                     return status;</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException ex) &#123;</div><div class="line">                     resume(null, suspendedResources);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (Error err) &#123;</div><div class="line">                     resume(null, suspendedResources);</div><div class="line">                     throw err;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line">       else &#123;</div><div class="line">              // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</div><div class="line">              if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</div><div class="line">                     logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +</div><div class="line">                                   &quot;isolation level will effectively be ignored: &quot; + definition);</div><div class="line">              &#125;</div><div class="line">              boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</div><div class="line">              return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handleExsitingTransaction方法是理解Spring事务传播属性的关键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Create a TransactionStatus for an existing transaction.</div><div class="line">*/</div><div class="line">private TransactionStatus handleExistingTransaction(</div><div class="line">              TransactionDefinition definition, Object transaction, boolean debugEnabled)</div><div class="line">              throws TransactionException &#123;</div><div class="line"></div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</div><div class="line">              throw new IllegalTransactionStateException(</div><div class="line">                            &quot;Existing transaction found for transaction marked with propagation &apos;never&apos;&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</div><div class="line">              if (debugEnabled) &#123;</div><div class="line">                     logger.debug(&quot;Suspending current transaction&quot;);</div><div class="line">              &#125;</div><div class="line">              Object suspendedResources = suspend(transaction);</div><div class="line">              boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</div><div class="line">              return prepareTransactionStatus(</div><div class="line">                            definition, null, false, newSynchronization, debugEnabled, suspendedResources);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</div><div class="line">              if (debugEnabled) &#123;</div><div class="line">                     logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; +</div><div class="line">                                   definition.getName() + &quot;]&quot;);</div><div class="line">              &#125;</div><div class="line">              SuspendedResourcesHolder suspendedResources = suspend(transaction);</div><div class="line">              try &#123;</div><div class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">                     DefaultTransactionStatus status = newTransactionStatus(</div><div class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</div><div class="line">                     doBegin(transaction, definition);</div><div class="line">                     prepareSynchronization(status, definition);</div><div class="line">                     return status;</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException beginEx) &#123;</div><div class="line">                     resumeAfterBeginException(transaction, suspendedResources, beginEx);</div><div class="line">                     throw beginEx;</div><div class="line">              &#125;</div><div class="line">              catch (Error beginErr) &#123;</div><div class="line">                     resumeAfterBeginException(transaction, suspendedResources, beginErr);</div><div class="line">                     throw beginErr;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</div><div class="line">              if (!isNestedTransactionAllowed()) &#123;</div><div class="line">                     throw new NestedTransactionNotSupportedException(</div><div class="line">                                   &quot;Transaction manager does not allow nested transactions by default - &quot; +</div><div class="line">                                   &quot;specify &apos;nestedTransactionAllowed&apos; property with value &apos;true&apos;&quot;);</div><div class="line">              &#125;</div><div class="line">              if (debugEnabled) &#123;</div><div class="line">                     logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;);</div><div class="line">              &#125;</div><div class="line">              if (useSavepointForNestedTransaction()) &#123;／／在Spring管理的事务中，创建事务保存点</div><div class="line">                     // Create savepoint within existing Spring-managed transaction,</div><div class="line">                     // through the SavepointManager API implemented by TransactionStatus.</div><div class="line">                     // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</div><div class="line">                     DefaultTransactionStatus status =</div><div class="line">                                   prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);</div><div class="line">                     status.createAndHoldSavepoint();</div><div class="line">                     return status;</div><div class="line">              &#125;</div><div class="line">              else &#123;</div><div class="line">                     // Nested transaction through nested begin and commit/rollback calls.</div><div class="line">                     // Usually only for JTA: Spring synchronization might get activated here</div><div class="line">                     // in case of a pre-existing JTA transaction.</div><div class="line">                     boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">                     DefaultTransactionStatus status = newTransactionStatus(</div><div class="line">                                   definition, transaction, true, newSynchronization, debugEnabled, null);</div><div class="line">                     doBegin(transaction, definition);</div><div class="line">                     prepareSynchronization(status, definition);</div><div class="line">                     return status;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</div><div class="line">       if (debugEnabled) &#123;</div><div class="line">              logger.debug(&quot;Participating in existing transaction&quot;);</div><div class="line">       &#125;</div><div class="line">       if (isValidateExistingTransaction()) &#123;</div><div class="line">              if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</div><div class="line">                     Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</div><div class="line">                     if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) &#123;</div><div class="line">                            Constants isoConstants = DefaultTransactionDefinition.constants;</div><div class="line">                            throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</div><div class="line">                                          definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; +</div><div class="line">                                          (currentIsolationLevel != null ?</div><div class="line">                                                        isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</div><div class="line">                                                        &quot;(unknown)&quot;));</div><div class="line">                     &#125;</div><div class="line">              &#125;</div><div class="line">              if (!definition.isReadOnly()) &#123;</div><div class="line">                     if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</div><div class="line">                            throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</div><div class="line">                                          definition + &quot;] is not marked as read-only but existing transaction is&quot;);</div><div class="line">                     &#125;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line">       boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</div><div class="line">       return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事务挂起"><a href="#事务挂起" class="headerlink" title="事务挂起"></a>事务挂起</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException &#123;／／返回的SuspendedResourcesHolder会作为参数传给TransactionStatus</div><div class="line">       if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</div><div class="line">              List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</div><div class="line">              try &#123;</div><div class="line">                     Object suspendedResources = null;／／把挂起事务的处理交给具体事务处理器去完成，如果具体的事务处理器不支持事务挂起，则默认抛出TransactionSuspensionNotSupportedException</div><div class="line">                     if (transaction != null) &#123;</div><div class="line">                            suspendedResources = doSuspend(transaction);</div><div class="line">                     &#125;//这里在线程中保存与事务处理有关的信息，并重置线程中相关的ThreadLocal变量</div><div class="line">                     String name = TransactionSynchronizationManager.getCurrentTransactionName();</div><div class="line">                     TransactionSynchronizationManager.setCurrentTransactionName(null);</div><div class="line">                     boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</div><div class="line">                     TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);</div><div class="line">                     Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</div><div class="line">                     TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);</div><div class="line">                     boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();</div><div class="line">                     TransactionSynchronizationManager.setActualTransactionActive(false);</div><div class="line">                     return new SuspendedResourcesHolder(</div><div class="line">                                   suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException ex) &#123;</div><div class="line">                     // doSuspend failed - original transaction is still active… 如果处理失败，则恢复原始的事务</div><div class="line">                     doResumeSynchronization(suspendedSynchronizations);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (Error err) &#123;</div><div class="line">                     // doSuspend failed - original transaction is still active...</div><div class="line">                     doResumeSynchronization(suspendedSynchronizations);</div><div class="line">                     throw err;</div><div class="line">              &#125;</div><div class="line">       &#125;</div><div class="line">       else if (transaction != null) &#123;</div><div class="line">              // Transaction active but no synchronization active.</div><div class="line">              Object suspendedResources = doSuspend(transaction);</div><div class="line">              return new SuspendedResourcesHolder(suspendedResources);</div><div class="line">       &#125;</div><div class="line">       else &#123;</div><div class="line">              // Neither transaction nor synchronization active.</div><div class="line">              return null;</div><div class="line">       &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Reactivate transaction synchronization for the current thread</div><div class="line"> * and resume all given synchronizations.</div><div class="line"> * @param suspendedSynchronizations List of TransactionSynchronization objects</div><div class="line"> */doSuspend 失败则恢复事务</div><div class="line">private void doResumeSynchronization(List&lt;TransactionSynchronization&gt; suspendedSynchronizations) &#123;</div><div class="line">       TransactionSynchronizationManager.initSynchronization();／／维护着ThreadLocal变量</div><div class="line">       for (TransactionSynchronization synchronization : suspendedSynchronizations) &#123;</div><div class="line">              synchronization.resume();</div><div class="line">              TransactionSynchronizationManager.registerSynchronization(synchronization);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事务的提交"><a href="#事务的提交" class="headerlink" title="事务的提交"></a>事务的提交</h4><p>在声明式事务处理中，事务的提交在TransactionInteceptor的invoke方法中实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">commitTransactionAfterReturning(txInfo)</div></pre></td></tr></table></figure></p>
<p>txInfo是TransactionInfo对象，是创建事务时生成的。同时，Spring的事务管理框架的生成的TransactionStatus对象就包含在TransactionInfo对象中。commitTransactionAfterReturning具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected void commitTransactionAfterReturning(TransactionAspectSupport.TransactionInfo txInfo) &#123;</div><div class="line">  if(txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;</div><div class="line">    if(this.logger.isTraceEnabled()) &#123;</div><div class="line">      this.logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用具体的事务管理器实现。而在事务管理器中的实现在AbstractPlatformTransactionManager中存在一个模版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* This implementation of commit handles participating in existing</div><div class="line">* transactions and programmatic rollback requests.</div><div class="line">* Delegates to &#123;@code isRollbackOnly&#125;, &#123;@code doCommit&#125;</div><div class="line">* and &#123;@code rollback&#125;.</div><div class="line">* @see org.springframework.transaction.TransactionStatus#isRollbackOnly()</div><div class="line">* @see #doCommit</div><div class="line">* @see #rollback</div><div class="line">*/</div><div class="line">@Override</div><div class="line">public final void commit(TransactionStatus status) throws TransactionException &#123;</div><div class="line">       if (status.isCompleted()) &#123;</div><div class="line">              throw new IllegalTransactionStateException(</div><div class="line">                            &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</div><div class="line">       if (defStatus.isLocalRollbackOnly()) &#123;／／如果事务处理过程中发生了异常，调用回滚。</div><div class="line">              if (defStatus.isDebug()) &#123;</div><div class="line">                     logger.debug(&quot;Transactional code has requested rollback&quot;);</div><div class="line">              &#125;</div><div class="line">              processRollback(defStatus);</div><div class="line">              return;</div><div class="line">       &#125;</div><div class="line">       if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</div><div class="line">              if (defStatus.isDebug()) &#123;</div><div class="line">                     logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);</div><div class="line">              &#125;／／处理回滚</div><div class="line">              processRollback(defStatus);</div><div class="line">              // Throw UnexpectedRollbackException only at outermost transaction boundary</div><div class="line">              // or if explicitly asked to.</div><div class="line">              if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</div><div class="line">                     throw new UnexpectedRollbackException(</div><div class="line">                                   &quot;Transaction rolled back because it has been marked as rollback-only&quot;);</div><div class="line">              &#125;</div><div class="line">              return;</div><div class="line">       &#125;</div><div class="line">       ／／处理提交入口</div><div class="line">       processCommit(defStatus);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出rollback和commit都在这个方法中实现。看看 processCommit的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;</div><div class="line">       try &#123;</div><div class="line">              boolean beforeCompletionInvoked = false;</div><div class="line">              try &#123;／／事务的提交准备工作由具体的事务处理器来完成</div><div class="line">                     prepareForCommit(status);</div><div class="line">                     triggerBeforeCommit(status);</div><div class="line">                     triggerBeforeCompletion(status);</div><div class="line">                     beforeCompletionInvoked = true;</div><div class="line">                     boolean globalRollbackOnly = false;</div><div class="line">                     if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</div><div class="line">                            globalRollbackOnly = status.isGlobalRollbackOnly();</div><div class="line">                     &#125;／／嵌套事务的处理过程。</div><div class="line">                     if (status.hasSavepoint()) &#123;</div><div class="line">                            if (status.isDebug()) &#123;</div><div class="line">                                   logger.debug(&quot;Releasing transaction savepoint&quot;);</div><div class="line">                            &#125;</div><div class="line">                            status.releaseHeldSavepoint();</div><div class="line">                     &#125;</div><div class="line">                     else if (status.isNewTransaction()) &#123;／／根据当前线程中保存的事务状态进行处理，如果当前的事务是一个新的事务，调用具体事务处理器的完成提交，如果当前所持有的事务不是一个新事务，则不提交，由已经存在的事务来完成提交</div><div class="line">                            if (status.isDebug()) &#123;</div><div class="line">                                   logger.debug(&quot;Initiating transaction commit&quot;);</div><div class="line">                            &#125;</div><div class="line">                            doCommit(status);</div><div class="line">                     &#125;</div><div class="line">                     // Throw UnexpectedRollbackException if we have a global rollback-only</div><div class="line">                     // marker but still didn&apos;t get a corresponding exception from commit.</div><div class="line">                     if (globalRollbackOnly) &#123;</div><div class="line">                            throw new UnexpectedRollbackException(</div><div class="line">                                          &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);</div><div class="line">                     &#125;</div><div class="line">              &#125;</div><div class="line">              catch (UnexpectedRollbackException ex) &#123;</div><div class="line">                     // can only be caused by doCommit</div><div class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (TransactionException ex) &#123;</div><div class="line">                     // can only be caused by doCommit</div><div class="line">                     if (isRollbackOnCommitFailure()) &#123;</div><div class="line">                            doRollbackOnCommitException(status, ex);</div><div class="line">                     &#125;</div><div class="line">                     else &#123;</div><div class="line">                            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</div><div class="line">                     &#125;</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException ex) &#123;</div><div class="line">                     if (!beforeCompletionInvoked) &#123;</div><div class="line">                            triggerBeforeCompletion(status);</div><div class="line">                     &#125;</div><div class="line">                     doRollbackOnCommitException(status, ex);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (Error err) &#123;</div><div class="line">                     if (!beforeCompletionInvoked) &#123;</div><div class="line">                            triggerBeforeCompletion(status);</div><div class="line">                     &#125;</div><div class="line">                     doRollbackOnCommitException(status, err);</div><div class="line">                     throw err;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              // Trigger afterCommit callbacks, with an exception thrown there</div><div class="line">              // propagated to callers but the transaction still considered as committed.</div><div class="line">              try &#123;</div><div class="line">                     triggerAfterCommit(status);</div><div class="line">              &#125;</div><div class="line">              finally &#123;</div><div class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">       finally &#123;</div><div class="line">              cleanupAfterCompletion(status);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，对事务的提交处理都是紧紧围绕TransactionStatus保存的事务处理相关状态进行判断。具体的提交处理过程都设计成抽象方法，交由具体的事务处理器来完成。</p>
<h4 id="事务的回滚"><a href="#事务的回滚" class="headerlink" title="事务的回滚"></a>事务的回滚</h4><p>在事务的提交方法中看到了事务的回滚入口，即processRollback方法，其实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">private void processRollback(DefaultTransactionStatus status) &#123;</div><div class="line">       try &#123;</div><div class="line">              try &#123;</div><div class="line">                     triggerBeforeCompletion(status);</div><div class="line">                     if (status.hasSavepoint()) &#123;／／嵌套事务的回滚处理</div><div class="line">                            if (status.isDebug()) &#123;</div><div class="line">                                   logger.debug(&quot;Rolling back transaction to savepoint&quot;);</div><div class="line">                            &#125;</div><div class="line">                            status.rollbackToHeldSavepoint();</div><div class="line">                     &#125;／／当前事务调用方法中新建事务的回滚处理</div><div class="line">                     else if (status.isNewTransaction()) &#123;</div><div class="line">                            if (status.isDebug()) &#123;</div><div class="line">                                   logger.debug(&quot;Initiating transaction rollback&quot;);</div><div class="line">                            &#125;</div><div class="line">                            doRollback(status);</div><div class="line">                     &#125;／／如果在当前事务调用方法中没有新建事务的回滚处理</div><div class="line">                     else if (status.hasTransaction()) &#123;</div><div class="line">                            if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</div><div class="line">                                   if (status.isDebug()) &#123;</div><div class="line">                                          logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);</div><div class="line">                                   &#125;</div><div class="line">                                   doSetRollbackOnly(status);</div><div class="line">                            &#125;／／由线程的前一个事务来处理回滚，这里不执行任何操作。</div><div class="line">                            else &#123;</div><div class="line">                                   if (status.isDebug()) &#123;</div><div class="line">                                          logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);</div><div class="line">                                   &#125;</div><div class="line">                            &#125;</div><div class="line">                     &#125;</div><div class="line">                     else &#123;</div><div class="line">                            logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);</div><div class="line">                     &#125;</div><div class="line">              &#125;</div><div class="line">              catch (RuntimeException ex) &#123;</div><div class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</div><div class="line">                     throw ex;</div><div class="line">              &#125;</div><div class="line">              catch (Error err) &#123;</div><div class="line">                     triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</div><div class="line">                     throw err;</div><div class="line">              &#125;</div><div class="line">              triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</div><div class="line">       &#125;</div><div class="line">       finally &#123;</div><div class="line">              cleanupAfterCompletion(status);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，看了代码我们很快就能理解，Spring 事务传播属性中的 Required_New和NESTED（嵌套事务）的本质区别</p>
<ol>
<li>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行. </li>
<li>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,它将取得一个 savepoint. 如果这个嵌套事务失败,我们将回滚到此savepoint潜套事务是外部事务的一部分,只有外部事务结束后它才会被提交。</li>
<li>由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back. </li>
</ol>
<p>也就是说：</p>
<ol>
<li>PROPAGATION_REQUIRES_NEW事务不受外部事务的影响，是隔离的。</li>
<li>PROPAGATION_NESTED，如果内部事务失败且内部，它会回到savepoint之前的状态不会产生脏数据，而外部事务catch住异常后可以选择回滚或者提交；如果外部事务失败，由于嵌套事务是外部事务的一部分，则会导致外部事务与嵌套事务一起回滚。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> spring </tag>
            
            <tag> ioc </tag>
            
            <tag> aop </tag>
            
            <tag> 源码 </tag>
            
            <tag> 事务处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring源码解读(-)]]></title>
      <url>/2017/02/07/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a><strong>设计理念</strong></h4><p>先来看看接口设计预览图：<br><img src="http://ol7zjjc80.bkt.clouddn.com/ioc1.jpg" alt="IOC接口设计规范"></p>
<h4 id="资源定位与注册"><a href="#资源定位与注册" class="headerlink" title="资源定位与注册"></a>资源定位与注册</h4><p>容器的初始化过程是IOC实现的入口，过程如下：</p>
<ol>
<li>Resource定位。BeanDefitioin的资源定位，由ResourceLoader通过统一的Resource接口完成<br>，这个Resource对各种形式的BeanDefinition使用都提供了统一接口。</li>
<li>BeanDefition的载入。这个载入过程是用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器的数据<br>结构就是BeanDefition。BeanDefition实际上就是POJO对象在IOC容器中的抽象，通过这个BeanDefition定义<br>的数据结构，使得IOC容器能够方便地对POJO对象也就是Bean进行管理。</li>
<li>向IOC容器注册这些BeanDefition的过程。调用BeanDefitionRegistry接口的实现来完成。把解析得到的BeanDefition向容器中进行注册。在IOC内部将BeanDefition注入到一个HasMap中去(BeanDefitionHolder),IOC容器就是通过这个HashMap来持有这些BeanDefition数据的。</li>
<li><strong>值得注意：</strong>容器初始化过程不包括依赖注入的实现，Bean定义的载入和依赖注入是俩个独立的过程。依赖注入一般发生在第一次getBean的时候或者通过设置lazyinit实现预先注入Bean。 </li>
</ol>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>AbstractApplicationContext定义了基本的refresh方法，其他的由子类去实现扩展,即AbstractApplicationContext是容器初始化的入口</p>
</li>
<li><p>DefaultListableBeanFactory是IOC容器的基础，FileSystemXmlApplicationContext、WebXmlApplicationContext都是建立在DefaultListableBeanFactory之上，实现自定义BeanDefinition的载入方式</p>
</li>
</ul>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><ul>
<li>初始化过程完成的主要工作是在IOC容器中建立BeanDefinition数据映射。此过程中并没有实现IOC容器对Bean依赖关系进行注入。</li>
<li>对于依赖注入，其触发条件是用户第一次向IOC容器索要Bean时触发的。当然也可以通过控制lazy-init属性来让容器完成对bean的预实例化。</li>
<li><strong>依赖注入的起点：</strong> IOC容器接口BeanFactory中定义了一个getBean接口，这个接口的实现就是触发依赖注入的地方。可以在DefaultListableBeanFactory的类AbstractBeanFactory入手看看getBean的实现。</li>
<li><p>SimpleInstsntiationStrategy类，这个Strategy是Spring用来生成Bean对象的默认类，提供了俩种实例化Java对象的方法，一种是通过BeanUtils，它使用了JVM的反射功能，一种是CGLIB来生成，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</div><div class="line">		// Don&apos;t override the class with CGLIB if no overrides.</div><div class="line">		if (bd.getMethodOverrides().isEmpty()) &#123;</div><div class="line">			Constructor&lt;?&gt; constructorToUse;</div><div class="line">			synchronized (bd.constructorArgumentLock) &#123;</div><div class="line">				constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</div><div class="line">				if (constructorToUse == null) &#123;</div><div class="line">					final Class&lt;?&gt; clazz = bd.getBeanClass();</div><div class="line">					if (clazz.isInterface()) &#123;</div><div class="line">						throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</div><div class="line">					&#125;</div><div class="line">					try &#123;</div><div class="line">						if (System.getSecurityManager() != null) &#123;</div><div class="line">							constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</div><div class="line">								@Override</div><div class="line">								public Constructor&lt;?&gt; run() throws Exception &#123;</div><div class="line">									return clazz.getDeclaredConstructor((Class[]) null);</div><div class="line">								&#125;</div><div class="line">							&#125;);</div><div class="line">						&#125;</div><div class="line">						else &#123;</div><div class="line">							constructorToUse =	clazz.getDeclaredConstructor((Class[]) null);</div><div class="line">						&#125;</div><div class="line">						bd.resolvedConstructorOrFactoryMethod = constructorToUse;</div><div class="line">					&#125;</div><div class="line">					catch (Throwable ex) &#123;</div><div class="line">						throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			return BeanUtils.instantiateClass(constructorToUse);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			// Must generate CGLIB subclass.</div><div class="line">			return instantiateWithMethodInjection(bd, beanName, owner);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖注入最终步骤</strong>：在实例化Bean对象生成的基础上，对于Bean对象生成以后，怎样对这些Bean对象的依赖关系处理好，完成整个依赖注入过程？即通过populateBean方法完成，这个方法在AbstractAutowireCapableBeanFactory中实现，AutoWire的依赖注入等，都做了集中处理。</p>
</li>
<li><p><strong>Bean的初始化(InitializeBean)：</strong>：在initializeBean方法中，需要使用Bean的名字，完成依赖注入以后的Bean对象，以及这个Bean对应的BeanDefinition。然后开始初始化工作：</p>
<blockquote>
<p>为类型是BeanNameAware的Bean设置Bean的名字<br>为类型是BeanClassLoaderAware的Bean设置类装载器，<br>类型是BeanFactoryAware的Bean设置自身所在的IOC容器以供回调使用，<br>对PostProcessBeforeInitialization/postAfterInitialization的回调和初始化属性init-method的处理等。<br>最后，就可以正常的使用由IOC容器托管的Bean了</p>
</blockquote>
</li>
<li><p><img src="http://ol7zjjc80.bkt.clouddn.com/ioc3.jpg" alt="注入过程"></p>
</li>
</ul>
<h4 id="讲讲预先注入"><a href="#讲讲预先注入" class="headerlink" title="讲讲预先注入"></a>讲讲预先注入</h4><p>我们讲过依赖注入一般发生在用户第一次请求，但是也可以设置lazy-init属性实现预先依赖注入。这部分过程依然属于AbstractApplicationContext的 refresh方法中。在finishBeanFactoryInitialization的方法中，封装了lazy-init属性的处理，实际的处理是在DefaultListableBeanFactory这个基本容器的preInstantiateSingletons方法中完成的。该方法对单件Bean完成预先实例化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">public void refresh() throws BeansException, IllegalStateException &#123;</div><div class="line">   Object var1 = this.startupShutdownMonitor;</div><div class="line">   synchronized(this.startupShutdownMonitor) &#123;</div><div class="line">     this.prepareRefresh();</div><div class="line">     ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</div><div class="line">     this.prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">     try &#123;</div><div class="line">       this.postProcessBeanFactory(beanFactory);</div><div class="line">       this.invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">       this.registerBeanPostProcessors(beanFactory);</div><div class="line">       this.initMessageSource();</div><div class="line">       this.initApplicationEventMulticaster();</div><div class="line">       this.onRefresh();</div><div class="line">       this.registerListeners();</div><div class="line">       //预先实例化入口</div><div class="line">       this.finishBeanFactoryInitialization(beanFactory);</div><div class="line">       this.finishRefresh();</div><div class="line">     &#125; catch (BeansException var9) &#123;</div><div class="line">       if(this.logger.isWarnEnabled()) &#123;</div><div class="line">         this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);</div><div class="line">       &#125;</div><div class="line">       this.destroyBeans();</div><div class="line">       this.cancelRefresh(var9);</div><div class="line">       throw var9;</div><div class="line">     &#125; finally &#123;</div><div class="line">       this.resetCommonCaches();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> //在finishBeanFactoryInitialization方法中进行具体的处理过程</div><div class="line"> protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</div><div class="line">   ...</div><div class="line">   beanFactory.setTempClassLoader((ClassLoader)null);</div><div class="line">   beanFactory.freezeConfiguration();</div><div class="line">   beanFactory.preInstantiateSingletons();</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">public void preInstantiateSingletons() throws BeansException &#123;</div><div class="line">	List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</div><div class="line"></div><div class="line">	// Trigger initialization of all non-lazy singleton beans...</div><div class="line">	for (String beanName : beanNames) &#123;</div><div class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</div><div class="line">		if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</div><div class="line">			if (isFactoryBean(beanName)) &#123;</div><div class="line">				final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</div><div class="line">				boolean isEagerInit;</div><div class="line">				if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</div><div class="line">					isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</div><div class="line">						@Override</div><div class="line">						public Boolean run() &#123;</div><div class="line">							return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</div><div class="line">						&#125;</div><div class="line">					&#125;, getAccessControlContext());</div><div class="line">				&#125;</div><div class="line">				else &#123;</div><div class="line">					isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</div><div class="line">							((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</div><div class="line">				&#125;</div><div class="line">				if (isEagerInit) &#123;</div><div class="line">					getBean(beanName);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				getBean(beanName);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Trigger post-initialization callback for all applicable beans...</div><div class="line">	for (String beanName : beanNames) &#123;</div><div class="line">		Object singletonInstance = getSingleton(beanName);</div><div class="line">		if (singletonInstance instanceof SmartInitializingSingleton) &#123;</div><div class="line">			final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</div><div class="line">			if (System.getSecurityManager() != null) &#123;</div><div class="line">				AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">					@Override</div><div class="line">					public Object run() &#123;</div><div class="line">						smartSingleton.afterSingletonsInstantiated();</div><div class="line">						return null;</div><div class="line">					&#125;</div><div class="line">				&#125;, getAccessControlContext());</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				smartSingleton.afterSingletonsInstantiated();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>存疑：</strong> spring 2 中preInstantiateSingletons的实现是加了个Synchronized内置锁，而在当前版本中，这一步去掉了锁，why?</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="AOP名词解释"><a href="#AOP名词解释" class="headerlink" title="AOP名词解释"></a>AOP名词解释</h4><blockquote>
<p><strong>方面（Aspect）</strong>：<br>一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用spring的 Advisor或拦截器实现。<br><strong>连接点（Joinpoint）:</strong> 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。<br><strong>通知（Advice）:</strong> 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice<br><strong>切入点（Pointcut 一系列连接点的集合）:</strong> 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上<br><strong>引入（Introduction）:</strong> 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口<br><strong>目标对象（Target Object）:</strong> 包含连接点的对象。也被称作被通知或被代理对象。POJO<br><strong>AOP代理（AOP Proxy）:</strong> AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。<br><strong>织入（Weaving）:</strong> 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入</p>
</blockquote>
<h4 id="设计原理及流程"><a href="#设计原理及流程" class="headerlink" title="设计原理及流程"></a><strong>设计原理及流程</strong></h4><p>Advice、PointCut、Advisor(通知器，组织起Advice与PointCut)</p>
<p><img src="http://ol7zjjc80.bkt.clouddn.com/aopinterface.jpg" alt="接口设计"><br>AopProxy代理对象生成过程：ProxyFactoryBean和ProxyFactory都提供了AOP的功能封装，但是ProxyFactoryBean与IOC进行了结合，利用BeanFactoryAware获取ApplicationContext,从而可以利用context对IOC注入的bean进行获取</p>
<p>初始化通知链—— &gt;获取单例，没有的话去创建——&gt;判断是否为接口，如果为接口使用JDK,如果不是使用CGlib最后返回AopProxy</p>
<h4 id="AOP调用"><a href="#AOP调用" class="headerlink" title="AOP调用"></a><strong>AOP调用</strong></h4><p>invoke方法，里面逐个去应用配置好的拦截器链,在逐个应用之前先进行一系列的判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">／／如果目标对象没有实现object的基本法方法：equals、如果目标对象没有实现object的基本方法： hashcode、根据代理对象的配置来调用服务</div><div class="line">if(!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</div><div class="line">  Boolean retVal3 = Boolean.valueOf(this.equals(args[0]));</div><div class="line">  return retVal3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</div><div class="line">  Integer retVal2 = Integer.valueOf(this.hashCode());</div><div class="line">  return retVal2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(method.getDeclaringClass() == DecoratingProxy.class) &#123;</div><div class="line">  Class retVal1 = AopProxyUtils.ultimateTargetClass(this.advised);</div><div class="line">  return retVal1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Object retVal;</div><div class="line">if(!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</div><div class="line">  retVal = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</div><div class="line">  return retVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if(this.advised.exposeProxy) &#123;</div><div class="line">  oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">  setProxyContext = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">target = targetSource.getTarget();</div><div class="line">if(target != null) &#123;</div><div class="line">  targetClass = target.getClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后获取配置好的拦截器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div></pre></td></tr></table></figure></p>
<p>判断是否为空，为空的话直接调用invokeJoinpointUsingReflection方法。这个方法直接调用目标方法的实现，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable &#123;</div><div class="line">  try &#123;</div><div class="line">    ReflectionUtils.makeAccessible(method);</div><div class="line">    return method.invoke(target, args);</div><div class="line">  &#125; catch (InvocationTargetException var4) &#123;</div><div class="line">    throw var4.getTargetException();</div><div class="line">  &#125; catch (IllegalArgumentException var5) &#123;</div><div class="line">    throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; + method + &quot;] on target [&quot; + target + &quot;]&quot;, var5);</div><div class="line">  &#125; catch (IllegalAccessException var6) &#123;</div><div class="line">    throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, var6);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果不为空，则创建ReflectiveMethodInvocation传入chain（拦截器链）,然后调用proceed方法，这个方法去递归调用拦截器链中的invoke方法，代码如下（在拦截器的调用一节还会详细展开介绍）：</div><div class="line">ReflectiveMethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</div><div class="line">retVal = invocation.proceed();</div><div class="line"></div><div class="line">public Object proceed() throws Throwable &#123;</div><div class="line">  if(this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</div><div class="line">    return this.invokeJoinpoint();</div><div class="line">  &#125; else &#123;</div><div class="line">    Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</div><div class="line">    if(interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</div><div class="line">      InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;</div><div class="line">      return dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)?dm.interceptor.invoke(this):this.proceed();</div><div class="line">    &#125; else &#123;</div><div class="line">      return ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于最后的目标对象的调用：JDK 直接通过AopUtils的反射机制而cglib则是通过 MethodProxy完成调用，这是cglib自己封住好的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">retval=methodProxy.invoke(target,args);</div></pre></td></tr></table></figure></p>
<h4 id="AOP拦截器链的调用"><a href="#AOP拦截器链的调用" class="headerlink" title="AOP拦截器链的调用"></a><strong>AOP拦截器链的调用</strong></h4><p>了解了AOP的调用之后，再来看看AOP是怎么实现对目标对象增强的。<br>在运行拦截器链的拦截方法时，需要对代理方法完成一个匹配判断，通过这个匹配判断来决定是否满足切面增强的要求。确定是否执行拦截方法。<br>获取interceptors的操作是由advised的对象完成的。是一个AdvisedSupport对象。AdvisedSupport是ProxyFactoryBean的基类。在其中，我们可以看到getInterceptorsAndDynamicInterceptionAdvice 方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class&lt;?&gt; targetClass) &#123;</div><div class="line">  AdvisedSupport.MethodCacheKey cacheKey = new AdvisedSupport.MethodCacheKey(method);</div><div class="line">  List cached = (List)this.methodCache.get(cacheKey);</div><div class="line">  if(cached == null) &#123;</div><div class="line">    cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);</div><div class="line">    this.methodCache.put(cacheKey, cached);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return cached;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里AdvisedSupport被配置成一个DefaultAdvisedSupport对象，里面实现了具体的getInterceptorsAndDynamicInterceptionAdvice方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class&lt;?&gt; targetClass) &#123;</div><div class="line">  ArrayList interceptorList = new ArrayList(config.getAdvisors().length);</div><div class="line">  Class actualClass = targetClass != null?targetClass:method.getDeclaringClass();</div><div class="line">  boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);</div><div class="line">  AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</div><div class="line">  Advisor[] var8 = config.getAdvisors();</div><div class="line">  int var9 = var8.length;</div><div class="line"></div><div class="line">  for(int var10 = 0; var10 &lt; var9; ++var10) &#123;</div><div class="line">    Advisor advisor = var8[var10];</div><div class="line">    MethodInterceptor[] interceptors1;</div><div class="line">    if(advisor instanceof PointcutAdvisor) &#123;</div><div class="line">      PointcutAdvisor var20 = (PointcutAdvisor)advisor;</div><div class="line">      if(config.isPreFiltered() || var20.getPointcut().getClassFilter().matches(actualClass)) &#123;</div><div class="line">        interceptors1 = registry.getInterceptors(advisor);</div><div class="line">        MethodMatcher mm = var20.getPointcut().getMethodMatcher();</div><div class="line">        if(MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</div><div class="line">          if(mm.isRuntime()) &#123;</div><div class="line">            MethodInterceptor[] var15 = interceptors1;</div><div class="line">            int var16 = interceptors1.length;</div><div class="line"></div><div class="line">            for(int var17 = 0; var17 &lt; var16; ++var17) &#123;</div><div class="line">              MethodInterceptor interceptor = var15[var17];</div><div class="line">              interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</div><div class="line">            &#125;</div><div class="line">          &#125; else &#123;</div><div class="line">            interceptorList.addAll(Arrays.asList(interceptors1));</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; else if(advisor instanceof IntroductionAdvisor) &#123;</div><div class="line">      IntroductionAdvisor var19 = (IntroductionAdvisor)advisor;</div><div class="line">      if(config.isPreFiltered() || var19.getClassFilter().matches(actualClass)) &#123;</div><div class="line">        interceptors1 = registry.getInterceptors(advisor);</div><div class="line">        interceptorList.addAll(Arrays.asList(interceptors1));</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</div><div class="line">      interceptorList.addAll(Arrays.asList(interceptors));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return interceptorList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DefaultAdvisorChainFactory 会通过一个AdvisorDapterRegister实现拦截器的注册，注册完成之后,List中的拦截器会被JDK生成的AopProxy中的代理对象的invoke调用，这里通过配置的Intercepters获得拦截器列表然后逐一应用在目标方法上。<br>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123;</div><div class="line">    ArrayList interceptors = new ArrayList(3);</div><div class="line">    Advice advice = advisor.getAdvice();</div><div class="line">    if(advice instanceof MethodInterceptor) &#123;</div><div class="line">      interceptors.add((MethodInterceptor)advice);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Iterator var4 = this.adapters.iterator();</div><div class="line"></div><div class="line">    while(var4.hasNext()) &#123;</div><div class="line">      AdvisorAdapter adapter = (AdvisorAdapter)var4.next();</div><div class="line">      if(adapter.supportsAdvice(advice)) &#123;</div><div class="line">        interceptors.add(adapter.getInterceptor(advisor));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if(interceptors.isEmpty()) &#123;</div><div class="line">      throw new UnknownAdviceTypeException(advisor.getAdvice());</div><div class="line">    &#125; else &#123;</div><div class="line">      return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[interceptors.size()]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> spring </tag>
            
            <tag> ioc </tag>
            
            <tag> aop </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[类函数式的sql生成工具类的封装]]></title>
      <url>/2017/01/30/%E7%B1%BB%E5%87%BD%E6%95%B0%E5%BC%8F%E7%9A%84sql%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自从正式工作以来，公司一直用的是Spring 原生的JDBC Template以及在其上封装的扩展的一些小工具， 而摈弃了Mybatis、ibatis等ORM框架。总的来说，这种做法对于开发效率来说提高不少，由于真正的查库操作不会直接穿透到Mysql，所以抗压性也没有太大的问题。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>虽说直接使用原生的JDBC Template比较方便，但是构造参数条件，以及生成查询语句过于简单粗暴，导致代码不简洁，复用度也不高。举个例子，根据特定的条件查询用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">StringBuffer sqlBuilder = new StringBuffer(&quot;select * from user where &quot;);</div><div class="line">Map&lt;String, Object&gt; paramsMap = new HashMap&lt;&gt;();</div><div class="line">if (userId != null) &#123;</div><div class="line">  sqlBuilder.append(&quot;user_id=:userId&quot;);</div><div class="line">  paramsMap.put(&quot;userId&quot;, userId);</div><div class="line">&#125;</div><div class="line">if (batchNumber != null) &#123;</div><div class="line">  sqlBuilder.append(&quot;batch_number=:batchNumber&quot;);</div><div class="line">  paramsMap.put(&quot;batchNumber&quot;, batchNumber);</div><div class="line">&#125;</div><div class="line">if (status != null) &#123;</div><div class="line">  sqlBuilder.append(&quot;status=:status&quot;);</div><div class="line">  paramsMap.put(&quot;stats&quot;, status);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (page &gt; 0 &amp;&amp; count &gt; 0) &#123;</div><div class="line">  sqlBuilder.append(&quot; limit &quot;)</div><div class="line">      .append(page * count)</div><div class="line">      .append(&quot;, &quot;)</div><div class="line">      .append(count);</div><div class="line">&#125;</div><div class="line">//生成sql语句</div><div class="line">sqlBuilder.toString();</div></pre></td></tr></table></figure></p>
<p>可以看到上面的代码大部分在重复同样的逻辑，20多行的代码仅仅只是在构造sql语句以及收集参数，而且这些重复的代码将充斥项目所有的DAO层，导致代码非常不整洁。维护困难。</p>
<h3 id="sql生成工具类封装"><a href="#sql生成工具类封装" class="headerlink" title="sql生成工具类封装"></a>sql生成工具类封装</h3><p>秉承着恶心重复的代码要重构抽象的态度，对sql生成的步骤，做了一次简单的封装：</p>
<ul>
<li>先介绍接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public interface Order &#123;</div><div class="line">    Where desc();</div><div class="line"></div><div class="line">    Where asc();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">public interface Where &#123;</div><div class="line">    Where ifPresent(Object value, String sql);</div><div class="line"></div><div class="line">    Order orderBy(String field);</div><div class="line"></div><div class="line">    Where limit(int begin, int end);</div><div class="line"></div><div class="line">    Where in(List&lt;Object&gt; values, String sql);</div><div class="line"></div><div class="line">    String sql();//构造的sql</div><div class="line"></div><div class="line">    Map&lt;String, Object&gt; params();//参数值</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>根据sql语句的特点，抽出子句部分的生成单独构造，涵盖Where, in(暂未实现)，limit 以及 order 排序规则。</p>
<ul>
<li>来看看接口的实现<br>将所有相关的类通过内部静态类封装入SqlWhereBuffer类中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">public class SqlWhereBuffer &#123;</div><div class="line"></div><div class="line">  public static SqlWhereBuffer.Where builder() &#123;</div><div class="line">    return new Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  static class Builder implements SqlWhereBuffer.Order, SqlWhereBuffer.Where &#123;</div><div class="line">    private List&lt;String&gt; sql = new ArrayList&lt;&gt;();</div><div class="line">    private Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</div><div class="line">    private String orderBy = &quot; &quot;;</div><div class="line">    private String limit = &quot; &quot;;</div><div class="line">    private String in = &quot; &quot;;</div><div class="line">    private List&lt;SqlMapperPlugin&gt; sqlMapperPlugins;</div><div class="line"></div><div class="line">    public Builder() &#123;</div><div class="line">      //添加基本类型默认的插件</div><div class="line">      sqlMapperPlugins = Lists.newArrayList();</div><div class="line">      this.mapperPlugins(SqlMapperPlugin.EnumSqlPlugin)</div><div class="line">          .mapperPlugins(SqlMapperPlugin.BooleanSqlPlugin);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Builder mapperPlugins(SqlMapperPlugin sqlMapperPlugin) &#123;</div><div class="line">      if (CollectionUtils.isEmpty(sqlMapperPlugins)) &#123;</div><div class="line">        sqlMapperPlugins = Lists.newArrayList();</div><div class="line">      &#125;</div><div class="line">      sqlMapperPlugins.add(sqlMapperPlugin);</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public SqlWhereBuffer.Where ifPresent(Object value, String sql) &#123;</div><div class="line">      Optional.ofNullable(value)</div><div class="line">          .ifPresent(val -&gt; &#123;</div><div class="line">            this.sql.add(sql);</div><div class="line">            Pattern pattern = Pattern.compile(&quot;:([a-z,A-Z,\\w,_]*)&quot;); //固定的sql参数模式</div><div class="line">            Matcher matcher = pattern.matcher(sql);</div><div class="line">            if (!matcher.find()) &#123;</div><div class="line">              throw new IllegalArgumentException(sql + &quot; don&apos;t include :name&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Optional&lt;SqlMapperPlugin&gt; mapper = sqlMapperPlugins.stream()</div><div class="line">                .filter(sqlMapperPlugin -&gt; sqlMapperPlugin.test(val))</div><div class="line">                .findFirst();</div><div class="line">            if (mapper.isPresent()) &#123;</div><div class="line">              params.putAll(mapper.get()</div><div class="line">                  .getParams(matcher.group(1), value));</div><div class="line">            &#125; else &#123;</div><div class="line">              //匹配不到走默认的插件</div><div class="line">              params.put(matcher.group(1), value);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public SqlWhereBuffer.Order orderBy(String field) &#123;</div><div class="line">      orderBy += &quot;ORDER BY &quot; + field;</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public SqlWhereBuffer.Where limit(int offset, int count) &#123;</div><div class="line">      limit += &quot;limit &quot; + offset + &quot;,&quot; + count;</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public String sql() &#123;</div><div class="line">      if (sql.isEmpty() || params.isEmpty()) &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">      &#125; else &#123;</div><div class="line">        return &quot; WHERE &quot; + sql.stream()</div><div class="line">            .collect(Collectors.joining(&quot; AND &quot;)) + orderBy + limit;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ImmutableMap&lt;String, Object&gt; params() &#123;</div><div class="line">      return ImmutableMap.copyOf(params);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public SqlWhereBuffer.Where desc() &#123;</div><div class="line">      orderBy += &quot; DESC&quot;;</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public SqlWhereBuffer.Where asc() &#123;</div><div class="line">      return this;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>静态类Builder实现了SqlWhereBuffer.Order, SqlWhereBuffer.Where这俩个接口的方法。ifPresent是主入口。流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、在ifPresent中参数先进行非空判断，如果是空则直接过滤掉；</div><div class="line">2、然后通过一个正则表达式（**:([a-z,A-Z,\\w,_]*)**）对参数sql进行规则校验，如果不符合也将过滤；</div><div class="line">3、最后value通过一系列的自定义的注册插件的匹配判断，得出sql以及params。</div></pre></td></tr></table></figure></p>
<ul>
<li>关于自定义插件，本没想做这么复杂，然而在实际的使用过程中，JDBC Template对Enum的支持不够…不过想也是，Enum大多是自定义的，没法做到一套约定的接口满足所有需求。于是封装了一个插件类，方便以后扩展：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public static class SqlMapperPlugin &#123;</div><div class="line">    private final Predicate&lt;Object&gt; predicate;</div><div class="line">    private final ParamValue paramValue;</div><div class="line"></div><div class="line">    private SqlMapperPlugin(Predicate&lt;Object&gt; predicate,</div><div class="line">        ParamValue paramValue) &#123;</div><div class="line">      this.predicate = predicate;</div><div class="line">      this.paramValue = paramValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //定义枚举插件</div><div class="line">    static SqlMapperPlugin EnumSqlPlugin = of(Enum.class).paramValue((value, sql) -&gt;</div><div class="line">        Collections.singletonMap(sql, getEnumValue(value))</div><div class="line">    );</div><div class="line">    //定义Boolean插件</div><div class="line">    static SqlMapperPlugin BooleanSqlPlugin = of(Boolean.class).paramValue((value, sql) -&gt;</div><div class="line">        Collections.singletonMap(sql, ((boolean) value) ? 1 : 0)</div><div class="line">    );</div><div class="line"></div><div class="line">    public static SqlMapperPlugin.MapperPluginsBuilder of(Predicate&lt;Object&gt; predicate) &#123;</div><div class="line">      return new MapperPluginsBuilder(predicate);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static SqlMapperPlugin.MapperPluginsBuilder of(Class clazz) &#123;</div><div class="line">      return of((pd) -&gt; &#123;</div><div class="line">        return clazz.isAssignableFrom(pd.getClass());</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    boolean test(Object pd) &#123;</div><div class="line">      return this.predicate.test(pd);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Map&lt;String, Object&gt; getParams(String sql, Object value) &#123;</div><div class="line">      return paramValue.getParams(value, sql);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class MapperPluginsBuilder &#123;</div><div class="line"></div><div class="line">      Predicate&lt;Object&gt; predicate;</div><div class="line"></div><div class="line">      public MapperPluginsBuilder(Predicate&lt;Object&gt; predicate) &#123;</div><div class="line">        this.predicate = predicate;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      public SqlMapperPlugin paramValue(SqlMapperPlugin.ParamValue paramValue) &#123;</div><div class="line">        return new SqlMapperPlugin(this.predicate, paramValue);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @FunctionalInterface</div><div class="line">    public interface ParamValue &#123;</div><div class="line">      Map&lt;String, Object&gt; getParams(Object var1, String var2);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static String getEnumValue(Object value) &#123;</div><div class="line">    Method method;</div><div class="line">    try &#123;</div><div class="line">      method = value.getClass()</div><div class="line">          .getMethod(&quot;name&quot;);</div><div class="line">      return String.valueOf(method.invoke(value));</div><div class="line">    &#125; catch (NoSuchMethodException e) &#123;</div><div class="line">      throw new RuntimeException(&quot;NoSuchMethodException&quot;, e);</div><div class="line">    &#125; catch (IllegalAccessException e) &#123;</div><div class="line">      throw new RuntimeException(&quot;IllegalAccessException&quot;, e);</div><div class="line">    &#125; catch (InvocationTargetException e) &#123;</div><div class="line">      throw new RuntimeException(&quot;InvocationTargetException&quot;, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>主要用到了java8中新增的Predicate接口，用于判断value的Class类型，以及自己定义了一个FunctionalInterface 用于获取查询参数。这里先实现了EnumSqlPlugin，BooleanSqlPlugin俩个插件，之后有其他类型的需求，也可以通过类似的形式加入。对EnumSqlPlugin实现进行解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//定义枚举插件</div><div class="line">    static SqlMapperPlugin EnumSqlPlugin = of(Enum.class).paramValue((value, sql) -&gt;</div><div class="line">        Collections.singletonMap(sql, getEnumValue(value))</div><div class="line">    );</div></pre></td></tr></table></figure></p>
<p>通过定义的of方法定义赋值Predicate,作为判断value是否为指定类型的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static SqlMapperPlugin.MapperPluginsBuilder of(Class clazz) &#123;</div><div class="line">      return of((pd) -&gt; &#123;</div><div class="line">        return clazz.isAssignableFrom(pd.getClass());</div><div class="line">      &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>of方法返回了MapperPluginsBuilder类，紧接着定义函数式接口paramValue的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.singletonMap(sql, getEnumValue(value))</div></pre></td></tr></table></figure></p>
<p>最后返回EnumSqlPlugin对应的新实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return new SqlMapperPlugin(this.predicate, paramValue);</div></pre></td></tr></table></figure></p>
<p>使用的时候，在Builder的构造函数中注入默认的插件即可，如日后有扩展，也可调用mapperPlugins方法动态加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> private List&lt;SqlMapperPlugin&gt; sqlMapperPlugins;</div><div class="line"> public Builder() &#123;</div><div class="line">      //添加基本类型默认的插件</div><div class="line">      sqlMapperPlugins = Lists.newArrayList();</div><div class="line">      this.mapperPlugins(SqlMapperPlugin.EnumSqlPlugin)</div><div class="line">          .mapperPlugins(SqlMapperPlugin.BooleanSqlPlugin);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public Builder mapperPlugins(SqlMapperPlugin sqlMapperPlugin)    &#123;</div><div class="line">      if (CollectionUtils.isEmpty(sqlMapperPlugins)) &#123;</div><div class="line">        sqlMapperPlugins = Lists.newArrayList();</div><div class="line">      &#125;</div><div class="line">      sqlMapperPlugins.add(sqlMapperPlugin);</div><div class="line">      return this;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h3><p>现在，我们可以使用封装好的工具了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SqlWhereBuffer.Where where = SqlWhereBuffer.builder()</div><div class="line">        .ifPresent(batchNumber, &quot;batch_number=:batchNumber&quot;)</div><div class="line">        .ifPresent(status, &quot;upload_result=:uploadResult&quot;)</div><div class="line">        .ifPresent(userId, &quot;user_id=:userId&quot;)</div><div class="line">        .limit(page * count, count)</div><div class="line">        .orderBy(&quot;id&quot;)</div><div class="line">        .asc();</div></pre></td></tr></table></figure></p>
<p>这样，代码变得整洁多了，也符合java8函数式风格的效果。</p>
]]></content>
      
        
        <tags>
            
            <tag> java8 </tag>
            
            <tag> sqlGenerator </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ReentrantLock与condition应用后的思考]]></title>
      <url>/2017/01/20/ReentrantLock%E4%B8%8Econdition%E5%BA%94%E7%94%A8%E5%90%8E%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>一直在断断续续看《java并发编程实战》这本书，每次看都有不一样的体会，前些日子在知乎上回答了一个关于ReentrantLock的问题<a href="https://www.zhihu.com/question/52273413" target="_blank" rel="external">java里是怎么通过condition接口是获取监视器方法的</a> ,那次回答之后也引发了我对其实现的进一步探究。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>举一个简单的例子，是基本上各个公司招聘的时候都会出现的关于多线程间通信的问题：利用多线程循环打印n次”ABC”。当然，这个题目有很多实现方法，有经典的wait和notify的原生方法,也有时髦一点的ReentrantLock写法，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by lichao on 2016/1/20.</div><div class="line"> */</div><div class="line">public class PrintABC &#123;</div><div class="line"></div><div class="line">  static ReentrantLock lock = new ReentrantLock();</div><div class="line">  static Condition conditionA = lock.newCondition();</div><div class="line">  static Condition conditionB = lock.newCondition();</div><div class="line">  static Condition conditionC = lock.newCondition();</div><div class="line">  static int signal = 1;//1=&gt;A, 2=&gt;B 3=&gt;C</div><div class="line">  static int loopValue = 10;</div><div class="line"></div><div class="line">  class taskA implements Runnable &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">      lock.lock();</div><div class="line">      try &#123;</div><div class="line">        for (int i = 0; i &lt; loopValue; i++) &#123;</div><div class="line">          if (signal != 1) &#123;</div><div class="line">            conditionA.await();</div><div class="line">            conditionB.signalAll();</div><div class="line">            conditionC.signalAll();</div><div class="line">          &#125;</div><div class="line">          signal = 2;</div><div class="line">          System.out.print(&quot;A&quot;);</div><div class="line">          conditionB.signal();</div><div class="line">          conditionA.await();</div><div class="line">        &#125;</div><div class="line">      &#125; catch (Exception ex) &#123;</div><div class="line"></div><div class="line">      &#125; finally &#123;</div><div class="line">        lock.unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  class taskB implements Runnable &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">      lock.lock();</div><div class="line">      try &#123;</div><div class="line">        for (int i = 0; i &lt; loopValue; i++) &#123;</div><div class="line">          if (signal != 2) &#123;</div><div class="line">            conditionB.await();</div><div class="line">            conditionA.signalAll();</div><div class="line">            conditionC.signalAll();</div><div class="line">          &#125;</div><div class="line">          signal = 3;</div><div class="line">          System.out.print(&quot;B&quot;);</div><div class="line">          conditionC.signal();</div><div class="line">          conditionB.await();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">      &#125; catch (Exception ex) &#123;</div><div class="line"></div><div class="line">      &#125; finally &#123;</div><div class="line">        lock.unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  class taskC implements Runnable &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">      lock.lock();</div><div class="line">      try &#123;</div><div class="line">        for (int i = 0; i &lt; loopValue; i++) &#123;</div><div class="line">          if (signal != 3) &#123;</div><div class="line">            conditionC.await();</div><div class="line">            conditionB.signalAll();</div><div class="line">            conditionA.signalAll();</div><div class="line">          &#125;</div><div class="line">          signal = 1;</div><div class="line">          System.out.print(&quot;C&quot;);</div><div class="line">          conditionA.signal();</div><div class="line">          conditionC.await();</div><div class="line">        &#125;</div><div class="line">      &#125; catch (Exception ex) &#123;</div><div class="line"></div><div class="line">      &#125; finally &#123;</div><div class="line">        lock.unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    ExecutorService executorService = Executors.newFixedThreadPool(3);</div><div class="line">    executorService.submit(new PrintABC().new taskC());</div><div class="line">    executorService.submit(new PrintABC().new taskB());</div><div class="line">    executorService.submit(new PrintABC().new taskA());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先定义了一个可重入锁，然后起了三个监视器用于控制任务a,b,c的状态，signal作为信号量用于表明当前应该哪个线程执行打印操作，实现无论任务往线程池中提交的顺序如何都能正确打印ABC的顺序</p>
<h3 id="讲讲原理"><a href="#讲讲原理" class="headerlink" title="讲讲原理"></a>讲讲原理</h3><ul>
<li>ReentrantLock（重入锁）是jdk的concurrent包提供的一种独占锁的实现。它继承自Dong Lea的 AbstractQueuedSynchronizer（同步器）。回到上面的代码，我们提交任务是按照CBA的次序来提交的，也就是打印C的任务会先开始执行，而当前的信号量signal为1,也就是A而不是3，所以通过conditonC.await()来释放锁，同时线程休眠等待唤醒，这时A拿到了，并且打印后将signal置为2即B，同时通过conditionA.await()方法使自己休眠，并唤醒B进行打印。以此类推，总的来说，ReentrantLock�与condition配合，优雅的完成了wait和notify做的事情。</li>
<li>我们来看看其中是如何实现这种线程的调度过程的：reentrantLock.newCondition() 返回的是Condition的一个实现，该类在AbstractQueuedSynchronizer中被实现，可以访问AbstractQueuedSynchronizer中的方法和其余内部类,await被调用时的代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public final void await() throws InterruptedException &#123;</div><div class="line">if (Thread.interrupted())</div><div class="line"> throw new InterruptedException();</div><div class="line"> //将当前线程包装下后，添加到Condition自己维护的一个链表中。</div><div class="line"> Node node = addConditionWaiter(); </div><div class="line"> //释放当前线程占有的锁</div><div class="line">int savedState = fullyRelease(node);</div><div class="line">int interruptMode = 0;</div><div class="line"> while (!isOnSyncQueue(node)) &#123;</div><div class="line"> //释放完毕后，不断AQS的队列，看当前节点是否在队列中，不在 说明它还没有竞争锁的资格，所以继续将自己沉睡。直到它被重新加入到队列中.</div><div class="line"> LockSupport.park(this);</div><div class="line"> if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class="line"> break;</div><div class="line"> &#125;</div><div class="line">//被唤醒后，重新开始正式竞争锁，同样，如果竞争不到还是会将自己沉睡，等待唤醒重新开始竞争。</div><div class="line">if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</div><div class="line"> interruptMode = REINTERRUPT;</div><div class="line"> if (node.nextWaiter != null)</div><div class="line"> unlinkCancelledWaiters();</div><div class="line"> if (interruptMode != 0)</div><div class="line"> reportInterruptAfterWait(interruptMode);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>signal方法的调用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public final void signal() &#123;</div><div class="line"> if (!isHeldExclusively())</div><div class="line"> throw new IllegalMonitorStateException();</div><div class="line"> Node first = firstWaiter; //firstWaiter为condition自己维护的一个链表的头结点，</div><div class="line">                          //取出第一个节点后开始唤醒操作</div><div class="line"> if (first != null)</div><div class="line"> doSignal(first);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> private void doSignal(Node first) &#123;</div><div class="line"> do &#123;</div><div class="line"> if ( (firstWaiter = first.nextWaiter) == null) //修改头结点，完成旧头结点的移出工作</div><div class="line"> lastWaiter = null;</div><div class="line"> first.nextWaiter = null;</div><div class="line"> &#125; while (!transferForSignal(first) &amp;&amp;//将老的头结点，加入到AQS的等待队列中</div><div class="line"> (first = firstWaiter) != null);</div><div class="line"> &#125;</div><div class="line"></div><div class="line">final boolean transferForSignal(Node node) &#123;</div><div class="line"> /*</div><div class="line"> * If cannot change waitStatus, the node has been cancelled.</div><div class="line"> */</div><div class="line"> if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</div><div class="line"> return false;</div><div class="line"></div><div class="line">/*</div><div class="line"> * Splice onto queue and try to set waitStatus of predecessor to</div><div class="line"> * indicate that thread is (probably) waiting. If cancelled or</div><div class="line"> * attempt to set waitStatus fails, wake up to resync (in which</div><div class="line"> * case the waitStatus can be transiently and harmlessly wrong).</div><div class="line"> */</div><div class="line"> Node p = enq(node);</div><div class="line"> int ws = p.waitStatus;</div><div class="line">//如果该结点的状态为cancel 或者修改waitStatus失败，则直接唤醒。</div><div class="line"> if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class="line"> LockSupport.unpark(node.thread);</div><div class="line"> return true;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>其实condition内部维护了一个等待队列，用于存放等待signal的任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</div><div class="line">        private static final long serialVersionUID = 1173984872572414699L;</div><div class="line">        /** First node of condition queue. */</div><div class="line">        private transient Node firstWaiter;</div><div class="line">        /** Last node of condition queue. */</div><div class="line">        private transient Node lastWaiter;</div><div class="line">        </div><div class="line">**</div><div class="line">         * Adds a new waiter to wait queue.</div><div class="line">         * @return its new wait node</div><div class="line">         */</div><div class="line">        private Node addConditionWaiter() &#123;</div><div class="line">            Node t = lastWaiter;</div><div class="line">            // If lastWaiter is cancelled, clean out.</div><div class="line">            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</div><div class="line">                unlinkCancelledWaiters();</div><div class="line">                t = lastWaiter;</div><div class="line">            &#125;</div><div class="line">            Node node = new Node(Thread.currentThread(), Node.CONDITION);</div><div class="line">            if (t == null)</div><div class="line">                firstWaiter = node;</div><div class="line">            else</div><div class="line">                t.nextWaiter = node;</div><div class="line">            lastWaiter = node;</div><div class="line">            return node;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而AbstractQueuedSynchronizer中也维护了一个队列，就是获取当前资源的等待队列，当资源释放掉之后，会依次从队列中恢复线程，直至为空。每个线程会在这俩个队列中来回切换，但同一时刻仅存在于一个队列中。<br><img src="http://jacobs.wanhb.cn/images/reentrantLock.jpg" alt="ReentrantLock流程"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">线程1-&gt;AQS: ReentrantLock.lock（加入AQS队列，获取资源）</div><div class="line">线程1-&gt;AQS: condition.await()（移除队列，释放资源）</div><div class="line">AQS-&gt;condition队列: 线程1加入condition等待队列</div><div class="line">线程2-&gt;AQS: 线程2加入AQS队列并获取资源</div><div class="line">线程2-&gt;AQS: condition2.await()（移除AQS队列，释放资源）</div><div class="line">线程2-&gt;线程1: condition.signal()（线程2调用signal唤醒线程1）</div><div class="line">线程1-&gt;AQS: ReentrantLock.lock(重新加入AQS队列，获取资源)</div></pre></td></tr></table></figure></p>
<p>###总结<br>还是得深入源码去看问题，不能只关注业务，否则会成为彻头彻尾的搬砖工，不仅要会用轮子，还要会造轮子。最后分享一片陈浩写的技术人员的职业生涯文章，共勉。<a href="http://coolshell.cn/articles/17583.html" target="_blank" rel="external">技术人员的发展之路</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次失败的debug经历]]></title>
      <url>/2017/01/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84debug%E7%BB%8F%E5%8E%86/</url>
      <content type="html"><![CDATA[<p>昨天使用spring aop的事务注解出现了业务中主动抛出异常却无法回滚脏数据的情形，然后崩溃的debug了一天，最后猛然发现不能通过this去掉加了增强的方法否则将拿不到代理对象。归根结底还是自己不甚理解事务实现的其中原理，才导致了bug的出现而不自知。</p>
<h3 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h3><p>如果对java如何实现底层的事务机制不太熟悉的话可以看看<a href="http://www.cnblogs.com/davenkin/archive/2013/02/16/java-tranaction-1.html" target="_blank" rel="external">java事务处理系列文章</a> 自己手动实现事务处理。</p>
<p>来看看我调用事务的错误示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">class DemoService&#123;</div><div class="line"></div><div class="line">   public List&lt;ExpressExportRow&gt; notExpressedRecord() &#123;</div><div class="line">    ...</div><div class="line">    changeOrderStatusToExpressing();</div><div class="line">    ...</div><div class="line">    return expressExportRowList;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line"></div><div class="line">  @Transactional(value = &quot;apolloTransactionManager&quot;,rollbackFor = Exception.class)</div><div class="line">  public boolean changeOrderStatusToExpressing(Long orderId, Long orderGroupId) &#123;</div><div class="line">    boolean isSuccess = updateExpressRecordStatus(orderId, orderGroupId,</div><div class="line">        OrderStatus.EXPRESSING.getValue());</div><div class="line">    if (isSuccess) &#123;</div><div class="line">      isSuccess = apolloService.updateOrderStatus(orderId, orderGroupId,</div><div class="line">          OrderStatus.EXPRESSING.getValue());</div><div class="line">    &#125;</div><div class="line">    if (!isSuccess) &#123;</div><div class="line">      throw new RuntimeException(&quot;更改订单状态失败,订单号为: &quot; + orderId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return isSuccess;</div><div class="line">  &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>首先DemoService通过@Component注解在容器加载的时候是确实注入进去了， 由于AOP 结合了IOC 的一部分功能（ProxyFactoryBean中实现）也就是在容器启动的过程中跟着在Demoservice封装成了aop代理对象保存在容器中。上面的代码错在直接在service 里面通过this引用去调增强的方法，结果导致方法不会应用相应的增强处理。来看看aop的处理流程图<br><img src="http://jacobs.wanhb.cn/images/aop1.jpg" alt="aop事务处理流程"></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul>
<li>清楚了导出bug的原因和spring事务的基本原理之后，相应的解决办法就很简单，即我们只需要确保我们拿到的demoservice实例是通过容器注入进来的即可，于是可以以下解法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">class Resource&#123;</div><div class="line">@Resource</div><div class="line">  DemoServcie demoService;</div><div class="line">  </div><div class="line">  public changeStatus()&#123;</div><div class="line">    demoService.changeOrderStatusToExpressing(...);</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>通过@Resource注入进来的demoService必然式容器中的已经加载配置好的代理对象。这样就能成功应用事务增强。</p>
<ul>
<li>或者也可以通过后置器BeanPostProcessor将自身注入进来，即在自身的service里完成调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Component  </div><div class="line">public class DemoService implements BeanPostProcessor &#123;  </div><div class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;  </div><div class="line">        return bean;  </div><div class="line">    &#125;  </div><div class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;  </div><div class="line">        if(bean instanceof BeanSelfAware) &#123; </div><div class="line">            ((BeanSelfAware) bean).setSelf(bean);</div><div class="line">        &#125;  </div><div class="line">        return bean;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>但是这样会出现循环依赖问题。所以第一种方法最为合适。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这次的低级bug再一次发现自己对源码不够深入，虽然前前后后看过了不少spring源码，但是也没有立即发现bug的存在，各方面理解还有待提高。继续努力吧</p>
]]></content>
      
        
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 爬取新浪微博]]></title>
      <url>/2016/12/01/python-%E7%88%AC%E5%8F%96%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/</url>
      <content type="html"><![CDATA[<p>最近因为课设的要求，开始了对新浪微博数据的爬取研究，看了不少博客文章，也试了不少方法，原理无非就是模拟登录，但是感觉目前可用的方法太过分散，而且自从微博改版之后，很多以前适用的方法都基本没有用处了。这里总结一下几种可用的方法以及自己研究之后稳定可用的方法(所有的方法都是基于python2.7)：</p>
<hr>
<p>###1、绕过.com域名</p>
<p>如果没有爬取主站的刚需，只是对微博相关的数据感兴趣，可以尝试爬取微博cn域名下的内容(即<a href="http://weibo.cn)，亲测可用...最简单的办法就是先预先登录一下然后获取返回的cookie，贴入代码中作为请求的headers即可。" target="_blank" rel="external">http://weibo.cn)，亲测可用...最简单的办法就是先预先登录一下然后获取返回的cookie，贴入代码中作为请求的headers即可。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_header=&#123;</div><div class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.86 Safari/537.36&quot;,</div><div class="line">        &quot;Cookie&quot;:&quot;_T_WM=03e77f532a8c1a437da863b36a62207d; SUB=_2A256KfecDeRxGeVP61MX9yzKyT-IHXVZ1ZnUrDV6PUNbvtANLRTVkW1LHesQJOUc8nbbLnoALvjmulMBSwDnAw..; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9WhPUuFTXg4zll8rx_8Ap-XA5JpX5KMhUgL.Foepeh2cS0zceoet; SUHB=0cSXC9tcKk2RM7; SSOLoginState=1462601676; gsid_CTandWM=4uTtCpOz5hhWcws1tVSIdd0SYa3&quot;    &#125;</div><div class="line"> request = urllib2.Request(url=url, headers=self._header)</div><div class="line"> response = urllib2.urlopen(request)</div><div class="line"> html = response.read()</div></pre></td></tr></table></figure>
<p>接下来对爬取下来的html就可以通过xpath,或者bs来完成数据提取了。</p>
<hr>
<p>###2、使用urllib模拟登录微博.com主站</p>
<p>这个过程比较麻烦，前人有了很多铺垫做相应的改动直接拿来用就好啦，以下代码亲测可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">-*- coding: utf-8 -*-import urllib2</div><div class="line">import re</div><div class="line">import rsa</div><div class="line">import cookielib  #从前的cookielibimport base64</div><div class="line">import json</div><div class="line">import urllib</div><div class="line">import binascii</div><div class="line">from lxml import etree</div><div class="line">import json</div><div class="line"> 用于模拟登陆新浪微博class launcher():</div><div class="line"> </div><div class="line">    cookieContainer=None    _headers=&#123;</div><div class="line">            &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36&quot;        &#125;</div><div class="line">    def __init__(self,username, password):</div><div class="line">        self.password = password</div><div class="line">        self.username = username</div><div class="line"></div><div class="line"></div><div class="line">    def get_prelogin_args(self):</div><div class="line">        json_pattern = re.compile(&apos;\((.*)\)&apos;)</div><div class="line">        url = &apos;http://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=&amp;&apos; + self.get_encrypted_name() + &apos;&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.18)&apos;        try:</div><div class="line">            request = urllib2.Request(url)</div><div class="line">            response = urllib2.urlopen(request)</div><div class="line">            raw_data = response.read().decode(&apos;utf-8&apos;)</div><div class="line">            print &quot;get_prelogin_args&quot;+raw_data;</div><div class="line">            json_data = json_pattern.search(raw_data).group(1)</div><div class="line">            data = json.loads(json_data)</div><div class="line">            return data</div><div class="line">        except urllib2.HTTPError as e:</div><div class="line">            print(&quot;%d&quot;%e.code)</div><div class="line">            return None    def get_encrypted_pw(self,data):</div><div class="line">        rsa_e = 65537 #0x10001        pw_string = str(data[&apos;servertime&apos;]) + &apos;\t&apos; + str(data[&apos;nonce&apos;]) + &apos;\n&apos; + str(self.password)</div><div class="line">        key = rsa.PublicKey(int(data[&apos;pubkey&apos;],16),rsa_e)</div><div class="line">        pw_encypted = rsa.encrypt(pw_string.encode(&apos;utf-8&apos;), key)</div><div class="line">        self.password = &apos;&apos;   #清空password        passwd = binascii.b2a_hex(pw_encypted)</div><div class="line">        print(passwd)</div><div class="line">        return passwd</div><div class="line"></div><div class="line"></div><div class="line">    def get_encrypted_name(self):</div><div class="line">        username_urllike   = urllib.quote(self.username)</div><div class="line">        byteStr=bytes(username_urllike)</div><div class="line">        byteStrEncod=byteStr.encode(encoding=&quot;utf-8&quot;)</div><div class="line">        username_encrypted = base64.b64encode(byteStrEncod)</div><div class="line">        return username_encrypted.decode(&apos;utf-8&apos;)</div><div class="line"></div><div class="line"></div><div class="line">    def enableCookies(self):</div><div class="line">            #建立一个cookies 容器            self.cookieContainer = cookielib.MozillaCookieJar(&quot;/Users/lichao/desktop/weibo/cookie/cookie.txt&quot;);</div><div class="line">            # ckjar=cookielib.MozillaCookieJar(&quot;/Users/Apple/Desktop/cookie.txt&quot;)            #将一个cookies容器和一个HTTP的cookie的处理器绑定            cookie_support = urllib2.HTTPCookieProcessor(self.cookieContainer)</div><div class="line">            #创建一个opener,设置一个handler用于处理http的url打开            opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler)</div><div class="line">            #安装opener，此后调用urlopen()时会使用安装过的opener对象            # proxy_handler = urllib2.ProxyHandler(&#123;&quot;http&quot;: &apos;http://localhost:5000&apos;&#125;)            # opener=urllib2.build_opener(proxy_handler)            urllib2.install_opener(opener)</div><div class="line"></div><div class="line"></div><div class="line">    def build_post_data(self,raw):</div><div class="line">        post_data = &#123;</div><div class="line">            &quot;entry&quot;:&quot;weibo&quot;,</div><div class="line">            &quot;gateway&quot;:&quot;1&quot;,</div><div class="line">            &quot;from&quot;:&quot;&quot;,</div><div class="line">            &quot;savestate&quot;:&quot;7&quot;,</div><div class="line">            &quot;useticket&quot;:&quot;1&quot;,</div><div class="line">            &quot;pagerefer&quot;:&quot;Sina Visitor System&quot;,</div><div class="line">            &quot;vsnf&quot;:&quot;1&quot;,</div><div class="line">            &quot;su&quot;:self.get_encrypted_name(),</div><div class="line">            &quot;service&quot;:&quot;miniblog&quot;,</div><div class="line">            &quot;servertime&quot;:raw[&apos;servertime&apos;],</div><div class="line">            &quot;nonce&quot;:raw[&apos;nonce&apos;],</div><div class="line">            &quot;pwencode&quot;:&quot;rsa2&quot;,</div><div class="line">            &quot;rsakv&quot;:raw[&apos;rsakv&apos;],</div><div class="line">            &quot;sp&quot;:self.get_encrypted_pw(raw),</div><div class="line">            &quot;sr&quot;:&quot;1280*800&quot;,</div><div class="line">            &quot;encoding&quot;:&quot;UTF-8&quot;,</div><div class="line">            &quot;prelt&quot;:&quot;77&quot;,</div><div class="line">            &quot;url&quot;:&quot;http://weibo.com/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack&quot;,</div><div class="line">            &quot;returntype&quot;:&quot;META&quot;        &#125;</div><div class="line">        data = urllib.urlencode(post_data).encode(&apos;utf-8&apos;)</div><div class="line">        return data</div><div class="line"></div><div class="line"></div><div class="line">    def login(self):</div><div class="line">        url = &apos;新浪通行证&apos;        self.enableCookies()</div><div class="line">        data = self.get_prelogin_args()</div><div class="line">        post_data = self.build_post_data(data)</div><div class="line">        headers = &#123;</div><div class="line">            &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36&quot;        &#125;</div><div class="line">        try:</div><div class="line">            request = urllib2.Request(url=url,data=post_data,headers=headers)</div><div class="line">            response = urllib2.urlopen(request)</div><div class="line">            html = response.read().decode(&apos;GBK&apos;)</div><div class="line">            #print(html)        except urllib2.HTTPError as e:</div><div class="line">            print(e.code)</div><div class="line"></div><div class="line"></div><div class="line">        p = re.compile(&apos;location\.replace\(\&apos;(.*?)\&apos;\)&apos;)</div><div class="line">        p2 = re.compile(r&apos;&quot;userdomain&quot;:&quot;(.*?)&quot;&apos;)</div><div class="line"></div><div class="line"></div><div class="line">        try:</div><div class="line">            login_url = p.search(html).group(1)</div><div class="line">            print(login_url)</div><div class="line">            request = urllib2.Request(login_url)</div><div class="line">            response = urllib2.urlopen(request)</div><div class="line">            page = response.read().decode(&apos;utf-8&apos;)</div><div class="line">            print(page)</div><div class="line">            login_url = &apos;http://weibo.com/&apos; + p2.search(page).group(1)</div><div class="line">            request = urllib2.Request(login_url)</div><div class="line">            response = urllib2.urlopen(request)</div><div class="line">            final = response.read().decode(&apos;utf-8&apos;)</div><div class="line"></div><div class="line"></div><div class="line">            print(&quot;Login success!&quot;)</div><div class="line">            self.cookieContainer.save(ignore_discard=True, ignore_expires=True)</div><div class="line">        except Exception, e:</div><div class="line">            print(&apos;Login error!&apos;)</div><div class="line">            print e</div><div class="line">            return 0</div></pre></td></tr></table></figure>
<p>###3、使用selenium实现模拟登录</p>
<ul>
<li>selenium +phantomjs</li>
</ul>
<p>第二种方法有一个问题，因为目前新版的微博页面的渲染方式采用的是分片渲染的，这就导致我们通过第二种静态方式爬取到的页面并不是最终的页面，而是内容嵌在 js里的中间页面，这肯定不是我们想看到的结果。于是，考虑模拟浏览器渲染页面的方式获取到最终的呈现页面。selenium这个工具正好完美的解决了我们的问题，它可以模拟浏览器的行为，并且我们拿到的source可以向jquery操作dom对象那样查找定位元素，非常方便，实现的核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line">from selenium import webdriver</div><div class="line">import urllib2</div><div class="line">import selenium.webdriver.support.ui as ui</div><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding( &quot;utf-8&quot; )</div><div class="line">from selenium.webdriver.common.keys import Keys</div><div class="line">Chrome PhantomJS#driver = webdriver.PhantomJS(&quot;/Users/test/documents/phantomjs/bin/phantomjs&quot;)</div><div class="line">driver.get(&apos;http://weibo.com/&apos;)</div><div class="line"></div><div class="line"></div><div class="line">try:</div><div class="line">    print &quot;登录开始&quot;</div><div class="line">    username = driver.find_element_by_xpath(&apos;//input[@name=&quot;username&quot;]&apos;)</div><div class="line">    password = driver.find_element_by_xpath(&apos;//input[@name=&quot;password&quot;]&apos;)</div><div class="line">    sbtn = driver.find_element_by_xpath(&apos;//a[@action-type=&quot;btn_submit&quot;]&apos;)</div><div class="line">    username.send_keys(&apos;&apos;) #send username       </div><div class="line">    password.send_keys(&apos;&apos;) #send password    sbtn.click()  </div><div class="line">    # 提交表单    </div><div class="line">    time.sleep(3)  # 等待页面加载   </div><div class="line">    # get the session cookie    </div><div class="line">    cookie = &#123;item[&quot;name&quot;] + &quot;:&quot; + item[&quot;value&quot;] for item in driver.get_cookies()&#125;    cookie=driver.get_cookies()</div><div class="line">    for item in driver.get_cookies():    cookieItem=&#123;&quot;name&quot;:item[&quot;name&quot;],&quot;value&quot;:item[&quot;value&quot;],&quot;domain&quot;:item[&quot;domain&quot;],&quot;httponly&quot;:item[&quot;httponly&quot;],&quot;path&quot;:item[&quot;path&quot;],&quot;secure&quot;:item[&quot;secure&quot;]&#125;    cookie.append(cookieItem)    cookie_file= open(&quot;/Users/test/desktop/weibo/cookie/cookie.txt&quot;,&apos;w&apos;)    cookie_file.write(str(cookie))    print str(str(cookie))</div><div class="line">except urllib2.HTTPError as e:</div><div class="line">    print e</div><div class="line">    print &quot;登录失败&quot;print &quot;开始爬取谣言大厅&quot;driver.get(&quot;http://service.account.weibo.com/show?rid=K1CaN7gJl8q8f&quot;)</div><div class="line">page = driver.page_source</div><div class="line">print page</div><div class="line">driver.quit()</div></pre></td></tr></table></figure>
<p>我们将登录之后获取的cookie以键值对的形式存入文本文件中，方便下次直接load而不需要重复登录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def loadCookie(self):</div><div class="line">self._driver.get(&quot;http://www.sina.com.cn&quot;)</div><div class="line">    cookie_file=open(&quot;/Users/test/desktop/weibo/cookie/cookie.txt&quot;,&apos;r&apos;)</div><div class="line">    cookieStr=cookie_file.read();</div><div class="line">print &quot;cookie is: &quot;+cookieStr</div><div class="line">    cookieList=list(eval(cookieStr))</div><div class="line">for item in cookieList:</div><div class="line">cookieDic= type(eval(item))</div><div class="line">        self._driver.add_cookie(item)</div></pre></td></tr></table></figure>
<ul>
<li>selenium +chromedirver</li>
</ul>
<p>使用phantomjs存在一个问题，登录过程老是失败，因为验证码无法识别获取导致登录经常失败，这里我们使用chromedirver这工具结合selenium实现开挂级别的python数据爬取，模拟登录万无一失，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print &quot;登录开始&quot;</div><div class="line">username = driver.find_element_by_xpath(&apos;//input[@name=&quot;username&quot;]&apos;)</div><div class="line">password = driver.find_element_by_xpath(&apos;//input[@name=&quot;password&quot;]&apos;)</div><div class="line">sbtn = driver.find_element_by_xpath(&apos;//a[@action-type=&quot;btn_submit&quot;]&apos;)</div><div class="line">veryfiCode=driver.find_element_by_xpath(&apos;//input[@name=&quot;verifycode&quot;]&apos;)</div></pre></td></tr></table></figure>
<p> 程序启动时会自动开启一个chrome窗口，只不过这个浏览器的行为我们可以通过程序控制，这样是不是方便多了！我们在username这一行打一个断点，然后程序执行到这一步，在浏览器中输入相应的用户名，密码，验证码，然后在pycharm中点击继续，登录成功！真实浏览器结合程序，真是开挂级别的爬取微博啊…</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Crawler </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手动封装HbaseTemplate mapper类]]></title>
      <url>/2016/10/09/%E6%89%8B%E5%8A%A8%E5%B0%81%E8%A3%85HbaseTemplate-mapper%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近因为业务关系，用到了Hbase，因为用的是Spring boot框架 ，所以自然而然就用到了spring封装的HbaseTemplate工具类。然而HbaseTemplate封装的代码实在比较糟糕，出了一些基本的CRUD操作之外并没有给我们提供太多便利之处。先来看看痛处：</p>
<h3 id="痛处一及改进"><a href="#痛处一及改进" class="headerlink" title="痛处一及改进"></a>痛处一及改进</h3><ul>
<li>我们先来看看HabaseTemplate最基本的查询操作(以下只是demo演示)：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class UserInfo&#123;</div><div class="line"> string name;</div><div class="line"> string password;</div><div class="line">&#125;</div><div class="line">public void putUserInfo(UserInfo userInfo) &#123;</div><div class="line">   hBaseTemplate.execute(TABLE_NAME, (table) -&gt; &#123;</div><div class="line">     //根据rowKey定义一个put对象，可用作插入和更新</div><div class="line">     Put put = new Put(Bytes.toBytes(rowKey));</div><div class="line">    //name是否为空</div><div class="line">     if(userInfo.name!=null)&#123;</div><div class="line">     put.addColumn(COLUMN_FAMILY_NAME.getBytes(), Bytes.toBytes(COLUMN_RAW_DATA)，Bytes.toBytes(userInfo.name));</div><div class="line">     &#125;</div><div class="line">     //password是否为空</div><div class="line">     if(userInfo.password!=null)&#123;</div><div class="line">     put.addColumn(COLUMN_FAMILY_NAME.getBytes(), Bytes.toBytes(COLUMN_RAW_DATA)，Bytes.toBytes(userInfo.password));</div><div class="line">     &#125;</div><div class="line">     table.put(put);</div><div class="line">     return true;</div><div class="line">   &#125;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>相信大家也看出来了，如果待插入的对象有很多字段呢？还要逐个写if语句来判读非空么？这明显使得代码非常地不简洁。于是，个人封装了一个插入更新模版类（其实只是简单的对Put对象的一个扩展）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//继承并扩展Put对象</div><div class="line">public class PutExtension extends Put &#123;</div><div class="line"></div><div class="line">  String columnFamilyName = &quot;demo&quot;;</div><div class="line"></div><div class="line">  public PutExtension(String columnFamilyName, byte[] row) &#123;</div><div class="line">    super(row);</div><div class="line">    this.columnFamilyName = columnFamilyName;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public PutExtension build(String paramName, Object param) throws IOException &#123;</div><div class="line">    if (param != null) &#123;</div><div class="line">      this.addColumn(columnFamilyName.getBytes(), paramName.getBytes(),</div><div class="line">          Bytes.toBytes(param.toString()));</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>封装之后，之前累赘的查询操作可以变得如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//然后操作如下</div><div class="line">hBaseTemplate.execute(TABLE_NAME, (table) -&gt; &#123;</div><div class="line">      PutExtension putExtension = new PutExtension(familyName, rowKey.getBytes());</div><div class="line">      putExtension.build(&quot;name&quot;,userInfo.name)</div><div class="line">          .build(&quot;password&quot;, userInfo.password);</div><div class="line">      table.put(putExtension);</div><div class="line">      return true;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>其实这也就是一个简单的封装，只不过把冗余的逻辑判断给丢出去了而已。</p>
<h3 id="痛处二及改进"><a href="#痛处二及改进" class="headerlink" title="痛处二及改进"></a>痛处二及改进</h3><ul>
<li>在HbaseTemplate中，根据rowKey查询出来的原始数据是字节数组，我们要将字节数组转化成业务逻辑中希望的java bean需要做很多重复的判断匹配逻辑，以下是没改进前的代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> public UserInfo getUserInfo() &#123;</div><div class="line">    return (UserInfo) hBaseTemplate.get(TABLE_NAME, rowKey, familyName,(result, i) -&gt;&#123;</div><div class="line">     UserInfo userInfo=new UserInfo()</div><div class="line">     //重复逻辑一</div><div class="line">bytes[] nameBytes=result.getValue(familyName.getBytes(), &quot;name&quot;.getBytes()));</div><div class="line">if(nameBytes!=null)&#123;</div><div class="line">  userInfo.setName(Bytes.toString(nameBytes));</div><div class="line">&#125;</div><div class="line">//重复逻辑二</div><div class="line">bytes[] passwordBytes=result.getValue(familyName.getBytes(), &quot;password&quot;.getBytes()));</div><div class="line">if(passwordBytes!=null)&#123;</div><div class="line">  userInfo.setPassword(Bytes.toString(passwordBytes));</div><div class="line">&#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，这样做的缺点是一旦java bean的字段一多，重复的非空判断逻辑也会增多，从而使得代码变得十分累赘且不可维护。于是我参考Spring JDBC的RowMapper的封装，利用了Spring框架自带的反射工具beanUtils和beanWrapper，自己实现了如下封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">public class HBaseResultBuilder&lt;T&gt; &#123;</div><div class="line">  private Class&lt;T&gt; mappedClass;</div><div class="line">  private Map&lt;String, PropertyDescriptor&gt; mappedFields;</div><div class="line">  private Set&lt;String&gt; mappedProperties;</div><div class="line">  HashSet populatedProperties;</div><div class="line">  private BeanWrapper beanWrapper;</div><div class="line">  private Result result;</div><div class="line">  private String columnFamilyName;</div><div class="line">  private T t;</div><div class="line">  //接受一些列参数并实例化要返回的结果对象</div><div class="line">  public HBaseResultBuilder(String columnFamilyName, Result result, Class&lt;T&gt; clazz) &#123;</div><div class="line">    this.columnFamilyName = columnFamilyName;</div><div class="line">    this.result = result;</div><div class="line">    this.mappedClass = clazz;</div><div class="line">    mappedFields = new HashMap&lt;&gt;();</div><div class="line">    mappedProperties = new HashSet&lt;&gt;();</div><div class="line">    populatedProperties = new HashSet&lt;&gt;();</div><div class="line">    this.t = BeanUtils.instantiate(clazz);</div><div class="line">    PropertyDescriptor[] pds = BeanUtils.getPropertyDescriptors(mappedClass);</div><div class="line">    PropertyDescriptor[] var3 = pds;</div><div class="line">    int var4 = pds.length;</div><div class="line">    for (int var5 = 0; var5 &lt; var4; ++var5) &#123;</div><div class="line">      PropertyDescriptor pd = var3[var5];</div><div class="line">      if (pd.getWriteMethod() != null) &#123;</div><div class="line">        this.mappedFields.put(this.lowerCaseName(pd.getName()), pd);</div><div class="line">        String underscoredName = this.underscoreName(pd.getName());</div><div class="line">        if (!this.lowerCaseName(pd.getName()).equals(underscoredName)) &#123;</div><div class="line">          this.mappedFields.put(underscoredName, pd);</div><div class="line">        &#125;</div><div class="line">        this.mappedProperties.add(pd.getName());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(t);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private String underscoreName(String name) &#123;</div><div class="line">    if (!StringUtils.hasLength(name)) &#123;</div><div class="line">      return &quot;&quot;;</div><div class="line">    &#125; else &#123;</div><div class="line">      StringBuilder result = new StringBuilder();</div><div class="line">      result.append(this.lowerCaseName(name.substring(0, 1)));</div><div class="line"></div><div class="line">      for (int i = 1; i &lt; name.length(); ++i) &#123;</div><div class="line">        String s = name.substring(i, i + 1);</div><div class="line">        String slc = this.lowerCaseName(s);</div><div class="line">        if (!s.equals(slc)) &#123;</div><div class="line">          result.append(&quot;_&quot;).append(slc);</div><div class="line">        &#125; else &#123;</div><div class="line">          result.append(s);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return result.toString();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private String lowerCaseName(String name) &#123;</div><div class="line">    return name.toLowerCase(Locale.US);</div><div class="line">  &#125;</div><div class="line">  //使用时根据要解析的字段频繁调用此方法即可，仿造java8 流式操作</div><div class="line">  public HBaseResultBuilder build(String columnName) &#123;</div><div class="line">    byte[] value = result.getValue(columnFamilyName.getBytes(), columnName.getBytes());</div><div class="line">    if (value == null || value.length == 0) &#123;</div><div class="line">      return this;</div><div class="line">    &#125; else &#123;</div><div class="line">      String field = this.lowerCaseName(columnName.replaceAll(&quot; &quot;, &quot;&quot;));</div><div class="line">      PropertyDescriptor pd = this.mappedFields.get(field);</div><div class="line">      if (pd == null) &#123;</div><div class="line">        log.error(&quot;HBaseResultBuilder error: can not find property: &quot; + field);</div><div class="line">      &#125; else &#123;</div><div class="line">        beanWrapper.setPropertyValue(pd.getName(), Bytes.toString(value));</div><div class="line">        populatedProperties.add(pd.getName());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //伪造Java8的即视感，“流最后的终端操作“。</div><div class="line">  public T fetch() &#123;</div><div class="line">    //只要有一个属性被解析出来就返回结果对象，毕竟hbase存的是稀疏数据，不一定全量</div><div class="line">    if (CollectionUtils.isNotEmpty(populatedProperties)) &#123;</div><div class="line">      return this.t;</div><div class="line">    &#125; else &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过利用反射的基本原理，我们可以通过结果数据构造出我们需要的java bean。最后我们的调用过程可以简化成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public UserInfo getUserInfo() &#123;</div><div class="line">    return (UserInfo) hBaseTemplate.get(TABLE_NAME, rowKey,    familyName,</div><div class="line">        (result, i) -&gt; new HBaseResultBuilder&lt;&gt;(familyName, result, UserInfo.class).build(&quot;name&quot;).build(&quot;password&quot;).fetch());</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>成功！！！是不是代码整洁多了，其实也就是将一些复杂的逻辑给抽出去了，正好最近看了Java8实战，从而萌生的一点小想法。</p>
]]></content>
      
        
        <tags>
            
            <tag> Hbase </tag>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2016/10/02/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
