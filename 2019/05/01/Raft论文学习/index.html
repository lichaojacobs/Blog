<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Raft论文学习 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Raft论文学习</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Raft论文学习</h1><div class="post-meta">May 1, 2019<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式系统领域自然离不开一致性协议，而其中以Paxos和Raft最为著称。Paxos和Raft早两年有接触过，受限于当时的知识水平，对实现细节难免囫囵吞枣；最近决心专供分布式系统，于是重新拾起相关Paper开始拜读。以下是Raft 论文读后总结</p>
<h2 id="Raft-五大性质"><a href="#Raft-五大性质" class="headerlink" title="Raft 五大性质"></a>Raft 五大性质</h2><ul>
<li><strong>Election Safety</strong>: 在每一个term里，<em>至多</em>（有可能没有）只能有一个leader被选出</li>
<li><strong>Leader Append-Only</strong>: leader节点不会对自身的log entries 进行覆写/删除的操作；只是单纯的append</li>
<li><strong>Log Matching</strong>: 如果两个log entry 拥有相同的index和term，那么这两个entry是相等</li>
<li><strong>Leader Completeness</strong>: 在一个term中，如果log entry被commit了，那么这个entry 将会存在于所有的其他任期的leader中（<em>也是作为Candidate是否被选中的一个条件</em>）</li>
<li><strong>State Machine Safety</strong>:  如果一个节点apply 了一个log entry，那么带有相同index却不同的log entry是不能被其他任何一个节点所apply</li>
</ul>
<h2 id="Raft-组成部分"><a href="#Raft-组成部分" class="headerlink" title="Raft 组成部分"></a>Raft 组成部分</h2><ul>
<li>Raft 由 Leader，Follower以及Candidate三种角色组成，三者之间组成有限状态机，可在一定事件下互相切换，具体如下图<br><img src="https://pic4.zhimg.com/80/v2-393502082f95a7432687a6fbe19d7cdf_hd.jpg" alt=""></li>
<li>根据上图，角色对应的分工如下<ul>
<li>Follower<ul>
<li>响应candidates和leader的 rpc请求</li>
<li>如果leader在timeout之内未发送心跳，则主动切换为candidate发起新一轮选举</li>
</ul>
</li>
<li>Candidate：主要是选举<ul>
<li>将currentTerm +1，且投给自己，并发起Request Vote RPC给所有其他节点寻求投票</li>
<li>如果收到大多数节点投票，则变成leader，通知所有节点切换为follower</li>
<li>如果通过AppendEntries RPC说明新的leader选举成功，则将自己置为follower</li>
<li><em>可能出现都投自己的情况（极端）</em>：这种情况的处理机制是所有candidate 任意sleep 一段时间（<strong><em>150-300ms</em></strong>），再触发新一轮选举</li>
</ul>
</li>
<li>Leader:<ul>
<li>维持心跳，防止触发leader选举</li>
<li>如果接收到客户端append log请求，leader 会并发地向followers 发起AppendEntries Rpc请求，等大多数follower 节点都返回成功之后再将log entry本地commit,  并将结果最终结果返回给客户端；如果失败则retry，正常的请求处理流程如下图<br><img src="https://pic3.zhimg.com/80/v2-618a3dfc4c9169a6b486416c2c510516_hd.jpg" alt=""></li>
<li>在收到客户端append log 请求后，检测是否最新的log index大于nexIndex 中的值，如果是，则需要给follower 发送AppendEntries RPC请求<ul>
<li>请求成功：更新nextIndex和matchIndex</li>
<li>请求失败：一般是因为leader重选导致<em>数据不一致</em>，则减小nextIndex 重新发送AppendEntries RPC，如此往复，直到找到follower 与 leader 同步的最近一条log entry为止<br><img src="https://pic2.zhimg.com/80/v2-d81511e3cf92859cae0f37d2a05da2e5_hd.jpg" alt=""></li>
</ul>
</li>
<li>如果存在N， N&gt;CommitIndex，大多数matchIndex[follower]&gt;=N，且log[N].term == currentTerm，则将commitIndex 置为N</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现Raft的数据结构"><a href="#实现Raft的数据结构" class="headerlink" title="实现Raft的数据结构"></a>实现Raft的数据结构</h2><ul>
<li><p>消息状态划分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Uncommit: 未提交转态（Client发到主节点，主节点还没有得到大多数从节点的提交回执）</span><br><span class="line">Commited: 已提交转态（从节点收到主节点的消息提交，还未收到确认报文）</span><br><span class="line">Applied: 已确认转态（从节点收到主节点的确认报文，或主节点已收到大多数从节点的提交回执）</span><br></pre></td></tr></table></figure>
</li>
<li><p>State ：每个节点的状态</p>
<ul>
<li>在所有节点上都有的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//实际落盘的</span><br><span class="line">currentTerm：通过rpc接到的最新的任期，初始化为0，随着选举次数增加而增加</span><br><span class="line">votedFor: 保存着一次选举过程中所投的candidateId，为空表示还未投票</span><br><span class="line">log[]: log entries集合，每个entry由记录和所属任期组成 tuple2&lt;command,term&gt;</span><br><span class="line">//在内存中实时可见的</span><br><span class="line">commitIndex: 已确认被commit了的最高位的log entry index</span><br><span class="line">lastApplied: 被当前节点applied的最高位的log entry index</span><br></pre></td></tr></table></figure>
<ul>
<li>在leader 上的状态，每一次选举过后都会在新的leader上重新初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nextIndex[]: 保存着每一个follower节点的下一个log entry index;初始化中leader last log index +1</span><br><span class="line">matchIndex[]: 保存着每一个follower已经被确认replicate成功的最高位的log entry index；初始化为0</span><br></pre></td></tr></table></figure>
<ul>
<li><p>RequestVote RPC 工作模式<br><img src="https://pic1.zhimg.com/80/v2-0b504b0909c97d306c936e4d8a422ee8_hd.jpg" alt=""></p>
</li>
<li><p>AppendEntries RPC工作模式</p>
<ul>
<li>由leader 发起log replicate，以及维护leader to follower 心跳，防止新一轮election触发<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//rpc 请求参数</span><br><span class="line">term：leader term</span><br><span class="line">leaderId:</span><br><span class="line">pervLogIndex: 上一次apply过的 log 对应的Index</span><br><span class="line">prevLogTerm: 上一次apply过的log 对应的term</span><br><span class="line">entries[]: 要同步的log entries，之所以是数组是优化性能，减少rpc调用次数</span><br><span class="line">leaderCommit: leader最近一次提交的commitIndex</span><br><span class="line">//rpc 返回值</span><br><span class="line">term: follower 当前的term</span><br><span class="line">succss: 如果follower mactch了prevLogIndex和prevLogTerm返回true</span><br><span class="line">//replicate 处理逻辑</span><br><span class="line">如果term&lt; currentTerm，则返回false</span><br><span class="line">如果match 不上prevLogIndex和prevLogTerm 则返回fase</span><br><span class="line">如果当前节点存在相同index但是不同term的entry，则强制删掉该index之后所有的entry，从该节点往后同步leader log entry</span><br><span class="line">如果 leaderCommit &gt; commitIndex, 将commitIndex 设置为min(leaderCommit, index of last new entry)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-01f3b77c9c02f8e2b949b57418f140e1_hd.jpg" alt=""></p>
<h2 id="Leader崩溃"><a href="#Leader崩溃" class="headerlink" title="Leader崩溃"></a>Leader崩溃</h2><h3 id="如何保证follower跟新leader的数据一致性"><a href="#如何保证follower跟新leader的数据一致性" class="headerlink" title="如何保证follower跟新leader的数据一致性"></a>如何保证follower跟新leader的数据一致性</h3><ul>
<li>问题：旧leader挂掉之后，follower通过心跳感知，并转为candidate，触发新一轮选举。新leader产生之后，leader和follower之间很可能存在数据不一致的情况：某些log entry在leader上不存在</li>
<li>Raft的做法是：leader会强制follower 完全复制自己的数据，这样会导致follower上的log entries 可能会被覆写删除（<strong>Kafka中partition leader与follower 之间的Sync参考了这一点</strong>）<br><img src="https://pic4.zhimg.com/80/v2-45bb7e6e89a1d8d5d421d29e3f3a3f5b_hd.jpg" alt=""><ul>
<li>如上图，通过不断的retry之后找到leader和follower之间一致的log entry；从那个entry之后开始同步（强行覆写）<h3 id="如何防止brain-split后log-entries正确性"><a href="#如何防止brain-split后log-entries正确性" class="headerlink" title="如何防止brain split后log entries正确性"></a>如何防止brain split后log entries正确性</h3></li>
</ul>
</li>
<li>问题：如果集群中某一个follower 由于网络问题，长时间没收到leader心跳，如果这时它选自己为leader，等到网络恢复后是不是会成为新的leader覆写之前被commit 的log entry？</li>
<li>Raft做法：增加被选为Leader的限制(<strong>参考性质*Leader Completeness</strong>)<ul>
<li>Raft 确保只有那些包含所有committed log entries（majority） 的candidates 才有资格被选为leader </li>
<li>实现：Vote RPC中包含了candidate 的log 信息，这样voter就可以通过对比自己的日志中log entry 的 index和term来判断candidate 是不是比自己日志更latest<h3 id="如何继续leader-crash之前的commit操作"><a href="#如何继续leader-crash之前的commit操作" class="headerlink" title="如何继续leader crash之前的commit操作"></a>如何继续leader crash之前的commit操作</h3></li>
</ul>
</li>
<li>这个问题存在的前提是新一轮leader election 被选为新leader的节点上保存了上一个leader 未commit成功的log entry；<strong>在raft协议中只确保commit 当前leader中的log entries会按照副本数机制实现(num of replicas &gt; num of node / 2  )</strong><br><img src="https://pic3.zhimg.com/80/v2-51183acb3121e6f1ad07bfc4b49e4ef6_hd.jpg" alt=""><ul>
<li>这种确保的是：如果一条log entry 被当前leader commit成功，那么可以认为之前所有的entries 都commit成功了（<strong>参考特性5 — Log Matching Property</strong> ），<strong>也不需将之前的log entry的term 改成current term</strong></li>
</ul>
</li>
</ul>
<h2 id="Follower-amp-amp-Candidate崩溃"><a href="#Follower-amp-amp-Candidate崩溃" class="headerlink" title="Follower&amp;&amp;Candidate崩溃"></a>Follower&amp;&amp;Candidate崩溃</h2><ul>
<li>follower 和 candidate 崩溃处理方式比较简单<ul>
<li>如果一个follower 或者 candidate 挂掉了，RequestVote 和 AppendEntries RPC 都会失败，处理的方式就是无限次的retry，只要服务重启，就能随着rpc 同步到最新的状态</li>
</ul>
</li>
</ul>
<h2 id="集群扩缩容"><a href="#集群扩缩容" class="headerlink" title="集群扩缩容"></a>集群扩缩容</h2><ul>
<li>目前我们讨论的都是在一组固定的节点上操作，但是在现实中存在因为节点的down掉以及扩容的需求，需要变更集群节点。 如果直接变更的话，可能会出现一段时间brain split的情况。最稳妥的方案就是将服务全部下线，扩容完成之后再重新上线，但是这过于低效<br><img src="https://pic4.zhimg.com/80/v2-fd51d6fa5b917864b632463c272b301b_hd.jpg" alt=""><ul>
<li>如图表示的是滚动升级的情况，逐个重启旧server，会存在新旧两个leader同时存在的情况（各自都赢得了所在集群大多数的vote）</li>
</ul>
</li>
<li>解决方案：<em>引入一种特殊类型的log entry</em>，专门用来做集群配置更替，把它叫做C (old,new)，当C(old,new)被commit之后集群进入 joint consensus（联合一致性），即<em>新旧集群共存</em>的状态。在这种状态下，需遵循的规则如下：<ul>
<li>Log entries将被replicate到新旧配置的所有server节点中</li>
<li>任何一个节点通过新旧任何一份配置都有权利在选举中成为leader</li>
<li>选举结果和log entry commitment的决定需要各自配置中的大多数节点认可</li>
</ul>
</li>
<li>讨论集群扩容的例子<br><img src="https://pic4.zhimg.com/80/v2-01972efd90a47cab1e3e3339a6c4d2e7_hd.jpg" alt=""><ul>
<li>第一阶段：逐台变更时，部分server上处于C(old,new) 状态，此时leader选举只能从C(old, new) 或 C(old) 中产生，具体取决于candidate是否接收到了C(old,new)  log entry；当C(old, new) 被最终committed，则只拥有C(new)和C(old) 的server将再无法被选举为leader（<strong>参考特性4 — Log Matching Property</strong>）</li>
<li>第二阶段：接着再引入一种log entry C(new) ，将它同步到所有节点，等C(new) 最终committed之后则集群切到了C(new)</li>
</ul>
</li>
<li>需注意的点<ul>
<li>新上的节点会存在相对于老集群数据落后的情况，需要一段时间的sync，以追上其他节点，这期间不做任何<em>投票</em>操作（此处可类比Doris 里面Observer的设计理念）</li>
<li>第二阶段结束时，下掉的节点可能不在新集群的配置里面，也就不会接收到心跳，这样可能触发下掉的server leader选举<ul>
<li>为防止扰乱集群可以规定：server如果在timeout允许的范围内正常的接收到了leader的心跳，则会忽略其他RequestVote Rpc请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><ul>
<li>日志如果不做压缩处理，理论上会无限期膨胀，期间可能很多重复多余的数据，浪费空间</li>
<li>最简单的做法就是利用snapshot，将系统整个的状态数据作为一个snapshot保存到stable storage上，这样在上一个时间点的snapshot就可以被删除了（FLink的 checkpoint 和Doris的metadata里面也是这么做的）<br><img src="https://pic3.zhimg.com/80/v2-8f6e62d58a0ac891021bc119c3f9f1de_hd.jpg" alt=""></li>
<li>一些其他的方式如：LSM Tree, log cleaning 等都可以</li>
</ul>
<h2 id="客户端设计的原则"><a href="#客户端设计的原则" class="headerlink" title="客户端设计的原则"></a>客户端设计的原则</h2><ul>
<li>首先客户端需要具备请求超时重发机制：请求random server会被reject，如果leader 挂掉触发选举也需要再一次的retry</li>
<li>Raft 对客户端的设计目标是要实现线性一致性语义，这样要求客户端每次command需要分配一个unique serial numer，在server端的state machine中会跟踪client最近一次的serial number，如果被serial number表示的command已经被执行完了则不会被再次执行（<strong>类似Doris 里面mini load Label的概念</strong>）</li>
<li><strong>只读订阅需求</strong>：（<strong>范例可了解Doris 元数据设计</strong>）为了降低leader节点的负载，可以允许client 请求follower节点读取数据；但是有一个缺点就是随着leader选举的过程，可能会读到过期的数据（被commited的数据没有被读到，这不满足线性一致性设计理念），针对这个, 有两种预防措施<ul>
<li>主节点选举成功之后，立即发一个空的log entry到所有节点，这样就触发了集群中所有follower节点向leader强制同步的过程</li>
<li>主节点在响应read-only请求之前必须确认自己是否已经过期，防止自身的信息处于过期的状态；<strong>确认方法是集群中大多数节点发送心跳</strong></li>
</ul>
</li>
</ul>
<h2 id="与Paxos的差异"><a href="#与Paxos的差异" class="headerlink" title="与Paxos的差异"></a>与Paxos的差异</h2><ul>
<li><a href="https://zh.wikipedia.org/zh-cn/Paxos%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Paxos</a> 可以同时提交和处理多个提案，但是发生冲突时，理论上会有更高的延时（协商时间），而Raft算法会天生地把消息确定一个先后顺序。大幅减少了冲突的可能性</li>
</ul>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://ol7zjjc80.bkt.clouddn.com/271524552778_.pic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2019/05/01/Raft论文学习/" data-id="ck61q9rnq000bogyhc11hrjtf" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJElEQVR42u3ay27FIAwFwPv/P51uuqiUJj3GpFJgWF2leTBUsmzM5xOP4zTO16/u/3nl/Pv+qckDAwPjtYzjdtwzkmnlb0i+e0nFwMDYgJFMIgmR1ac6b8DAwMCY8OpGWomBgYHxRMBNJnpfpt4HXwwMDIw8XcsZ+XLkpe+EWhwDA+OFjHzX/f9/P9LfwMDAeBXjKI5qwpc/Ozaf72cxMDCWZlTTtSQty//aCbgYGBi7Ma4eHjta0Tm60Z8DBgbGeozOYa9ZLclqAvrLmzEwMJZmVBPBpOC8v3NW6xQDA2MfRjl/jLfSklBebZdeLjEGBsbSjLGDWdWjD/0EdLDjioGBsRCjP5UqcmzqfywxBgbGoozkA3l4rW7DVQP95f0YGBhLM+Zu6OdTzzfpyscsMDAwlmPMSvWqAbTfQsDAwNiHMauIrSaOY9cf+Z9gYGC8llHdLKtuxuVXkgMZGBgYuzGSonRW9Tz2zsslw8DAWJqRlKP3AbEziTxZTJqgGBgYqzKqAbe6KlXkYFqJgYGxDaOzxZ83FR4pmDEwMLZh5AcvkhJ07JjFYDMVAwNjUcZRHNWytt/UjL6LgYGxNKO66ZaUtf20clbRi4GBsRKjE2STiVbbjYPpIwYGxgaMauCrUvMmaLWlioGBgZFPsVOy5g1LDAwMjJyRb5n1U8ZoyTAwMDZgjB0Ly4vPzsZcqxOLgYGxBKNaOvbDaDVNzKkYGBjLMb4Al4KTYVG+GXkAAAAASUVORK5CYII=" class="article-share-link">分享</a><div class="tags"><a href="/tags/分布式/">分布式</a><a href="/tags/大数据/">大数据</a><a href="/tags/paper/">paper</a></div><div class="post-nav"><a href="/2019/05/26/【Spark源码分析】Dynamic-Resource-Allocation设计的思考/" class="pre">【Spark源码分析】Dynamic Resource Allocation设计的思考</a><a href="/2019/01/12/【spark-tips】spark2-4-0触发的executor内存溢出排查/" class="next">【spark-tips】spark2.4.0触发的executor内存溢出排查</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/MR任务在Hadoop子系统中状态流转/">MR任务在Hadoop子系统中状态流转</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Yarn-Federation源码串读/">Yarn Federation源码串读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Hadoop-Rpc源码分析/">Hadoop Rpc源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/">【Spark源码分析】Job提交执行过程详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/【Spark源码分析】Broadcast/">【Spark源码分析】Broadcast</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/【Spark源码分析】Dynamic-Resource-Allocation设计的思考/">【Spark源码分析】Dynamic Resource Allocation设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/Raft论文学习/">Raft论文学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/12/【spark-tips】spark2-4-0触发的executor内存溢出排查/">【spark-tips】spark2.4.0触发的executor内存溢出排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/20/Flink实战总结/">Flink实战总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/Spark学习笔记/">Spark实战总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/chao-li-11/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://weibo.com/3101672623/profile?topnav=1&amp;wvr=6" title="微博" target="_blank">微博</a><ul></ul><a href="https://github.com/lichaojacobs" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>