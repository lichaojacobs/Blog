<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Yarn Federation源码串读 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Yarn Federation源码串读</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Yarn Federation源码串读</h1><div class="post-meta">Nov 5, 2019<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p><a href="https://zhuanlan.zhihu.com/p/79378807" target="_blank" rel="noopener">知乎链接</a></p>
<h2 id="Federation架构总览"><a href="#Federation架构总览" class="headerlink" title="Federation架构总览"></a>Federation架构总览</h2><ul>
<li>Federation: 主要有四个模块，Router ，StateStore，AMRMProxy, Global Policy Generator；从架构上来看，有点类似于后端的微服务架构中<strong>服务注册发现</strong>模块</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-7ee20bc86d8be49d25b5ca3897d3278f_b.png" alt="img"></p>
<h2 id="Router模块"><a href="#Router模块" class="headerlink" title="Router模块"></a>Router模块</h2><ul>
<li>类似于微服务的网关模块；通过state store获取具体的集群配置策略，将client端submit请求转发到对应的subCluster中</li>
<li>代码结构</li>
<li>hadoop-yarn-server-router：router组件核心实现，分为对接admin用户的协议和client用户协议，以及web server三个子模块实现  </li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-b6ee24339266083c97b6642c4f3a081e_b.png" alt="img"></p>
<ul>
<li>hadoop-yarn-server-common-federation-router：包含了Router的各种Policy，具体控制router给子集群分配app的策略</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-e7402699fce4808743375957f68a8b11_b.png" alt="img"></p>
<h3 id="Router-clientrm"><a href="#Router-clientrm" class="headerlink" title="Router- clientrm"></a><strong>Router- clientrm</strong></h3><ul>
<li>负责接收客户端命令请求，并根据对应router具体配置的policy将客户端请求转发到HomeSubcluster上</li>
<li>在每一个router服务上随着启动，用来监听客户端作业提交，实现了Client与RM沟通的RPC协议接口(ApplicationClientProtocol)；作为client的proxy，执行一系列的chain interceptor），通常FederationClientInterceptor需作为最后一个拦截器</li>
<li>当然RouterClientRMService某种程度上针对的是Server测，取代原来RM侧<strong>RMClientService</strong>；在客户端具体的调用还是在<strong>YarnClientImpl</strong>；之间通过RPC通信</li>
<li>初始化： 获取配置文件中配置的拦截器，默认是DefaultClientRequestInterceptor  </li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-74b97de7e4a90be9f4f7f5e703dcbd56_b.png" alt="img"></p>
<ul>
<li>DefaultClientRequestInterceptor只是做了简单的请求透明转发；没涉及到多子集群的处理</li>
<li>FederationClientInterceptor：面向client，隐藏了多个sub cluster RM；但是目前只实现了四个接口：<strong>getNewApplication, submitApplication, forceKillApplication and getApplicationReport</strong></li>
<li><strong>FederationClientInterceptor</strong></li>
<li>clientRMProxies: 子集群id与对应的通信client的key value集合</li>
<li>federationFacade: 对应的state store具体实现</li>
<li>policyFacade: 路由策略的工厂  </li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-d6bbfd466b88388bdb9777d17d159210_b.png" alt="img"></p>
<ul>
<li>一个任务的提交需经过<strong>FederationClientInterceptor.getNewApplication</strong>和<strong>submitApplication</strong>接口，前者获得新的<strong>applicationId</strong>, 后者通过获得的<strong>applicationId</strong>将任务提交到具体的sub Cluster RM；这一个阶段没有经过与state store的写操作</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-6824ab1d9c5489ea0264ef5b79f9f075_b.png" alt="img"></p>
<ul>
<li>getNewApplication实现只是<strong>随机</strong>的选择一个active sub cluster来获取一个新的<strong>applicationId</strong>；而subClustersActive是通过具体实现的<strong>state store</strong>来获取，此处有过滤active的字段</li>
<li>submitApplication，方法注释有讨论各种failover的处理情况；</li>
<li>RM没挂的情况：如果state store 更新成功了，则多次提交任务都是幂等的</li>
<li>RM挂了：则router time out之后重试，选择其他的sub cluster</li>
<li>Client挂了：跟原来的/ClientRMService/一样</li>
<li>通过policyFacade加载策略，根据context与blacklist为当前提交选择sub cluster；具体逻辑在<strong>FederationRouterPolicy.getHomeSubcluster</strong>  </li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-c6dbd82e45d5c69bd30b07e4f7e077a3_b.png" alt="img"></p>
<ul>
<li>同步提交任务至目标sub cluster</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-da2fa220baae8ba7238a1b77bebe009a_b.png" alt="img"></p>
<p><strong>疑问&amp;&amp;待确定的点</strong></p>
<ul>
<li>client —&gt; router —&gt; rm： 这条链路如果router挂了如何failover；<strong>在submitApplication方法上方有较为详细的边界情况处理解释</strong></li>
<li><strong>是否支持多个router？以及在配置中如何指定多个router？防止一个router挂掉的情况</strong></li>
<li><strong>需要确定是否有机制来维系真正存活的cluster，是否会动态摘除down掉的RM</strong></li>
</ul>
<h2 id="Policy-State-Store模块"><a href="#Policy-State-Store模块" class="headerlink" title="Policy State Store模块"></a>Policy State Store模块</h2><h3 id="FederationStateStoreFacade"><a href="#FederationStateStoreFacade" class="headerlink" title="FederationStateStoreFacade"></a>FederationStateStoreFacade</h3><ul>
<li>作为statestore的封装，抽象出一些重试和缓存的逻辑</li>
</ul>
<h3 id="FederationStateStore"><a href="#FederationStateStore" class="headerlink" title="FederationStateStore"></a>FederationStateStore</h3><ul>
<li>一般采用<strong>ZookeeperFederationStateStore</strong>的方式</li>
<li><strong>ZookeeperFederationStateStore</strong>  实现中，对应的数据存储结构如下  </li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-b4e79639629bdec688ec4efb6f9b275f_b.png" alt="img"></p>
<ul>
<li>通过心跳维系了RM是否是active；通过<strong>filterInactiveSubClusters</strong>来决定是否需要过滤存活的RM</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-1de1b20d5b5a5c01c26e6724695cf440_b.png" alt="img"></p>
<ul>
<li><strong>实例化过程</strong></li>
<li>加载配置<strong><em>yarn.federation.state-store.class</em></strong>：默认实现是<strong><em>MemoryFederationStateStore</em></strong></li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-e5888bd36c0c482c10c2bb22782ceb27_b.png" alt="img"></p>
<h3 id="SubClusterResolver"><a href="#SubClusterResolver" class="headerlink" title="SubClusterResolver"></a>SubClusterResolver</h3><ul>
<li>用来判断某个指定的node是属于哪个子集群的工具类;主要有getSubClusterForNode，getSubClustersForRack方法</li>
<li>实例化过程</li>
<li>加载配置yarn.federation.subcluster-resolver.class: 默认实现是DefaultSubClusterResolverImpl</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-cf9ebad47e5c250ef5a545ee4e1c1b05_b.png" alt="img"></p>
<ul>
<li>在<strong>load</strong>方法中，获取了machineList，定义list的地方是在一个文件中通过<strong>yarn.federation.machine-list</strong>获取文件位置；且文件中的内容格式如下</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-7d1685ce8602e9884412e42a9faaf72e_b.png" alt="img"></p>
<ul>
<li>解析文件之后，将machine依次添加到<strong>nodeToSubCluster</strong>，<strong>rackToSubClusters</strong>集合中</li>
</ul>
<h2 id="AMRMProxy模块"><a href="#AMRMProxy模块" class="headerlink" title="AMRMProxy模块"></a>AMRMProxy模块</h2><ul>
<li>看完client—&gt;rm侧的提交任务模块之后（<strong>router</strong>），接下来可以分析AM与RM侧的交互模块(<strong>AMRMProxy</strong>)  </li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-d90061b8beeb05e40586a3dada4222a7_b.png" alt="img"></p>
<ul>
<li>AMRMProxyService ：如上图所示，起于所有的NM之上的服务，作为AM与RM之间通信的代理；会将AM请求转发到正确的HomeSubCluster</li>
<li>FederationInterceptor: 作为AMRMProxyService中的拦截器，主要做AM与RM之间请求转发</li>
</ul>
<h3 id="AMRMProxyService-—-FederationInterceptor"><a href="#AMRMProxyService-—-FederationInterceptor" class="headerlink" title="AMRMProxyService — FederationInterceptor"></a>AMRMProxyService — FederationInterceptor</h3><ul>
<li>类比Router，FederationInterceptor作为AMRMProxy的请求拦截处理</li>
<li>在AM的视角，<strong>FederationInterceptor</strong>的作用就RM上的<strong>ApplicationMasterService</strong>；AM通过<strong>AMRMClientAsyncImpl</strong>或<strong>AMRMClientImpl</strong> 走RPC协议与<strong>AMRMProxyService</strong> 交互</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-0ec5e08fa702ab8a00bb11528da4b138_b.png" alt="img"></p>
<p><strong>registerApplicationMaster详解</strong></p>
<ul>
<li>按照正常的AM流程分析，由<strong>AMLauncher</strong>启动container之后须首先会调用<strong>registerApplicationMaster</strong>方法初始化权限信息以及将自己注册到对应的RM上去；对应到<strong>FederationInterceptor</strong>是如下方法</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-a322c31e9908ed4f8b08c05130c67688_b.png" alt="img"></p>
<ul>
<li>制造一种假象：RM永不会挂掉；有可能会因为超时或者RM挂掉等原因而导致发出多个重复注册的请求，此时都会返回最近一次成功的注册结果；所以这也就是为什么registermaster这个方法必须为线程安全的原因</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-e127ca2f6e0120575bc76c5b38126a43_b.png" alt="img"></p>
<ul>
<li>目前只是往HomeSubCluster上注册AM，而不会往其他子集群上注册。是为了不影响扩展性；即不会随着集群的增多AM呈线性扩展；应该是后续按需注册sub-cluster rm</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-571134517c85d3c6fd5a237412618a74_b.png" alt="img"></p>
<ul>
<li><strong>this.homeRMRelayer</strong>是具体的跟RM通信的代理，其创建方式在<strong>FederationInterceptor.init</strong>方法中</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-4afe5125de9a0e80a3440f6807e12e84_b.png" alt="img"></p>
<ul>
<li>最后在返回response之前，会根据作业所属的queue信息从statestore中获取对应的策略，并初始化<strong>policyInterpreter</strong></li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-bab165a60bd63a3c43549950825d28a0_b.png" alt="img"></p>
<h3 id="Allocate详解"><a href="#Allocate详解" class="headerlink" title="Allocate详解"></a>Allocate详解</h3><ul>
<li>周期性的通过心跳与HomeCluster和SubCluster RMs交互；期间可能伴随有SubCluster 上AM的启动和注册</li>
<li><strong>splitAllocateRequest</strong>：将原来的request重新构造成面向所有已经注册的sub-cluster rm request</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-bf455e34f88d53a7dcc5ffea1d51d8a9_b.png" alt="img"></p>
<ul>
<li>具体到实现：通过requestMap来放置clusterId与allocateRequest的对应关系；通过uamPool获取已经注册UAM的sub clusterId并构建request</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-3bb90c887c818638bb335ff6d46b9d46_b.png" alt="img"></p>
<ul>
<li>后面的步骤是根据所有已经注册的home cluster和sub cluster id构建release, ask, blacklist等请求</li>
<li>对于资源的请求拆分：这里会去调federation policy interpreter将原来request中的<strong>askList(Resource Request List)</strong>根据策略拆分到各个子集群；所以这里会涉及到Federation Policy调用，具体的分析接下来会单独拎出一小节解释</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-675411d4dfdc72c8d89ee301a8709b7c_b.png" alt="img"></p>
<ul>
<li>拿到<strong>asks</strong>后，会将<subclusterid, resourcerequestlist="">的对应关系，加入到<strong>requestMap</strong>中</subclusterid,></li>
<li><strong>注意：</strong>这里借助<strong>findOrCreateAllocateRequestForSubCluster</strong>方法实现如果requestMap中不存在asks中对应的subClusterId，会新new一个request塞入map；后续这个request会在对应的subCluster上启动<strong>UAM</strong></li>
<li><strong>因为对于新的job，刚开始确实是只在homeCluster上启动了AM</strong></li>
<li><strong>sendRequestsToResourceManagers</strong></li>
<li>splitAllocateRequest之后就是将构造好的请求发送到对应的cluster上；顺带在所有的subcluster启动UAM并注册上(如果之前没有启动的话)；返回值是所有新注册上的UAM</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-34f142d2135a9f8b12ae234966bde9b6_b.png" alt="img"></p>
<ul>
<li><strong>registerWithNewSubClusters</strong> 用来在其他子集群中创建新的UAM实例</li>
<li>在uamPool中不存在的被认为是新集群（<em>有点与<strong>splitAllocateRequest</strong>） 取AllUAMIds逻辑矛盾</em>）</li>
<li>对newSubClusters集合迭代，依次在subClaster上启动UAM，并注册UAM</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-1051b6772a9c893a910f3497cb9cc327_b.png" alt="img"></p>
<ul>
<li>最后针对不同的cluster，调用不同的clientRPC请求资源</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-2e0d3265a416a8bd9131559ce958b2f1_b.png" alt="img"></p>
<ul>
<li><strong>mergeAllocateResponses</strong></li>
<li>用于合并所有资源请求返回的allocateResponse。实现里面是对<strong>asyncResponseSink</strong>容器的迭代，而asyncResponseSink的写入是在HeartBeatCallback逻辑里的</li>
<li>对于allocateResponse的合并操作在<strong>mergeAllocateResponse</strong>中</li>
<li><strong>mergeRegistrationResponses</strong></li>
<li>是在注册完其他的sub cluster之后将UAM加入到最终合并的AllocateResponse中；主要是对allocatedContainers以及NMTokens集合做增加</li>
</ul>
<h3 id="finishApplicationMaster详解"><a href="#finishApplicationMaster详解" class="headerlink" title="finishApplicationMaster详解"></a>finishApplicationMaster详解</h3><ul>
<li>结束任务的时候有点类似allocate，需要向所有的sub cluster发送finish请求；目前是丢到一个compSvc线程池中批量执行*finshApplicationMaster</li>
<li>在线程池中执行sub cluster finish的同时，也会调用home cluster rm进行finish操作</li>
</ul>
<h2 id="Federation-Policy模块"><a href="#Federation-Policy模块" class="headerlink" title="Federation Policy模块"></a>Federation Policy模块</h2><ul>
<li>federation policy模块通过FederationPolicyManager的接口实现来统一加载</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-6a2db128fc5762aba3591cf4912bfc40_b.png" alt="img"></p>
<ul>
<li><strong>FederationPolicyInitializationContext</strong>：初始化FederationAMRMProxyPolicy和FederationRouterPolicy的上下文类</li>
<li><strong>federationStateStoreFacade</strong>: policy state strore的具体实现实例</li>
<li><strong>federationPolicyConfiguration</strong>: 具体的策略配置</li>
<li><strong>federationSubclusterResolver</strong>：用来判断某个指定的node是属于哪个子集群的工具类</li>
<li><strong>homeSubcluster</strong>：当前application实际AM运行的集群ID</li>
</ul>
<h2 id="Policy-具体的实现列举"><a href="#Policy-具体的实现列举" class="headerlink" title="Policy 具体的实现列举"></a>Policy 具体的实现列举</h2><h3 id="amrmproxy模块的policy实现"><a href="#amrmproxy模块的policy实现" class="headerlink" title="amrmproxy模块的policy实现"></a>amrmproxy模块的policy实现</h3><ul>
<li><strong>LocalityMulticastAMRMProxyPolicy</strong></li>
<li>\1. 如果是有偏好的host的话，会根据<em>SubClusterResolver</em> resolve cluster的结果转发到对应的cluster，但如果没有resolve的话，会默认将请求转向home cluster</li>
<li>\2. 如果有机架的限制，策略同上</li>
<li>\3. 如果没有host/rack偏好的话，会根据<em>weights</em>转发到对应的集群；weights的计算根据<em>WeightedPolicyInfo</em>以及<em>headroom</em>中的信息</li>
<li>\4. 所有请求量为0的请求都会转发到所有我们曾经调度过的子集群中（以防用户在尝试取消上一次的请求）</li>
<li>注：该实现始终排除当前未活跃的RM</li>
<li><strong>具体实现细节待深究</strong></li>
</ul>
<p><strong>router模块的policy实现</strong></p>
<ul>
<li>总体来说router端的策略偏简单，自己定制也容易</li>
<li>默认实现是<strong>UniformRandomRouterPolicy</strong>，随机转发client请求到某个alive的cluster</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li>在NM侧，不能开启<strong>FederationRMFailoverProxyProvider</strong>，这个统一在获取RMAddress逻辑上有不足，导致NM启动时拿到的RMAddress是localhost无法通过ResourceTracker连上RM，最终注册失败</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-edc97c0d9ba93b9094e561e6cd7b5464_b.png" alt="img"></p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://ol7zjjc80.bkt.clouddn.com/271524552778_.pic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2019/11/05/Yarn-Federation源码串读/" data-id="ck61q9ro3000nogyhqhaabp2o" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIklEQVR42u3aQW7DMAwEwPz/0y7QU4HU7pJyUoQanYpEtTM6EBTJxyNex/dKvj1+rOc9Zzuf1+MVCwMD42MZyeOSl1Wfc30QZSoGBsYGjCSM9kLz9XOq+08/x8DAwIgDZR6yr7M7DAwMjLsYSWKXMK7xGBgYGPnlsxock5/+D3dxDAyMD2RUr6bv/PuF/Q0MDIwPYRwLq1oae93CwMCYzVi5aiaXz2qzM3lLdBfHwMAYx8jD4krpbaU5WtiPgYExjtErYN3VgOyF2l+ejIGBsQGjF4J7yLxRWgjWGBgYGzOug2m+M2lPXoOjHiwGBsZoRh52q6W3fA8GBgbGCiMnJaWx5JPq8WFgYMxm5FfKatpXvaZWj+YPDAYGxiBGr8TfG8hICnDNgI6BgbENo/ezkiJ+9VJabmpiYGCMZqykgHnCdy/jNIhjYGAMZfSuoNXhjLtKdYXUEAMDYxCjOnixUm7LS2x5gMbAwNiBUR19yIPv+v8WGp8YGBijGdUUcCXtq6aPvQIfBgbGPEbPvT5Glof7aE4EAwNjNKPXdMwHuXoNzl66iYGBMZVxFFevAZkX+qsJKAYGxg6M9Wi93iq4C4+BgTGbUQ2yyankwXEl4GJgYOzGSIJsddj0hmQuL89hYGBgxM3FvMJXPZTyRAYGBsaWjPwJebp5W+sUAwNjA0bvEpu3P6uBO2mmng6HYWBgjGP0GgP5a3rDXtW0EgMDYyjjC6J1jnQ4Mx/nAAAAAElFTkSuQmCC" class="article-share-link">分享</a><div class="tags"><a href="/tags/架构/">架构</a><a href="/tags/Hadoop/">Hadoop</a><a href="/tags/Yarn/">Yarn</a></div><div class="post-nav"><a href="/2020/01/07/MR任务在Hadoop子系统中状态流转/" class="pre">MR任务在Hadoop子系统中状态流转</a><a href="/2019/11/05/Hadoop-Rpc源码分析/" class="next">Hadoop Rpc源码分析</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/MR任务在Hadoop子系统中状态流转/">MR任务在Hadoop子系统中状态流转</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Yarn-Federation源码串读/">Yarn Federation源码串读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Hadoop-Rpc源码分析/">Hadoop Rpc源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/">【Spark源码分析】Job提交执行过程详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/【Spark源码分析】Broadcast/">【Spark源码分析】Broadcast</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/【Spark源码分析】Dynamic-Resource-Allocation设计的思考/">【Spark源码分析】Dynamic Resource Allocation设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/Raft论文学习/">Raft论文学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/12/【spark-tips】spark2-4-0触发的executor内存溢出排查/">【spark-tips】spark2.4.0触发的executor内存溢出排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/20/Flink实战总结/">Flink实战总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/Spark学习笔记/">Spark实战总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/chao-li-11/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://weibo.com/3101672623/profile?topnav=1&amp;wvr=6" title="微博" target="_blank">微博</a><ul></ul><a href="https://github.com/lichaojacobs" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>