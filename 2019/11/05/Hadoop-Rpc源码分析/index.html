<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content><title>Hadoop Rpc源码分析 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Hadoop Rpc源码分析</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Hadoop Rpc源码分析</h1><div class="post-meta">Nov 5, 2019<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>Hadoop生态系统中Rpc底层基本都是走的一套实现，所以有必要对Rpc底层实现做一次系统性的梳理总结。<br><a href="https://zhuanlan.zhihu.com/p/88768710" target="_blank" rel="noopener">知乎专栏链接</a></p>
<p><strong>Client&amp;Server实现入口</strong></p>
<p>RpcEngine作为Rpc实现的接口，用来获取client端proxy和server端的server</p>
<ul>
<li>主要的实现是WritableRpcEngine，ProtobufRpcEngine（现默认），两者的区别主要是序列化与反序列化的协议不同；内部都有继承Server构成完整Rpc Server的实现类</li>
<li>IPC.Server是两种序列化协议的基类，org.apache.hadoop.ipc.Server 主要实现了Reactor的请求处理模式</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-c8db58fa71163284be19a5ef5d18226b_b.jpg" alt="img"></p>
<h2 id="Client-amp-Server-构造方式"><a href="#Client-amp-Server-构造方式" class="headerlink" title="Client &amp; Server 构造方式"></a>Client &amp; Server 构造方式</h2><ul>
<li>按照序列化协议区分两种实现：ProtobufRpcEngine, WriteableRpcEngine</li>
<li>通过接口getProxy 构造RpcClient</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-88bd21ee56a1cd64a95d970c67c743a5_b.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-92891b943d699abd3dbb68332be7c6e4_b.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/v2-1a71694dbcf4d96672256ed37fa33cf9_b.jpg" alt="img"></p>
<ul>
<li>getServer构造RpcServer</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-7ea92e7484f556a3f658e79a751e19a1_b.jpg" alt="img"></p>
<h3 id="RPC-Client剖析"><a href="#RPC-Client剖析" class="headerlink" title="RPC Client剖析"></a>RPC Client剖析</h3><p>总体来说Client端实现比较简单，用hashTable的结构来维护connectionId -&gt; connections以及callId -&gt; calls 对应关系，使得请求响应不需要有严格的顺序性</p>
<ul>
<li>Ipc.Client构成</li>
<li>callIdCounter：callId 发号器</li>
<li>rpc_client.png: HashTable结构，用来维护Id → Connection的映射</li>
<li>sendParamsExecutor：请求发送线程池    </li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-9b923f98235d7881f79f9525f2a025f5_b.jpg" alt="img"></p>
<ul>
<li>Connection：自身是一个线程</li>
<li>calls: HashTable结构，请求结束将从call从HashTable中移除</li>
<li>sendRpcRequest：用户线程中通过call入口调用，用户线程阻塞</li>
<li>receiveRpcResponse:  run中不断轮询server看结果是否就绪</li>
<li>client 处理过程</li>
</ul>
<p><img src="http://jacobs.wanhb.cn/images/rpc_client.png" alt="img"></p>
<ul>
<li>通过反射获取到方法描述，走client Invoker调用远程实现</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-a73c35b6ffe44b32f40f638f110d0ac6_b.jpg" alt="img"></p>
<ul>
<li>getConnection中与远程server 建立socket 连接，并将连接加入connections集合中</li>
<li>在用户线程中调用connection.sendRpcRequest，阻塞的获取结果</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-9ace991f5df04fde6559437de1e46402_b.jpg" alt="img"></p>
<ul>
<li>Connection自身run方法中不停的轮询Server接收返回结果</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-d4ebd6403c80e86bb7ea7acff2b3e643_b.jpg" alt="img"></p>
<ul>
<li>waitForWork用来判断当前connection是否应该继续存在，返回true则继续轮询server，如果是false则关闭当前connection</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-c46e3a852373a74fa752a8b1edfe176f_b.jpg" alt="img"></p>
<ul>
<li><strong>receiveRpcResponse</strong>接收服务端返回结果，将calls移除table，可以乱序，通过ConnectionId索引，<strong>不需要同步代码块，因为只有一个receiver</strong></li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-347d4bb3e5d6bafe471a1b8e686343e8_b.jpg" alt="img"></p>
<h3 id="RPC-Server剖析"><a href="#RPC-Server剖析" class="headerlink" title="RPC Server剖析"></a>RPC Server剖析</h3><ul>
<li>Server端采用经典的Reactor模式，利用IO多路复用实现事件驱动</li>
<li>痛点在于多路复用之前的处理模式，socket read/write是阻塞的，一个线程只能处理一个socket；使用selector之后一个进程可以监视多个进程文件描述符</li>
</ul>
<p>参考阅读：<a href="https://www.cnblogs.com/crazymakercircle/p/9833847.html" target="_blank" rel="noopener">Reactor模式</a>、<a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html#4310290" target="_blank" rel="noopener">Java  NIO   底层原理 </a> 、<a href="https://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="noopener">select、poll、epoll</a></p>
<p><img src="https://pic1.zhimg.com/v2-58df22a9108b9c724c8b757f6357d8c4_b.jpg" alt="img"></p>
<p>图片摘自《Hadoop技术内幕：深入解析MapReduce架构设计与实现原理 》</p>
<ul>
<li>Reactor 工作图</li>
<li>Reactor：负责响应IO事件，将事件派发到工作线程</li>
<li>Acceptor：用来接收Client端的请求，建立Client与handler的联系；向Reactor注册handler</li>
<li>Reader/Sender：为了加快速度，同时做到请求和处理过程的隔离，reader和sender 分别是两个线程池，用来存放该过程处理完后的连接，处理完之后塞入中间队列，等待下一个过程的线程拿去处理就行</li>
<li>Handler：connection对应的工作线程，会做一些decode, compute, encode工作</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-64e02ba7cce407bf7d191ce4b08bfdeb_b.jpg" alt="img"></p>
<p><strong>Hadoop RpcServer组成结构</strong></p>
<ul>
<li><strong>序列化层</strong>：RpcRequestWrapper, RpcResponseWrapper</li>
<li><strong>接口调用层</strong>：RpcInvoker，通过反射方式阻塞调用Server端具体的Service方法；调用前后记录一些metrics信息</li>
<li>在handler线程处理逻辑中，通过注册的rpcKind获取对应的RpcInvoker实现，通过反射来调用工作层的Service</li>
<li><strong>请求接收/返回层Ipc.Server</strong>：基于Java NIO实现的Reactor 事件驱动模式</li>
<li>Listener</li>
<li>selector：监听请求 → 建立连接 → 派发到Reader线程</li>
<li>Readers</li>
<li>readSelector：解析&amp;封装Call → 塞入CallQueue </li>
<li>Handlers：工作线程</li>
<li>并行pull CallQueue，调用RpcInvoker处理</li>
<li>Responder：read request和write response采用不同的selector实现读写分离</li>
<li>writeSelector</li>
<li>connectionManager: 定时清理idle时间过长的Connection</li>
<li>CallQueue：reader handler之间的缓冲队列，<strong>生产消费者模型</strong></li>
</ul>
<h3 id="RPC-Server-处理流程"><a href="#RPC-Server-处理流程" class="headerlink" title="RPC Server 处理流程"></a>RPC Server 处理流程</h3><p><img src="https://pic2.zhimg.com/v2-38a1ef7504f6e74ba8bb4aa3a0a1bdb5_b.jpg" alt="img"></p>
<ul>
<li>Listener → Reader 请求建立过程：Listener<em>Reader</em>Connection</li>
<li>Listener线程只有一个，通过Selector方式监听客户端的Rpc请求(OP_ACCEPT事件)，调用doAccept方法建立连接；此时connectionManager线程开始工作</li>
<li>建立连接后，roundbin方式获取一个reader线程，将连接塞入reader线程的pending队列和connectionManager中</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-3d7ddb917b9a9bba707c2208e9b71c4f_b.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/v2-fb8edf28b12530ea9f49ce030d780f7b_b.jpg" alt="img"></p>
<ul>
<li>Reader线程doRunLoop中，将pending的connections注册到readSelector中，用来监听一个connection读就绪事件</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-c3056224c1b460860b0b9c26c2ccc182_b.jpg" alt="img"></p>
<ul>
<li>数据读入 → 工作线程 : Reader<em>Connection</em>CallQueue</li>
<li>而后Reader通过selector方式，只要监听的channel有读事件，则调用doRead方法；其中通过selectionKey获取关联的connection对象，调用connection的readAndProcess方法</li>
<li>connection.readAndProcess: 主要是将channel里面的数据读入data byteBuffer中，数据读完之后调用processOneRpc 进一步处理</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-01d207ac87060718231e7d6a32599412_b.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/v2-74ff999fb2c4844c9470e9d3bfefa943_b.jpg" alt="img"></p>
<ul>
<li>connection. processOneRpc 对buffer decode构造成DataInputStream以及RpcHeader（请求元信息，协议类型等）通过processRpcRequest将请求塞入CallQueue中，等待handlers处理</li>
<li>connection.processRpcRequest：通过header中指定的rpc engine将dataInputStream根据不同engine反序列化协议反序列化成rpcRequestWrapper；构造Call对象塞入CallQueue, 并incrRpcCount</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-46cd9573bbe1ffd820a5a22ca16628d9_b.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-195514acc9cc988cd2b7c14f45a535d4_b.jpg" alt="img"></p>
<ul>
<li>Handler → RpcInvoker → Responder</li>
<li>Handler线程在Server start的时候就已经构建启动了</li>
<li>并行pull callQueue获取队列中未处理的call，调用call方法</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-cc649767778d9769384fde11b8b7a5c0_b.jpg" alt="img"></p>
<ul>
<li>通过rpcKind获取对应的RpcInvoker实现；主看ProtoBufRpcInvoker.call</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-07fc870601bd5199e9c298828106c598_b.jpg" alt="img"></p>
<ul>
<li>通过反射获取server端对应的接口实现，阻塞调用，在调用前后记录一些metrics信息；最后将结果包装成RpcResponseWrapper</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-2c1300aac072c27f7a7f6d02326643d5_b.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/v2-10f7ea1450e7fcba8eeba0b28cfade16_b.jpg" alt="img"></p>
<ul>
<li>当结果处理完成之后，通过setupResponse将结果序列化成byte buffer根据不同engine实现的wrapper 序列化方式有所不同</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-ced2fa047079e775740313b85008ea2b_b.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/v2-0ec60ac2232816c3d38b72ce5ac1c02e_b.jpg" alt="img"></p>
<ul>
<li>调用Responder.doRespond将请求结果返回客户端</li>
<li><strong>请求返回处理过程:</strong>  通过Responder线程+ writeSelector</li>
<li>Responder.doRespond</li>
<li>在handler中尽可能的将response一次性写入channel buffer，如果没有剩余则不用注册Responder的Responder.doRespond</li>
<li>如果一次性写不完且是在handler线程中，则唤醒writeSelector，将当前channel 注册 SelectionKey.OP_WRITE 异步去处理</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-3b339c9e8e15060518996edccee9aebf_b.jpg" alt="img"></p>
<ul>
<li>Responder 线程自身的doRunLoop里面也是通过writeSelector监听OP_WRITE事件处理</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-7c4c403ee9bff19653e58088d81d7428_b.jpg" alt="img"></p>
<ul>
<li><strong>CallQueueManager</strong> 相关</li>
<li>默认实现是LinkedBlockingQueue</li>
<li>大小通过queueSizePerHandler或ipc.server.handler.queue.size * handler_count 决定</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-56e6f38dd99dc26c8dbe3ccb84a581aa_b.jpg" alt="img"></p>
<ul>
<li><strong>ConnectionManager相关</strong>：用来定时清理idle时间过长的connection</li>
<li>idleScanThreshold: 每次轮询扫描的connections 阈值default 4000</li>
<li>idleScanInterval: 定时检测线程轮询间隔 default 10000</li>
<li>maxIdleTime:  一个connection最长idle时间，default 2* 10000</li>
<li>maxIdleToClose : 一次轮询最多关闭的连接数 default 10</li>
<li>一个connection是不是可以被清理由以下条件决定</li>
<li>connection.isIdle(): rpcCount为0, 也就是Call没有塞入callQueue；在connection.processRpcRequest末尾，如果成功塞入callQueue中的话会incrRpcCount</li>
<li>lastContact &lt; minLastContact: </li>
<li>minLastContact:  Time.now() - maxIdleTime</li>
<li>startIdleScan：开启清理线程，随Listener线程启动</li>
</ul>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://ol7zjjc80.bkt.clouddn.com/271524552778_.pic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2019/11/05/Hadoop-Rpc源码分析/" data-id="ckjz5arnx0009u9yhgpn9cn24" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMElEQVR42u3aS27jMBAFwNz/0sp2gAnt91pKAJPFVeDYlIqLBvvz9RWv65/Vfv//3672aZ9SLwwMjI9lXC/X6gHJw17vM/t8ScXAwDiAsXqJ1XdW273GJ4eSh2YMDAyMdrs8BLcHgYGBgfEsY/ZJewHFwMA4k9EWyKLE8uVv26D8WC6OgYHxgYy86v73f/9KfwMDA+OjGFe5kiJ+25JsmwE/PB0DA2NrxlPNyPza1wbxYvgDAwNjU8b9gJuntbNLYXRYGBgYBzBev8osW4wifbznm7IdBgbGkYzZ8Fb+3/vDFhgYGOcw2hGHHJO3G2dFvWUujoGBsSkjeaGWdGd0rG0tYGBgnMZ4drRr1jzID3QZcDEwMDZlzIr7eSJaBM37gRgDA2M7xp2yfpu+ztqcRfqKgYFxDKNNO9sG5KyFUNxtMTAwNmW0JbMk0W2HLZKWQDQchoGBsR1jNhKRNzVnxzG8qmJgYGzH+I2SWRtS24GPutCGgYHx4YxkiyteeUi9k7JiYGCczLgTRmeDGnlTMzomDAyMgxmz0a42HW0LeXXAxcDA2IKRD0m0LYEE1h7KMuBiYGBsx7jKNUs186ZCTn3TGMDAwNiIka98aGx2+bvfEMXAwNib8ez4aZ7EtsMWb44AAwPjAEYbKHPYU2McbzAYGBgYNwLrLIzWpT0MDAyM0fhpPmrWprXLaVwMDIytGUkS234+a5HmJTwMDIxzGG3q2Iba/CXutA0wMDA2ZXwD3Se8KjawyL8AAAAASUVORK5CYII=" class="article-share-link">分享</a><div class="tags"><a href="/tags/架构/">架构</a><a href="/tags/Hadoop/">Hadoop</a><a href="/tags/Yarn/">Yarn</a></div><div class="post-nav"><a href="/2019/11/05/Yarn-Federation源码串读/" class="pre">Yarn Federation源码串读</a><a href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/" class="next">【Spark源码分析】Job提交执行过程详解</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Yarn/" style="font-size: 15px;">Yarn</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/Hadoop-Yarn/" style="font-size: 15px;">Hadoop - Yarn</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/paper/" style="font-size: 15px;">paper</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/kubernetes-源码/" style="font-size: 15px;">kubernetes - 源码</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/16/Netty源码解析系列：参数篇/">Netty源码解析系列：参数篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/27/kubernetes-shared-Informer-源码解析/">kubernetes shared Informer 源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/20/kubernetes-federation深度解析/">kubernetes federation深度解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/07/MR任务在Hadoop子系统中状态流转/">MR任务在Hadoop子系统中状态流转</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Yarn-Federation源码串读/">Yarn Federation源码串读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/Hadoop-Rpc源码分析/">Hadoop Rpc源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/【Spark源码分析】Job提交执行过程详解/">【Spark源码分析】Job提交执行过程详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/02/【Spark源码分析】Broadcast/">【Spark源码分析】Broadcast</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/26/【Spark源码分析】Dynamic-Resource-Allocation设计的思考/">【Spark源码分析】Dynamic Resource Allocation设计的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/Raft论文学习/">Raft论文学习</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/chao-li-11/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://weibo.com/3101672623/profile?topnav=1&amp;wvr=6" title="微博" target="_blank">微博</a><ul></ul><a href="https://github.com/lichaojacobs" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>