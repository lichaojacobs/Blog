{"pages":[{"title":"archives","text":"","link":"/archives/index.html"},{"title":"关于我","text":"信仰技术，相信技术能改变世界 专注于Java服务端开发，大数据开源解决方案领域 Kylin&amp;&amp;Doris开源贡献者 目前就职于快手科技–大数据架构工程师，内推简历请发送到我邮箱 联系我 email: lichaojacobs@tju.edu.cn 知乎：扎克布 github: lichaojacobs weibo: 扎克布","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"My Works","text":"","link":"/works/index.html"}],"posts":[{"title":"Flink实战总结","text":"前言Flink 近几年来一直备受业界瞩目，相对于同时期一夜成名的Spark来说，有种厚积薄发的味道。 当然，从根本上来看，也是因为这几年对于实时分布式计算引擎的需求日渐强烈，要求也越来越高（数据的latency，一致性）。而这也意味着以微批次来fake实时处理的Spark Streaming不再能满足实时处理系统的硬性要求(忽略spark continuous processing实现)。最近本司也正在考虑将实时处理任务从Spark Streaming迁移到Flink；于是就有了下面这篇实战总结文章。 基础相关概念 flink程序能实现在分布式的结合上进行各种转换操作，集合通常来自订阅的来源（文件，kafka,local,in-memory），结果被返回到sinks里（大多数写入分布式文件系统，或者标准输出） DataSet and DataStream DataSet和DataStream在flink中都代表一种数据结构，是不可变且包含重复记录的集合。区别在于DataSet是有限的集合，而DataStream是无界的 flink 配置interlij ideal 在本地运行调试 只需要将flink依赖的包引入项目中即可启动项目 讲解Flink怎么序列化objects，怎么分配内存Apache Flink: Juggling with Bits and Bytes DataStream Apache Flink 1.7 Documentation: Flink DataStream API Programming Guide datasource（数据源）: File-based: readTextFile, readFile… Socket-based: socketTextStream Collection-based: fromCollection, fromElements custom: addSource, FlinkKafkaConsumer08 or other connectors DataSet Apache Flink 1.7 Documentation: Flink DataSet API Programming Guide savepoint Apache Flink 1.7 Documentation: Savepoints Savepoints are created, owned, and deleted by the user. 目前savepoint和checkpoint实现和format方式都相同（除了checkpoint选择了rocksdb作为state backend，这样format会有些微不同） Operations： Triggering Savepoints： FsStateBackend or RocksDBStateBackend: Trigger a Savepoint Cancel Job with Savepoint bin/flink cancel -s [:targetDirectory] :jobId Resuming from Savepoints $ bin/flink run -s :savepointPath [:runArgs] Disposing Savepoints $ bin/flink savepoint -d :savepointPath checkpoint Apache Flink 1.7 Documentation: Checkpoints 生命周期是由Flink管理，checkpoint的管理，创建以及释放统一通过Flink，而不需要用户干预 Checkpoints are usually dropped（随应用退出被清除） after the job was terminated by the user (except if explicitly configured as retained Checkpoints) checkpoint 优化 Apache Flink 1.7 Documentation: Tuning Checkpoints and Large State state 双写：一份在distributed storage(HDFS)；一份在local task-local recovery：默认是关闭的状态,可以通过state.backend.local-recovery 打开 Barriers Apache Flink 1.8-SNAPSHOT Documentation: Data Streaming Fault Tolerance Window，waterMark，Trigger Window，waterMark，Trigger介绍- 简书 window 滚动窗口：分配器将每个元素分配到一个指定窗口大小的窗口中，并且不会重叠；TumblingEventTimeWindows.of(Time.seconds(5)) 滑动窗口：滑动窗口分配器将元素分配到固定长度的窗口中，与滚动窗口类似，窗口的大小由窗口大小参数来配置，另一个窗口滑动参数控制滑动窗口开始的频率；因此可能出现窗口重叠，如果滑动参数小于滚动参数的话；SlidingEventTimeWindows.of(Time.seconds(10), Time.seconds(5)) 会话窗口：通过session活动来对元素进行分组，跟滚动窗口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况。当他在一个固定的时间周期内不再收到元素，即非活动间隔产生，那么窗口就会关闭； 一个session窗口通过一个session间隔来配置，这个session间隔定义了非活跃周期的长度。当这个非活跃周期产生，那么当前的session将关闭并且后续的元素将被分配到新的session窗口中去。如：EventTimeSessionWindows.withGap(Time.minutes(10) 触发器(Triggers) 触发器定义了一个窗口何时被窗口函数处理 EventTimeTrigger ProcessingTimeTrigger CountTrigger PurgingTrigger 驱逐器(Evictors) 任务提交与停止姿势 任务提交 启动命令详解 :Apache Flink 1.7 Documentation: YARN Setup 参数 12345678910111213Usage: Required -n,--container &lt;arg&gt; Number of YARN container to allocate (=Number of Task Managers) Optional -D &lt;arg&gt; Dynamic properties -d,--detached Start detached -jm,--jobManagerMemory &lt;arg&gt; Memory for JobManager Container with optional unit (default: MB) -nm,--name Set a custom name for the application on YARN -q,--query Display available YARN resources (memory, cores) -qu,--queue &lt;arg&gt; Specify YARN queue. -s,--slots &lt;arg&gt; Number of slots per TaskManager -tm,--taskManagerMemory &lt;arg&gt; Memory per TaskManager Container with optional unit (default: MB) -z,--zookeeperNamespace &lt;arg&gt; Namespace to create the Zookeeper sub-paths for HA mode 提交到yarn-cluster上需要以 ::y:: 或者::yarn::作为前缀；如: ynm=nm 123flink run -c com.jacobs.jobs.realtime.wordcount.WindowWordCount target/real-time-jobs-1.0.0-SNAPSHOT.jarflink run -m yarn-cluster -ynm TestSinkUserLogStream -yn 4 -yjm 1024m -ytm 4096m -ys 4 -yqu feed.prod -c com.weibo.api.feed.dm.stream.TestFlinkStream /data1/dm-flink/feed-dm-flink-1.0.4-SNAPSHOT.jar 停止任务 关闭或重启flink程序不能直接kill掉，这样会导致flink来不及制作checkpoint，而应该调用flink提供的cancel语意 1234567//重启正确姿势, with savepoint1. 调用cancel，cancel之前先触发savepointbin/flink cancel -s [:targetDirectory] :jobId -yid: yarnAppId例子: flink cancel -s hdfs://vcp-yz-nameservice1/user/hcp/hcpsys/feed/flink-checkpoints/test-user-logs 97b4e67859af4bfb1b597355f1c846f3 -yid application_1542801635735_21212. 从savepoint中恢复flink程序bin/flink run -s :savepointPath [:runArgs]例子: flink run -s hdfs://vcp-yz-nameservice1/user/hcp/hcpsys/feed/flink-checkpoints/test-user-logs/savepoint-97b4e6-22dd5890dd0c -m yarn-cluster -ynm TestSinkUserLogStream -yn 4 -yjm 1024m -ytm 4096m -ys 4 -yqu feed.prod -c com.weibo.api.feed.dm.stream.TestFlinkStream /data1/dm-flink/feed-dm-flink-1.0.4-SNAPSHOT.jar 运行模式Standalone standalone 启动cluster1/usr/local/flink-1.6.0/bin;./start-cluster.sh On Yarn Cluster Apache Flink 1.7 Documentation: YARN 参考文章Flink1.6 - flink on yarn分布式部署架构 - 深山含笑 架构图 JobManager 和 ApplicationMaster 运行在同一个JVM里 on yarn 两种模式 session模式：允许运行多个作业在同一个Flink集群中，代价是作业之间没有资源隔离（同一个TM中可能跑多个不同作业的task） per-job模式（生产环境）：per-job模式是指在yarn上为每一个Flink作业都分配一个单独的Flink集群，这样就解决了不同作业之间的资源隔离问题 摘录参考文章相比旧的Flink-on-YARN架构（Flink 1.5之前），新的yarn架构带来了以下的优势： client可以直接在yarn上面启动一个作业，不在像以前需要先启动一个固定大小的Flink集群然后把作业提交到这个Flink集群上 按需申请容器（指被同一个作业的不同算子所使用的容器可以有不同的CPU/Memory配置），没有被使用的容器将会被释放 slot资源申请/分配流程分析 请求新TaskExecutor的slot分配 ResourceManager挂掉 ：不会挂掉task,不断尝试重新注册ResourceManager详细见参考文章 TaskExecutor挂掉 JobMaster挂掉 资源分配相关？ 在operator中对并行度的设置将决定任务分配到几个task slot里面去 Flink程序运行流程分解基本步骤 Obtain an execution environment 123getExecutionEnvironment()createLocalEnvironment()createRemoteEnvironment(host: String, port: Int, jarFiles: String*) Load/create the initial data 1val text: DataStream[String] = env.readTextFile(&quot;file:///path/to/file&quot;) Specify transformations on this data 12//create a new DataStream by converting every String in the original collection to an integerval mapped = input.map { x =&gt; x.toInt } Specify where to put the results of your computations 12writeAsText(path: String)print() Trigger the program execution Flink watermark机制 【重要】详细讲解watermark: Flink流计算编程—watermark（水位线） window 触发的两个条件 121、watermark时间 &gt;= window_end_time2、在[window_start_time,window_end_time)中有数据存在 摘录：深入理解Flink核心技术 纵坐标为event_time，横坐标为processingTime，理想情况自然是两者一致，但实际情况肯定不可能 摘录：使用EventTime与WaterMark进行流数据处理 123456789 // 这块结合上图理解watermark的值@Override public final Watermark getCurrentWatermark() { long potentialWM = currentMaxTimestamp - maxOutOfOrderness; // 当前最大事件时间戳，减去允许最大延迟到达时间 if (potentialWM &gt;= lastEmittedWatermark) { // 检查上一次emit的WaterMark时间戳，如果比lastEmittedWatermark大则更新其值 lastEmittedWatermark = potentialWM; } return new Watermark(lastEmittedWatermark); } Windowing, WaterMark,Trigger 三者依赖关系 Windowing：就是负责该如何生成Window，比如Fixed Window、Slide Window，当你配置好生成Window的策略时，Window就会根据时间动态生成，最终得到一个一个的Window，包含一个时间范围：[起始时间, 结束时间)，它们是一个一个受限于该时间范围的事件记录的容器，每个Window会收集一堆记录，满足指定条件会触发Window内事件记录集合的计算处理 WaterMark：它其实不太好理解，可以将它定义为一个函数E=f(P)，当前处理系统的处理时间P，根据一定的策略f会映射到一个事件时间E，可见E在坐标系中的表现形式是一条曲线，根据f的不同曲线形状也不同。假设，处理时间12:00:00，我希望映射到事件时间11:59:30，这时对于延迟30秒以内（事件时范围11:59:30~12:00:00）的事件记录到达处理系统，都指派到时间范围包含处理时间12:00:00这个Window中。事件时间超过12:00:00的就会由Trigger去做补偿了。 Trigger：为了满足实际不同的业务需求，对上述事件记录指派给Window未能达到实际效果，而做出的一种补偿，比如事件记录在WaterMark时间戳之后到达事件处理系统，因为已经在对应的Window时间范围之后，我有很多选择：选择丢弃，选择是满足延迟3秒后还是指派给该Window，选择只接受对应的Window时间范围之后的5个事件记录，等等，这都是满足业务需要而制定的触发Window重新计算的策略，所以非常灵活。 Sink Connectors Kafka Elasticsearch RabbitMQ Rolling File Sink (HDFS) Apache Flink 1.7 Documentation: HDFS Connector Streaming File Sink partfile 有三种状态：in-progress, pending,finished；part file先被写成in-progress，一旦被关闭写入，会变成pending，当检查点成功之后，pending状态的文件将变成finished; Apache Flink 1.7 Documentation: Streaming File Sink Using Row-encoded Output Formats 可以指定RollingPolicy 来滚动生成分区中的文件 Using Bulk-encoded Output Formats 支持parquet，orc等文件格式，批量编码文件 通过BulkWriter.Factory定义不同的文件格式 ParquetAvroWriters (flink 1.7-SNAPSHOT API)/Users/lichao15/Documents/github/awesome-big-data/README.md - 源码： flink/StreamingFileSink.java at master · apache/flink · GitHub 使用这种方式只能配合 OnCheckpointRollingPolicy 使用来滚动生成分区文件，通过设置 env.enableCheckpointing(interval)来设置文件滚动间隔 Streaming to parquet in hdfs 出现问题，内存溢出导致job无限崩溃重启，大量part file 如果失败，将从上一个检查点开始重新store，期间回滚in-progress中的文件，以确保不会重复保存上一个检查点之后的数据 part文件过多问题 Streaming to parquet files not happy with flink 1.6.1 - Stack Overflow rolling parquet file 重点邮件 Apache Flink User Mailing List archive. - Streaming to Parquet Files in HDFS 注意压缩的时候内存溢出的情况，flink陷入无限的重启循环中 StreamingFileSink与Kafka 结合如何做到exactly once？ An Overview of End-to-End Exactly-Once Processing in Apache Flink (with Apache Kafka, too!) 二阶段提交 partfile 有三种状态：in-progress, pending,finished；part file先被写成in-progress，一旦被关闭写入，会变成pending，当检查点成功之后，pending状态的文件将变成finished; 如果失败，将从上一个检查点开始重新store，期间回滚in-progress中的文件，以确保不会重复保存上一个检查点之后的数据flink如何控制kafka offset提交与checkpoint&amp;&amp;savepoint相结合 FlinkKafkaConsumer使用详解 关闭checkpoint(Checkpointingdisabled): 此时， Flink Kafka Consumer依赖于它使用的具体的Kafka client的自动定期提交offset的行为，相应的设置是 Kafka properties中的 enable.auto.commit (或者 auto.commit.enable 对于Kafka 0.8) 以及 auto.commit.interval.ms 开启checkpoint(Checkpointingenabled): 在这种情况下，Flink Kafka Consumer会将offset存到checkpoint中 制作完checkpoint 一并提交offsets 当checkpoint 处于completed的状态时（整个job的所有的operator都收到了这个checkpoint的barrier）。将offset记录起来并提交，从而保证exactly-once ::exactly once的两个风险点：可结合savepoint来做:: 异常退出的情况，没法来得及做checkpoint，而checkpoint间隔太长会导致丢失大量数据；可以通过airflow周期性手动触发savepoint恢复；封装hflink脚本 解决思路是结合savepoint来做，通过airflow定时的触发savepoint操作，防止因checkpoint未及时做数据丢失 规定一分钟savepoint一次，这样即使分钟级别的数据丢失也是可以容忍 第一点利用savepoint来做也有风险：在做savepoint的时候，如果异常退出，parfile未及时关闭导致数据丢失 暂时可以认为问题较小？ 如何控制背压 如何做到挂很久之后重新启动时限制拉取的消息量？（类似spark.streaming.kafka.maxRatePerPartition） 背压通过task slot 的stackTrace判断 可以在kafka source那层控制一次性消费量，类似于spark Flink 高性能部署 Apache Flink 1.8-SNAPSHOT Documentation: JobManager High Availability (HA) metric监控rest api Apache Flink 1.8-SNAPSHOT Documentation: Monitoring REST API Restart Strategies doc Apache Flink 1.7 Documentation: Restart Strategies Fixed Delay Restart Strategy Failure Rate Restart Strategy No Restart Strategy Fallback Restart Strategy","link":"/2018/12/20/Flink实战总结/"},{"title":"HBase学习与经验总结","text":"前言因为业务的关系，也零零碎碎的接触到了HBase，并对其产生了兴趣。这段时间又抽空看了一下《HBase权威指南》，于是，秉承着学习记录的习惯，把一些知识和经验写成了博客。 一些基础知识 表：HBase将数据组织到自己的HTable表中，这个表是根据列族(colomn family)在物理上保存数据的，每个列族都有自己的文件夹和storefiles，不像关系型数据库那样将一个表保存成一个文件，表明也是文件系统路径的一部分。 行键：每行都有唯一的行键，行键没有数据类型，它内部被认为是一个字节数组。 列族：HBase表中的行是按一个叫colomn family的列族分组的，也是在磁盘上也是按列族存储数据的，由于这个原因，故当定义一个hbase表时，除了定义表名外，还必须定义列族。传统数据库没有列族的概念。 列修饰符：列簇定义真实的列，被称之为列修饰符，你可以认为列修饰符就是列本身。 存储机制 数据结构：LSM树。使用日志文件和内存存储来将随机写转换成顺序写，因此也能保证稳定的数据插入速率。由于读和写独立，因此在这俩种操作之间没有冲突。由于存储数据的布局较优，查询一个键需要的磁盘寻到次数在一个可预测的范围内。并且读取与该键连续的任意数量的记录都不会引发任何额外的磁盘寻道。 启动HBase时。HMaster负责将所有的region分配到HRegion Server 上，其中也包括特别的-Root-和.META.表。HRegion Server负责打开region,并创建对应的HRegion实例。这些列族是用户之前创建表时定义的。每个store实例包含一个或多个storefile实例，它们实际数据存储文件HFile的轻量级封装。每个Store还有其对应的一个MemStore, 一个HregionServer分享了一个HLog实例。 基本的请求流程: 客户端先联系ZK子集群查找行键。此过程是通过ZK获取含有-ROOT-的region服务器名来完成的。通过含有-Root-的region服务器可以查询到含有.META表中对应的region服务器名，其中包括请求的行键信息。这俩处主要内容都被缓存起来了。并且都只查询一次。最终通过查询.META.服务器来获取客户端的行键数据所在的region的服务器名。 写数据的过程。第一步决定数据是否需要写到由HLog类实现的预写日志中。WAL是标准的Hadoop SequenceFile 并且存储了HlogKey实例。这些键包括序列号和实际数据。所以在服务器崩溃时可以回滚还没有持久化的数据。一旦数据被写入WAL中，数据就会被放到MemStore中，同时还会检查memstore是否已经骂了，如果满了，就会被请求刷写到磁盘中去。刷写请求由另外一个HRegionServer的线程处理，它会把数据写成一个新的HFile。同时也会保存最后写入的序号。系统就知道哪些数据现在被持久化了。 region拆分与合并拆分 当一个region里的存储文件增长到大于配置的hbase.hregion.max.filesize大小或者在列族层面配置的大小时，region会被一分为二。这个过程通常非常迅速，因为系统只是为新region创建了俩个对应的文件，每个region是原始region的一半。 region服务器在父region中创建splits目录来完成这个过程。接下来关闭该region。此后这个region不再接受任何请求。然后region服务器通过在splits目录中设立必须的文件结构来准备新的子region，包括新region目录和参考文件。如果这个过程成功完成，它将把两个新region目录移到表目录中。.META.表中父region的状态会被更新，以表示其现在拆分的节点和子节点是什么。可以避免父region被意外重新打开。 合并rowKey的设计关于rowKey的一些认识 HBase表里只有键(KeyValue对象的Key部分，包括行键、列限定符和时间戳)可以建立索引。访问一个特定行的唯一办法是通过行键。 设计HBase表时，行键是唯一重要的事情，因此应该按照预期的访问方式来建立行键。此结论基于俩个事实依据： region基于行键为一个区间的行提供服务，并且负责区间内每一行 HFile在硬盘上存储有序的行。当region刷写留在内存里的行时生成了HFile。这些行已经排过序，也会有序地刷写到硬盘上。 设计规范 先定好查询方案，可以使用包含部分键的扫描机制设计出非常有效的左对齐索引（字典序从左到右排序）当一个字段被加到键中时就多了一个可以检索的维度。 用户需要保证行键中每个字段的值都被补齐到这个字段所设的长度，这样字典序才会按照预期排列，（按照二进制内容比较，并升序排列），用户需要为每个字段设定一个固定的长度来保证每个字段比较时只会与同字段内容从左到右比较，否则可能出现溢出的情况。 可能的起始键的含义： 扫描一个给定用户ID下的所有消息 - 扫描一个给定用户ID下特定日期的消息 -- 扫描一个用户ID和日期下的一个消息。 防止系统产生热读写的设计： salting方式：使用salting前缀来保证数据分散到所有的region服务器。缺点就是当用户要扫描一个连续的范围时，可能需要跨region请求，这样的话可以通过多线程读取。 1byte prefix=(byte)(Long.hashCode(time)%&lt;number of region servers&gt;); 随机化： 1byte rowkey=MD5(timestamp); 利用散列函数能将行键分散到所有的region服务器上，对于时间连续的数据，这样做不好，因为散列之后无法通过时间范围扫描数据。由于用户可以用散列的方式重新生成行键，随机化的方式很适合每次读取一行数据的应用，如果用户的数据不需要连续扫描而只需要随机读取，用户可以使用这种策略。","link":"/2017/03/15/HBase学习与经验总结/"},{"title":"HBase架构脑图","text":"前言最近，由于我司数据基础新架构正在陆续往以Kylin为中心的方向上走，而Kylin的底层存储又是重度依赖HBase，为了保证数据服务的稳定性，无奈最近开始研究HBase的源码以及工作原理。翻阅各种书籍博客之余，大致总结了一张初期的HBase架构脑图，之后会随着认知的深入去不断更新。结合源码方面的分析也会陆续进行…比较蛋疼的是，HBase的源码太过庞大，不如Kylin的结构清晰，慢慢看吧… 脑图","link":"/2017/06/25/HBase架构脑图/"},{"title":"Hadoop Rpc源码分析","text":"Hadoop生态系统中Rpc底层基本都是走的一套实现，所以有必要对Rpc底层实现做一次系统性的梳理总结。知乎链接 Client&amp;Server实现入口 RpcEngine作为Rpc实现的接口，用来获取client端proxy和server端的server 主要的实现是WritableRpcEngine，ProtobufRpcEngine（现默认），两者的区别主要是序列化与反序列化的协议不同；内部都有继承Server构成完整Rpc Server的实现类 IPC.Server是两种序列化协议的基类，org.apache.hadoop.ipc.Server 主要实现了Reactor的请求处理模式 Client &amp; Server 构造方式 按照序列化协议区分两种实现：ProtobufRpcEngine, WriteableRpcEngine 通过接口getProxy 构造RpcClient getServer构造RpcServer RPC Client剖析总体来说Client端实现比较简单，用hashTable的结构来维护connectionId -&gt; connections以及callId -&gt; calls 对应关系，使得请求响应不需要有严格的顺序性 Ipc.Client构成 callIdCounter：callId 发号器 rpc_client.png: HashTable结构，用来维护Id → Connection的映射 sendParamsExecutor：请求发送线程池 Connection：自身是一个线程 calls: HashTable结构，请求结束将从call从HashTable中移除 sendRpcRequest：用户线程中通过call入口调用，用户线程阻塞 receiveRpcResponse: run中不断轮询server看结果是否就绪 client 处理过程 通过反射获取到方法描述，走client Invoker调用远程实现 getConnection中与远程server 建立socket 连接，并将连接加入connections集合中 在用户线程中调用connection.sendRpcRequest，阻塞的获取结果 Connection自身run方法中不停的轮询Server接收返回结果 waitForWork用来判断当前connection是否应该继续存在，返回true则继续轮询server，如果是false则关闭当前connection receiveRpcResponse接收服务端返回结果，将calls移除table，可以乱序，通过ConnectionId索引，不需要同步代码块，因为只有一个receiver RPC Server剖析 Server端采用经典的Reactor模式，利用IO多路复用实现事件驱动 痛点在于多路复用之前的处理模式，socket read/write是阻塞的，一个线程只能处理一个socket；使用selector之后一个进程可以监视多个进程文件描述符 参考阅读：Reactor模式、Java NIO 底层原理 、select、poll、epoll 图片摘自《Hadoop技术内幕：深入解析MapReduce架构设计与实现原理 》 Reactor 工作图 Reactor：负责响应IO事件，将事件派发到工作线程 Acceptor：用来接收Client端的请求，建立Client与handler的联系；向Reactor注册handler Reader/Sender：为了加快速度，同时做到请求和处理过程的隔离，reader和sender 分别是两个线程池，用来存放该过程处理完后的连接，处理完之后塞入中间队列，等待下一个过程的线程拿去处理就行 Handler：connection对应的工作线程，会做一些decode, compute, encode工作 Hadoop RpcServer组成结构 序列化层：RpcRequestWrapper, RpcResponseWrapper 接口调用层：RpcInvoker，通过反射方式阻塞调用Server端具体的Service方法；调用前后记录一些metrics信息 在handler线程处理逻辑中，通过注册的rpcKind获取对应的RpcInvoker实现，通过反射来调用工作层的Service 请求接收/返回层Ipc.Server：基于Java NIO实现的Reactor 事件驱动模式 Listener selector：监听请求 → 建立连接 → 派发到Reader线程 Readers readSelector：解析&amp;封装Call → 塞入CallQueue Handlers：工作线程 并行pull CallQueue，调用RpcInvoker处理 Responder：read request和write response采用不同的selector实现读写分离 writeSelector connectionManager: 定时清理idle时间过长的Connection CallQueue：reader handler之间的缓冲队列，生产消费者模型 RPC Server 处理流程 Listener → Reader 请求建立过程：ListenerReaderConnection Listener线程只有一个，通过Selector方式监听客户端的Rpc请求(OP_ACCEPT事件)，调用doAccept方法建立连接；此时connectionManager线程开始工作 建立连接后，roundbin方式获取一个reader线程，将连接塞入reader线程的pending队列和connectionManager中 Reader线程doRunLoop中，将pending的connections注册到readSelector中，用来监听一个connection读就绪事件 数据读入 → 工作线程 : ReaderConnectionCallQueue 而后Reader通过selector方式，只要监听的channel有读事件，则调用doRead方法；其中通过selectionKey获取关联的connection对象，调用connection的readAndProcess方法 connection.readAndProcess: 主要是将channel里面的数据读入data byteBuffer中，数据读完之后调用processOneRpc 进一步处理 connection. processOneRpc 对buffer decode构造成DataInputStream以及RpcHeader（请求元信息，协议类型等）通过processRpcRequest将请求塞入CallQueue中，等待handlers处理 connection.processRpcRequest：通过header中指定的rpc engine将dataInputStream根据不同engine反序列化协议反序列化成rpcRequestWrapper；构造Call对象塞入CallQueue, 并incrRpcCount Handler → RpcInvoker → Responder Handler线程在Server start的时候就已经构建启动了 并行pull callQueue获取队列中未处理的call，调用call方法 通过rpcKind获取对应的RpcInvoker实现；主看ProtoBufRpcInvoker.call 通过反射获取server端对应的接口实现，阻塞调用，在调用前后记录一些metrics信息；最后将结果包装成RpcResponseWrapper 当结果处理完成之后，通过setupResponse将结果序列化成byte buffer根据不同engine实现的wrapper 序列化方式有所不同 调用Responder.doRespond将请求结果返回客户端 请求返回处理过程: 通过Responder线程+ writeSelector Responder.doRespond 在handler中尽可能的将response一次性写入channel buffer，如果没有剩余则不用注册Responder的Responder.doRespond 如果一次性写不完且是在handler线程中，则唤醒writeSelector，将当前channel 注册 SelectionKey.OP_WRITE 异步去处理 Responder 线程自身的doRunLoop里面也是通过writeSelector监听OP_WRITE事件处理 CallQueueManager 相关 默认实现是LinkedBlockingQueue 大小通过queueSizePerHandler或ipc.server.handler.queue.size * handler_count 决定 ConnectionManager相关：用来定时清理idle时间过长的connection idleScanThreshold: 每次轮询扫描的connections 阈值default 4000 idleScanInterval: 定时检测线程轮询间隔 default 10000 maxIdleTime: 一个connection最长idle时间，default 2* 10000 maxIdleToClose : 一次轮询最多关闭的连接数 default 10 一个connection是不是可以被清理由以下条件决定 connection.isIdle(): rpcCount为0, 也就是Call没有塞入callQueue；在connection.processRpcRequest末尾，如果成功塞入callQueue中的话会incrRpcCount lastContact &lt; minLastContact: minLastContact: Time.now() - maxIdleTime startIdleScan：开启清理线程，随Listener线程启动","link":"/2019/11/05/Hadoop-Rpc源码分析/"},{"title":"InnoDB读书笔记","text":"基础知识 数据库的四种隔离级别 Read Uncommitted(读未提交): 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。于是事务B可能读取到了事务A未提交的数据。 Read -Committed(读提交): 读取数据的事务允许其他事务继续访问该行事务，但是未提交的写事务存在时禁止一切其他事务，该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。 Repeated read （可重复读） 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。mysql的InnoDB的Repeated read 级别就可以解决幻读的问题(源自Next-Key Locking算法)，而oracle只能将隔离级别设置在Serializable才能解决幻读的问题。 Serializable（串行化）： 序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。 InnoDB关键特性 插入缓冲（Insert Buffer） 不可能每张表上只有一个聚集索引，在进行插入操作时候，数据页存放还是按照主键a进行顺序存放的，但是对于非聚集索引叶子节点的插入不再是顺序的了，这时会需要离散地访问非聚集索引页，需要注意，辅助索引的插入顺序依然是顺序的，或者说比较顺序的，比如用户购买表中的时间字段，通常情况下，用户购买时间是一个辅助索引，用来根据时间条件进行查询，但是在插入时却是根据时间递增而插入的，因此插入较为顺序。Insert Buffer 对于非聚集索引的插入和更新操作，不是每一次直接插入到索引页面，而是判断插入的是否在非索引页是否在缓冲池，若在，则直接插入。若不在先放入一个Insert Buffer中，好似欺骗。 因此 Insert Buffer需要满足的俩个条件： 索引是辅助索引，并且索引不是唯一的。 俩次写（Double Write） 自适应哈希索引（Adaptive Hash Index） 异步IO 刷新邻接页 索引与算法 InnoDB存储引擎支持的几种常见索引 B+ 树索引：其下索引又分为：聚集索引，辅助索引（内部均为B+树） 全文索引 哈希索引 （哈希索引是自适应的，根据表的使用情况自动生成） 注意：B+ 树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存，再在内训中进行查找，最后得到想要查找的数据。 B+树索引 定义和性质 由二叉树和平衡二叉树演化而来。是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录的节点都是按照键值的大小顺序存放在同一层的叶子节点上。由各叶子节点指针进行连接。 B+树的插入必须保证插入之后叶子节点的记录依然排序。 B+树在数据库中的有一个特点就是高扇出性，因此在数据库中B+树的高度一般都在2～4层，也就是说查找一个键值记录最多只需要2到4次IO。 B+树定义 分为聚集索引和辅助索引。俩者的不同之处在于叶子节点存放的是否是一整行的信息。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址，而InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而聚集索引能够在叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地针对范围值查询，查询优化器能够快速发现某一段范围的数据页需要扫描。 聚集索引。由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于使用聚集索引。因为:1）聚集索引能够直接在B+树索引上找到数据。2）定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。能够快速的发现某一段范围的数据页需要扫描误区：很多书和博客都介绍，聚集索引按照顺序物理地存储数据，其实这样会导致维护成本非常高，所以聚集索引的存储并不是物理上连续的。而是逻辑连续。原因：1）页通过双向链表链接，页按照主键的顺序排序；2）页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。 B+树索引的分裂 B+树索引的管理 Cardinality值：1）并不是在所有的查询条件中出现的列都需要添加索引，一般的经验是，在访问表中很少一部分时使用B+树索引才有意义，对于性别、地区、类型字段，它们的可取值范围很小，称为低选择性，于是建索引是完全没有必要的。2）对于高选择性的确定，可以通过show index结果列中的列Cardinality来观察，表示的是索引中不重复记录数量的预估值。注意：仅仅是个预估值，而不是一个准确值。 B+索引树的使用 分析1）用Show index table 查看索引的情况2）用explain+sql语句 来分析这条sql的情况，包括使用的possible_keys（可能选择的索引）与key(实际选择的索引) 联合索引是指对表上的多个列进行索引，创建方法与单个索引的创建方法一样，不同之处在于有多个索引列,如对于联合索引(a,b) ,以下是关于联合索引的一些情况 select * from table where a=x and b=x; 显然是可以用(a,b)索引的，因为索引的顺序就是按照（a,b）来排序的 select * from table where a=xxx; 这个也是可以使用(a,b)索引的，只不过只能使用一部分 select * from table where b=xxx; 这个是不能使用索引的，因为压根就没按照b做排序。 联合索引的好处是，在第一个索引的基础上，已经给第二个键值做了排序的处理，从而可以减少一次排序操作：比如我们要查某个用户购买商品的情况，并且按照时间排序。 覆盖索引 Innodb存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，因此，大小要远小于聚集索引，可以大大减少IO操作。 对于Innodb的辅助索引而言，由于其包含了主键信息，因此其叶子节点存放的数据为(primary key1,primary key2,…)例如，下列语句都可以通过使用一次辅助索引来完成查询 123456select primary key1,key2,… from tablewherekey1=xxx;对于覆盖索引的另一个好处是对某些统计问题而言，不会选择通过聚集索引来进行统计。因为辅助索引的量远小于聚集索引，可以大大减少IO操作。 优化器选择不使用索引的情况123select * from order where orderId&gt;10000 and orderId&lt;102000; （从orderId的基数看来非常大，这是前提） 这句sql按道理来说可以使用辅助索引的，可选的 KEYS有primary orderId, 等索引，然而最后选择了primary聚集索引，也就是全表扫描。 原因在于用户要选取的数据是整行信息，而orderId索引不能覆盖到我们要查询的信息，因此在对orderId索引查询到指定的数据之后，还需要一次书签访问来查询整行信息，虽然orderId索引中的数据是顺序存放的，但是再一次进行书签来查找数据则是无序的，因此变为了磁盘上的离散读操作。 如果要求访问的数据量很小。则优化器还会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分的时候（通常是百分之二十），优化器则会选择通过聚集索引来查找数据，因此之前已经提到过，顺序读要远远快于离散读。 因此，对于不能进行索引覆盖的情况，优化器选择辅助索引的条件是占有的数据量很小。当然这是由当前传统的机械硬盘的特性决定的。 InnoDB存储引擎中的哈希算法自适应哈希索引：数据库自身创建并使用的，经过哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快速。如 select * from table where index_cole=“xxx” 但是对于范围查找久无能为力了。 InnoDB锁机制lock 与 latch区别 latch一般称为轻量级锁，因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以氛围mutex（互斥量）与 rwlock 读写锁。目的是用来保证并发线程的操作临界资源的正确性，并且通常没有死锁检测的机制，仅仅通过应用程序加锁的顺序来保证无死锁的情况发生。 lock的对象是事务，用来锁定的是数据库中的对象。如表，页，行。并且一般lock的对象仅在事务commit或rollback后进行释放。且有死锁机制 latch查看 show engine innodb mutex。lock查看 show engine innodb status InnoDB存储引擎中的锁 InnoDB实现了俩种标准的行级锁： 共享锁：允许事务读一行数据 排他锁：允许事务删除或者更新一行数据 如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行的共享锁，称这种情况为锁兼容。但若有其他事务T3想要获得这一行的排他锁，则必须等待事务T1，2释放行上的共享锁称这种情况为锁不兼容。可以总结出：X锁与任何锁都不兼容。而S锁仅仅和S锁兼容。需注意的是，S和X锁都是行级锁，兼容是指对同一记录锁的兼容性情况。 意向锁的定义：InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上的枷锁操作。InnoDB存储引擎支持一种额外的枷锁方式，称为意向锁。它是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。 如需要在页上的记录r进行行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度的锁完成。举例子说明：在对记录r加X锁之前。已经有事务对表1进行了S表锁，那么表1上一存在S锁，之后事务需要对记录R表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。 InnoDB存储引擎支持意向锁设计比较简练。其意向锁即为表级别的锁，设计的目的主要是为了在事务中揭示下一行将被请求的锁类型。其支持俩种意向锁： 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。 由于InnoDB支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求，故而意向锁与行级别锁的兼容性 意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。 InnoDB行锁实现方式InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：1只有通过索引条件检索数据，InnoDB才使用行级锁，否则，将使用表级锁 一致性非锁定读InnoDB中通过多版本控制的方式来读取当前执行时间数据库中的行的数据。如果读取的行正在执行DELETE或者UPDATE操作，这时读取操作不会因此等待下去，相反，InnoDB存储引擎会去读取行的一个快照数据。是InnoDB默认的读取方式 称之为非锁定读是因为不需要等待访问的行上X锁的释放。快照数据是指该行的之前版本的数据；也称作多版本并发控制（MVCC） 在不同的事务隔离级别Read Committed和Repeatable read下，InnoDB使用非锁定的一致性读。但是对于快照的定义却不相同。在RC下，对于快照数据，总是读取被锁定行最新的一份快照数据，而在RR下，总是读取事务开始时的行数据版本 快照隔离只是适用于只读事务，但是对于读-写事务，由于默认是一致性非锁定读它却无法解决棘手的写倾斜问题（具体定义看《数据密集型应用系统设计》），要想解决写倾斜问题（幻读的一种），还得在读取的时候显式加锁，即一致性锁定读方式 一致性锁定读在默认的配置下，即事务的隔离级别为Repeatable Read模式下，InnoDB存储引擎的select操作使用一致性非锁定读，锁实现采用next-key-lock算法解决幻读但是在某些情况下，用户需要显式地加锁来保证数据的一致性。InnoDB存储引擎对于SELECT语句支持俩种一致性的锁定读操作：12select....FOR UPDATE //对行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。select....LOCK IN SHARE MODE//对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加上X锁则会被阻塞。 必须在一个事务中，如果事务提交，锁也就释放了。 自增长与锁外键和锁 外键 对于外键列，如果没有显示地给这个列加索引，则InnoDB存储引擎自动对其加一个索引，因为这样可以避免默认使用表级锁的情况（在博文InnoDB行锁实现方式一小节提到） 对于外键的插入或更新，首先需要查询父表中的记录，对于父表的SELECT操作，不是采用一致性非锁定读的方式，因为这样会发生数据不一致问题。使用的是Select … lock in share mode方式，即主动对父表加一个S锁。 锁的算法 InnoDB 3种行锁的算法 RecordLock: 单个行记录上的锁。总会去锁住索引记录，如果InnoDB在建立的时候没有设置任何一个索引，那么这时，InnoDB存储引擎会使用隐士的主键来锁定 Gap Lock: 间隙锁，锁定一个范围，但不包含记录本身。目的是为了解决Phantom Problem，即阻止多个事务将记录插入到同一范围内。 Next-Key Lock: Gap Lock+ record Lock,锁定一个范围，并且锁定记录本身。结合了GapLock和RecordLock。在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。例如一个索引有10，11，13，20这四个值，那么该索引可能被Next-Key Locking的区间为： (-8,10)、[10,11)…。 Next-Key Lock 采用的锁定技术为Next-Key Locking,锁定的不是单个值，而是一个范围，是谓词索引的一种改进。若事务T1已经通过next-key locking锁定了范围：(10,11]、(11,13] 当插入新的记录12时，则锁定的范围会变成:(10,11]、(11,12],(12,13]。 然而当查询的索引含有唯一属性时，InnoDB会对Next-Key Lock进行优化降级为Record Lock，即仅仅锁住索引本身，而不是范围。 解决Phantom Problem Phantom Problem定义： 是指在同一事务下，连续执行俩次同样的SQL语句可能导致不同的结果，第二次执行的SQL语句可能会返回之前不存在的行。 在默认的事务隔离级别下，即REPEATABLE READ下，InnoDB存储引擎采用Next-Key Locking机制来避免幻象问题。 123举例说明：表t由1，2，5三个值组成，事务T1执行：select * from t where a&gt;2 for update;这时，T1并没有提交操作，此时结果返回5，与此同时，另一个事务T2插入了4这个值，在执行一遍sql会返回4，5，即俩次的结果不一致。InnoDB的next-key locking算法避免Phantom Problem,是对（2，+8）这个范围加了X锁，因此对于任何这个范围插入的操作都是不被允许的。 锁问题 脏读 脏数据和脏页的关系：脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘的页的数据是不一致的。当然在刷新到磁盘之前，日志都已经被写入到了重做日志文件中，而脏数据是指事务对缓冲池中的行记录的修改，并且还没有被提交。 一个事务可以读到另一个事务中为提交的数据，这显然违反了数据库的个隔离性。 不可重复读 重点在于修改。是指在一个事务内多次读取同一数据集合，在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作，因此在第一个事务中的俩次读数据之间，由于第二个事务的修改，导致俩次读取到的结果集合可能出现不一致的情况。 不可重复读和脏读的区别是，脏读是读到未提交的数据，而不可重复读读到的却是已经提及的数据，但是其违反了数据库事务一致性的要求。 一般来说不可重复读还是可以接受的，不少数据库厂商（Oracle、MicroSoft SQL SERVER）将其数据库事务的默认隔离级别设置为Read COMMITTED InnoDB存储引擎中，通过使用Next-Key Lock算法来避免不可重复读的问题。Mysql官方文档中将不可重复读的问题定义为Phantom Problem，即幻象问题 幻读 重点在于新增或删除。当事务不是独立执行时发生的一种现象，第一个事务对一个表中的数据进行了修改，涉及到全部的数据行。同时第二个事务也修改了这个表中的数据，这种修改是向表中插入一行新数据。那么之后第一个事务重新读取数据的时候就会出现幻读的情况 Next-Key Lock算法解决幻读问题 丢失更新 丢失更新是另一个锁导致的问题，简单来说就是一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致。 1）事务T1将行记录r更新为v1,但是事务T1并未提交 2）与此同时事务T2将行记录更新为V2，事务T2未提交 3）事务T1提交 4）事务T2提交 但是在任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题。但是生产应用中还有一种逻辑意义的丢失更新，而导致该问题的并不是因为数据库本身的问题。 实际上，在所有多用户计算机系统环境下都有可能产生这个问题： 1) 事务T1查询一行数据，放入本地内存，并显示给一个终端用户User1 2) 事务T2也查询该行数据，放入本地内存，并显示给一个终端用户User2 3) user1修改该行记录，更新数据库并提交 4) User2也修改该行记录，更新数据库并提交 要避免丢失更新的发生，就需要让事务在这种情况下的操作变成串行化，而不是并行操作。于是在步骤一的过程中，用户读取数据加上一个排他锁，这样用户2读取的时候也必须加上排他锁，否则就等待锁的释放。 阻塞 因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。阻塞不是一件坏事，是为了确保事务可以并发且正常地运行。 在InnoDB中，参数 innodb_lock_wait_timeout用来控制等待的时间（默认是50秒），innodb_rollback_on_timeout用来设定是否在等待超时时对进行中的事务进行回滚操作，默认不回滚。可以通过代码调整： 123set @@innodb_lock_wait_time=60innodb_rollback_on_timeout是静态的，不可在启动时进行修改。默认情况下，innoDB存储引擎不会回滚超时引发的错误异常，其实InnoDB存储引擎在大部分情况下，都不会对异常进行回滚。 死锁 死锁的概念 死锁的概率 死锁的示例 锁升级","link":"/2017/02/15/InnoDB读书笔记/"},{"title":"JVM知识总结","text":"HotSpot JVM Architecture JVM运行时数据区域 程序计数器 (program counter registers) java虚拟机栈：线程私有，生命周期与线程相同。每个方法在运行期间都会创建一个栈帧用于存储局部变量、操作数栈、动态链接、方法出口等信息。 经常有人把java内存区分为堆内存和栈内存，这种分法比较粗糙。其中所指的栈就是虚拟机栈。或者说是虚拟机栈中局部变量表部分。 局部变量表存放了编译期间可知的各种基本数据类型(boolean byte char,…)、对象引用和returnAddress类型 本地方法栈 为虚拟机提供Native方法服务 java堆： 是JVM所管理的内存中最大的一块。是被所有线程共享的一块内存区域。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配（随着JIT编译器的发展与逃逸分析技术的成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，导致在堆上分配对象不是那么绝对）。 方法区： 与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于HotSpot熟悉的人员来说，很多人更愿意把方法区称为“永久代”本质上并不等价，仅仅是因为HotSpot虚拟机设计团队选择把GC分代收集扩展到方法区，或者说使用永久代来实现方法区而已。但是这种实现方式更容易遇到内存溢出的问题，现在HotSpot虚拟机也放弃永久代逐步改为采用Native Memory来实现方法区的规划了（如：把原本放在永久代的字符串常量池移除） JVM规范对方法区限制非常宽松，但也不是永久存在，还是会存在类的卸载，常量池的回收问题 运行时常量池：方法区的一部分，Class文件中出了有类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 运行期间也可以将新的常量放入池中，如String类的intern()方法（目前被废除） 直接内存(Direct Memory)：不是JVM规范定义的内存区域，但是也被频繁使用，而且也可能导致内存溢出异常。在JDK1.4新加入了NIO 类，引入了一种基于通道与缓冲区Buffer的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。显然，这部分内存不会受到Java堆大小的限制，但是还是受到本机总内存的限制 对象创建分配实例内存的时候可能会出现并发问题的解决方案： 对分配内存空间的动作进行同步处理———实际上JVM采用CAS配上失败重试的方式保证更新操作的原子性 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存称为本地线程分配缓冲（TLAB）。哪个线程要分配内存就在哪个TLAB上分配，只有TLAB用完并分配新的的时候才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+／-UseTLAB参数来设定 GC 算法： 可达性分析算法（不算GC算法，仅仅是思想）: GC Roots的对象包括下面几种： 1、虚拟机栈（栈帧中的本地变量表）中引用的对象 2、方法区中类静态属性引用的对象 3、方法区中常量引用的对象 4、本地方法栈中JNI（即一般说的Native方法）引用的对象。 引用计数法： 标记清除（Mark-Sweep)： 复制算法 (Copying) 标记-压缩算法 (Mark-Compact) 增量算法 (Incremental Collecting) JVM 垃圾回收器分类 Young generation: Serial ParNew Parallel Scavenge Tenured generation: CMS Parallel Old Serial Old All G1 新生代串行收集器（GC日志中:Default New Generation）： 第一，它仅仅使用单线程进行垃圾回收；第二，它独占式的垃圾回收。复制算法 老年代串行收集器： 标记-压缩算法。 -XX:+UseParNewGC 参数设置，表示新生代使用并行收集器，老年代使用串行收集器 -XX:+UseParallelGC 参数设置，表示新生代和老年代均使用并行回收收集器 新生代并行回收 (Parallel Scavenge) 收集器，对应的GC日志中新生代的名称为PSYoungGen 老年代并行回收收集器 CMS 收集器: 它使用的是标记-清除算法，同时它又是一个使用多线程并发回收的垃圾收集器。 主要步骤有：初始标记、并发标记、重新标记、并发清除和并发重置。其中初始标记和重新标记是独占系统资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。因此，从整体上来说，CMS 收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。 标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，为了解决这个问题，CMS 收集器还提供了几个用于内存压缩整理的算法。 -XX:+UseCMSCompactAtFullCollection 参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。 -XX:CMSFullGCsBeforeCompaction 参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。使用CMS收集器后，默认新老年代分别使用ParNew和CMS收集器进行垃圾回收 G1 收集器 (Garbage First) : 与 CMS 收集器相比，G1 收集器是基于标记-压缩算法的 G1 收集器还可以进行非常精确的停顿控制。它可以让开发人员指定当停顿时长为 M 时，垃圾回收时间不超过 N。 使用参数-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC 来启用 G1 回收器，设置 G1 回收器的目标停顿时间：-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200。 JVM内存分配情况 参考链接 容器内存 = 文件缓存 + Java 应用内存Java 应用内存 = 堆内存 + MetaSpace + 堆外内存堆外内存 = 线程栈 + 缓冲区（例如 NIO）等等 所以按照目前的经验来看，堆内存至少应该小于 2/3 的容器内存（？） happens-before规则 定义 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序） 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。 对象转入老年代的情况： 1、经过了正常的MinoGC过程数次之后（可以通过-XX:MaxTenuringThreshold配置）晋升到老年代 2、大于一定值的对象直接进入老年代（ 通过-XX:PretenureSizeThreshold配置） 3、空间分配担保：MinorGC之前，jvm会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么MinorGC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则尝试一次MinorGC，尽管会有风险，如果小于。或者HandlePromotionFailure设置不允许冒险，那这时候也需要改为进行一次Full GC. 因为新生代是使用复制收集算法，但是为了内存利用率，只使用其中一个Survivor空间作为轮换备份，因此当出现大量对象在MinorGC后仍然存活。就需要老年代进行分配担保。把Survivor无法容纳的对象直接进入老年代。前提是老年代还有容纳这些对象的剩余空间，一共有多少对象会存活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间比较，决定是否进行FullGc来让老年代腾出空间。如果允许担保失败(HandlePromotionFailure)并且老年代最大可用连续空间大于历次晋升到老年代对象的平均大小，将尝试进行一次MinorGC，如果小于或者不允许担保失败则会进行一次 FullGC，所以一般会将HandlePromotionFailure打开，以防止FullGC频率过高 一些JVM工具 jps : 虚拟机进程状况工具 详细参考文章 -q 只输出LVMID,省略主类名称 -m 输出虚拟机进程启动时传递给主类main()函数的参数 -l 输出主类的全名，如果进程执行的是Jar包，输出jar路径 -v 输出虚拟机进程启动时JVM参数 jstat: 虚拟机统计信息监视工具，可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据 详细参考文章 -class pid 监视类装载、卸载数量、总空间以及类装载所耗费时间 -gc pid 监视Java堆状况，包括Eden区，两个Survivor区、老年代、永久代容量、已用空间、GC时间合计等信息 -gccapacity pid 可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小 -gcnew pid 年轻代对象的信息 -gcold 年老代对象信息 jinfo: java配置信息工具 实时地查看和调整虚拟机各项参数，未被显示指定的参数的系统默认值 jinfo -flag CMSInitiatingOccupancyFraction 14444 jmap java内存映象工具 用于生成堆转储快照（一般称为heapdump或dump文件）如果不使用jmap命令，还可以使用暴力的手段如：-XX:+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在 OOM异常之后自动生成dump文件。通过-XX:+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件。 详细参考文章 jmap 的作用不仅仅是为了获取dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。 -dump 生成java堆转储快照 -dump:[live, ]format=b, file=,其中live子参数说明是否只dump出存活的对象。 1jmap -dump:format=b,file=20190108.dump [pid] -heap 显示java堆详细信息，如使用那种回收器、参数配置、分代状况等／ -histo 显示堆中对象的统计信息，包括类，实例数量，合计容量 -F 当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。 例子：jmap -dump:format=b,file=exlipse.bin 3500 (3500 是通过jps命令查询到的LVMID) jhat: 虚拟机堆转储快照分析工具 sun JDK提供jhat 与jmap 搭配使用，来分析jmap 生成的堆转储快照。jhat内置了一个微型的Http/Html服务器，生成dump文件的分析结果后，可以在浏览器中查看之后可以用visualVM来分析dump文件 jstack: java堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环 详细参考文章 垃圾收集器参数总结： UseSerialGC ：虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old 的收集器组合进行内存回收 UseParNewGC: 打开此开关后使用ParNew+SerialOld的收集器组合进行内存回收 UseConcMarkSweepGC：打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收，Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 UseparallelGC 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old (PS MarkSweep) 的收集器组合进行内存回收UseParallelOldGC: 使用Parallel Scavenge+ Parallel Old的收集器组合进行内存回收 GC 相关参数总结 与串行回收器相关的参数 1234-XX:+UseSerialGC:在新生代和老年代使用串行回收器。-XX:+SurvivorRatio:设置 eden 区大小和 survivor 区大小的比例。-XX:+PretenureSizeThreshold:设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。-XX:MaxTenuringThreshold:设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。 与并行 GC 相关的参数 123456-XX:+UseParNewGC: 在新生代使用并行收集器。-XX:+UseParallelOldGC: 老年代使用并行回收收集器。-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。-XX:+UseAdaptiveSizePolicy:打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 与 CMS 回收器相关的参数 123456789-XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS+串行收集器。-XX:+ParallelCMSThreads: 设定 CMS 的线程数量。-XX:+CMSInitiatingOccupancyFraction:设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。-XX:+UseFullGCsBeforeCompaction:设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收。-XX:+CMSParallelRemarkEndable:启用并行重标记。-XX:CMSInitatingPermOccupancyFraction:当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。-XX:UseCMSInitatingOccupancyOnly:表示只在到达阈值的时候，才进行 CMS 回收。-XX:+CMSIncrementalMode:使用增量模式，比较适合单 CPU。 与 G1 回收器相关的参数 1234-XX:+UseG1GC：使用 G1 回收器。-XX:+UnlockExperimentalVMOptions:允许使用实验性参数。-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间。-XX:+GCPauseIntervalMills:设置停顿间隔时间。 其他参数 1-XX:+DisableExplicitGC: 禁用显示 GC。 JVM调优实战除了Java堆和永久代之外还有以下区域还会占用较多的内存，这些内存总和受到操作系统进程最大内存的限制 DirectMemory：可通过 -XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError 或者 OutOfMemoryError: Direct buffer memory.如果把系统大部分的内存都分配给了java堆，并且很长时间没有发生GC操作。那么DirectMemory可能会溢出。因为DirectMemory只是等待老年代满了之后FullGC，然后顺便帮它清理掉内存的废弃对象。否则就只能一直等到抛出内存溢出异常。 线程堆栈： 可通过-Xss调整大小，内存不足时抛出StackOverflowError Socket 缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连续多的话这块内存也很可观。 JNI 代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。 虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存 解读GC 日志 1234[GC (Allocation Failure) 2017-10-15T16:02:33.567+0800: 790.871: [ParNewDesired survivor size 17432576 bytes, new threshold 6 (max 6)- age 1: 7619992 bytes, 7619992 total- age 2: 1081760 bytes, 8701752 total 可以明显看出上述 GC 日志包含两次 Minor GC。 注意到第二次 Minor GC 的情况， 日志打出 “Desired survivor size 53673984 bytes”， 但是却存活了 “- age 1: 107256200 bytes, 107256200 total” 这么多。 可以看出明显的新生代的 Survivor 空间不足。正因为 Survivor 空间不足， 那么从 Eden 存活下来的和原来在 Survivor 空间中不够老的对象占满 Survivor 后， 就会提升到老年代， 可以看到这一轮 Minor GC 后老年代由原来的 0K 占用变成了 105782K 占用， 这属于一个典型的 JVM 内存问题， 称为 “premature promotion”(过早提升)。”premature promotion” 在短期看来不会有问题， 但是经常性的”premature promotion”， 最总会导致大量短期对象被提升到老年代， 最终导致老年代空间不足， 引发另一个 JVM 内存问题 “promotion failure”（提升失败： 即老年代空间不足以容乃 Minor GC 中提升上来的对象）。 “promotion failure” 发生就会让 JVM 进行一次 CMS 垃圾收集进而腾出空间接受新生代提升上来的对象， CMS 垃圾收集时间比 Minor GC 长， 导致吞吐量下降、 时延上升， 将对用户体验造成影响。 Java什么情况下会报OutOfMemoryError 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StatckOverflowError异常；若果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样，在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法在申请到内存时会抛出OutOfMemoryError异常。 直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常的出现。在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native中来回复制数据。显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或分页文件)的大小及处理器寻址空间的限制。 虚拟机类加载机制 类加载的生命周期：加载—验证—准备—解析—初始化—使用—卸载 类初始化阶段：是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说字节码）在准备阶段，变量已经赋值锅系统要求的初始值，，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，从另一个方面表达：初始化阶段是执行类构造器()方法的过程。方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在原文件中出现的顺序决定的。 静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如： 1234567public class test{static{i=0; //给变量赋值可以正常编译通过System.out.print(i); //这句编译器会提示“非法向前引用”}static int i=1;} () 方法与类的构造函数不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的clinit方法执行之前，父类的cinit方法已经执行完毕。因此在虚拟机中第一个被执行的cinit方法的类肯定是java.lang.object。由于父类的clinit方法先执行，也就意味着父类中定义的静态语句块要优先于子类变量赋值操作。比如如下B的值将会是2而不是1 1234567891011121314static class Parent{public static int A =1; static { A =2 }}static class Sub extends Parent{public static int B=A}public static void main(String[] args){system.out.println(Sub.B);} - 1）clinit 方法不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，也就没有必要为这个类生成clint方法。 - 2）接口中不能使用静态语句块，但仍然有变量初始化赋值操作，因此接口和类一样都会生成clinit方法。但接口与类不同的是，执行接口的clinit方法不需要先执行父接口的clinit方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口实现类在初始化时也一样不会执行接口的clinit方法 - 3）虚拟机保证一个类的clinit方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit方法，其他线程都需要阻塞等待，直到活动线程执行clinit方法完毕。同一个类加载器下，一个类型只会初始化一次 类加载器 1）用于实现类的加载动作.比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类就必定不相等。相等指的是 equals() isAssignableFrom()方法，isInstance()方法返回的结果。也包括使用instanceof关键字做对象所属关系判定等情况。 2）双亲委派模型从Java虚拟机的角度，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器由C++实现，另一种就是所有其他的类加载器，由Java实现并且都继承自抽象类java.lang.ClassLoader 3）从开发人员的角度，类加载器还可以分更细： 启动类加载器(Bootstrap ClassLoader)：负责加载Java_HOME\\lib目录中的，或者被-Xbooclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。无法被java程序直接饮用。 扩展类加载器（Extension ClassLoader） 负责加载JAVA_HOME\\lib\\ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器 应用程序加载器（Application ClassLoader） 这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以也被称为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序没有自定义锅自己的类加载器，一般情况下这个就是程序中默认的类加载器 JVM逃逸分析 逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸 如果能证明一个对象不会逃逸到方法或线程外，则可能为这个变量进行一些高效的优化 优化点 栈上分配 我们都知道Java中的对象都是在堆上分配的，而垃圾回收机制会回收堆中不再使用的对象，但是筛选可回收对象，回收对象还有整理内存都需要消耗时间。如果能够通过逃逸分析确定某些对象不会逃出方法之外，那就可以让这个对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。 在一般应用中，如果不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了。 同步消除：参考高并发Java 九锁的优化和注意事项 标量替换 Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了 JIT 与Java10 Introduction: 对于大部分应用开发者来说，Java编译器指的是JDK自带的javac指令。这一指令可将Java源程序编译成.class文件，其中包含的代码格式我们称之为Java bytecode（Java字节码）。这种代码格式无法直接运行，但可以被不同平台JVM中的interpreter解释执行。由于interpreter效率低下，JVM中的JIT compiler（即时编译器）会在运行时有选择性地将运行次数较多的方法编译成二进制代码，直接运行在底层硬件上。Oracle的HotSpot VM便附带两个用C++实现的JIT compiler：C1及C2。 与interpreter，GC等JVM的其他子系统相比，JIT compiler并不依赖于诸如直接内存访问的底层语言特性。它可以看成一个输入Java bytecode输出二进制码的黑盒，其实现方式取决于开发者对开发效率，可维护性等的要求。Graal是一个以Java为主要编程语言，面向Java bytecode的编译器。与用C++实现的C1及C2相比，它的模块化更加明显，也更加容易维护。Graal既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现AOT编译。在Java 10中，Graal作为试验性JIT compiler一同发布（JEP 317）。这篇文章将介绍Graal在动态编译上的应用。有关静态编译，可查阅JEP 295或Substrate VM。 Tiered Compilation HotSpot中的tiered compilation JIT compiler — C1及C2（或称为Client及Server） 前者没有应用激进的优化技术，因为这些优化往往伴随着耗时较长的代码分析。因此，C1的编译速度较快，而C2所编译的方法运行速度较快。在Java 7前，用户需根据自己的应用场景选择合适的JIT compiler。举例来说，针对偏好高启动性能的GUI用户端程序则使用C1，针对偏好高峰值性能的服务器端程序则使用C2。 Java 7引入了tiered compilation的概念，综合了C1的高启动性能及C2的高峰值性能。这两个JIT compiler以及interpreter将HotSpot的执行方式划分为五个级别： level 0：interpreter解释执行 level 1：C1编译，无profiling level 2：C1编译，仅方法及循环back-edge执行次数的profiling level 3：C1编译，除level 2中的profiling外还包括branch（针对分支跳转字节码）及receiver type（针对成员方法调用或类检测，如checkcast，instnaceof，aastore字节码）的profiling level 4：C2编译。其中，1级和4级为接受状态 — 除非已编译的方法被invalidated（通常在deoptimization中触发），否则HotSpot不会再发出该方法的编译请求。 JVM优秀博客 Java字节码结构剖析一：常量池 Java字节码结构剖析二：字段表 Java字节码结构剖析三：方法表 从字节码和 JVM 的角度解析 Java 核心类 String 的不可变特性 高并发java博客系列","link":"/2018/03/26/JVM知识总结/"},{"title":"Kylin二次开发——测试环境搭建","text":"调研背景虽然公司目前在生产环境上正式用上了kylin，但是由于其本身年龄不长，社区并不完善，难难免会暴露出各种各样的源码级别的问题(包括上一篇介绍的kylin的同步机制的问题)。这时候使用者想等着官方推出新的release未免太过于被动。于是，我们想着对kylin进行二次开发以满足我们对定制化需求。事实上，目前我们使用的所有开源框架在一定程度上都进行了多多少少的二次开发： superset接入kylin，完成了自编译集成进了docker，并修改了 flask-appbuilder的源码逻辑，兼容ldap与原本的账号系统。 airflow 正在考虑从输出信息中判断task是否执行成功，而不是单纯的靠进程是否异常退出判断（主要考虑到支持kylin的任务调度） 其实在kylin的官网对于开发环境搭建大致的步骤都做了介绍下面描述整个过程 搭建过程 想应用经过自己二次开发的kylin当然必须得全覆盖的跑一遍所有的单元测试。这就意味着必须得有Hadoop+hive+hbase等一整套测试环境。这里使用kylin官方推荐的Hortonworks Sandbox。为了方便，直接使用Sandbox on docker。 按照官网的教程（docker占用的内存至少8G以上，否则运行不了） 在执行start_sandbox-hdp.sh的时候需要往映射的端口里面加入hive metastore的thrift端口9083，否则本地跑单元测试的时候连不上metastore ssh上运行的container，修改admin密码: 1234ssh -p 2222 root@localhost或者http://127.0.0.1:4200/ 进入shell浏览器界面//执行 ambari-admin-password-reset 用修改的admin密码登录http://localhost:8080，确保dashboard中hive+mapreduce+hdfs+hbase正常启动 修改kylin.properties的几个值: 12345678//KYLIN_HOME/examples/test_case_data/sandbox/kylin.propertieskylin.job.use-remote-cli=truekylin.job.remote-cli-hostname=sandboxkylin.job.remote-cli-username=rootkylin.job.remote-cli-password=xxxx//这个默认是22端口，由于我本地不生效，就直接设置为2222端口kylin.job.remote-cli-port=2222 如果单个单元进行测试，不想每次从头开始，方便集中debug某个moudle的错误，可以注释掉pom.xml中的check-style插件 12345678910111213141516171819202122232425262728&lt;!-- &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt; &lt;version&gt;2.17&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.puppycrawl.tools&lt;/groupId&gt; &lt;artifactId&gt;checkstyle&lt;/artifactId&gt; &lt;version&gt;6.19&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;check-style&lt;/id&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;configuration&gt; &lt;configLocation&gt;dev-support/checkstyle.xml&lt;/configLocation&gt; &lt;suppressionsLocation&gt;dev-support/checkstyle-suppressions.xml&lt;/suppressionsLocation&gt; &lt;includeTestSourceDirectory&gt;true&lt;/includeTestSourceDirectory&gt; &lt;consoleOutput&gt;true&lt;/consoleOutput&gt; &lt;failsOnError&gt;true&lt;/failsOnError&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;check&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; --&gt; 执行测试命令 1234//basemvn test -fae -Dhdp.version=${HDP_VERSION:-&quot;2.6.1.0-129&quot;} -P sandbox -X//全覆盖mvn verify -Dhdp.version=${HDP_VERSION:-&quot;2.6.1.0-129&quot;} -fae 2&gt;&amp;1 | tee mvnverify.log 踩坑记录 该暴露的端口得暴露出来，否则本地测试的时候对指定的端口无法进行tcp通信 1239083:9083 //hive metastore8050:8050 // kylin 获取job output信息端口50010:50010 // dfs.datanode.address，这里踩坑很久,不配置的话会有：createBlockOutputStream when copying data into HDFS错误 启动start_sandbox-hdp脚本的时候，可能会出现postgresql服务启动不了，这很可能是因为其申请的共享内存超过了系统的，只需要进入到容器里面做相关操作 12345ssh -p root@localhostsudo sysctl -w kernel.shmmax=17179869184 //假设你有16G内存，按实际扩充sudo service postgresql start//postgresql启动之后在容器外重新执行./start_sandbox-hdp.sh 就可以了","link":"/2017/08/07/Kylin二次开发——测试环境搭建/"},{"title":"Kylin学习笔记","text":"基础知识OLAP(on-Line AnalysisProcessing)的实现方式 ROLAP:基于关系数据库的OLAP实现（Relational OLAP）。ROLAP将多维数据库的多维结构划分为两类表:一类是事实表,用来存储数据和维关键字;另一类是维表,即对每个维至少使用一个表来存放维的层次、成员类别等维的描述信息。维表和事实表通过主关键字和外关键字联系在一起,形成了”星型模式”。对于层次复杂的维,为避免冗余数据占用过大的存储空间,可以使用多个表来描述,这种星型模式的扩展称为”雪花模式”。特点是将细节数据保留在关系型数据库的事实表中，聚合后的数据也保存在关系型的数据库中。这种方式查询效率最低，不推荐使用。 MOLAP:多维数据组织的OLAP实现（Multidimensional OLAP。以多维数据组织方式为核心,也就是说,MOLAP使用多维数组存储数据。多维数据在存储中将形成”立方块（Cube）”的结构,在MOLAP中对”立方块”的”旋转”、”切块”、”切片”是产生多维数据报表的主要技术。特点是将细节数据和聚合后的数据均保存在cube中，所以以空间换效率，查询时效率高，但生成cube时需要大量的时间和空间。 HOLAP: 基于混合数据组织的OLAP实现（Hybrid OLAP）。如低层是关系型的，高层是多维矩阵型的。这种方式具有更好的灵活性。特点是将细节数据保留在关系型数据库的事实表中，但是聚合后的数据保存在cube中,聚合时需要比ROLAP更多的时间,查询效率比ROLAP高，但低于MOLAP。 kylin的cube数据是作为key-value结构存储在hbase中的，key是每一个维度成员的组合值，不同的cuboid下面的key的结构是不一样的，例如cuboid={brand，product，year}下面的一个key可能是brand=’Nike’，product=’shoe’，year=2015，那么这个key就可以写成Nike:shoe:2015，但是如果使用这种方式的话会出现很多重复，所以一般情况下我们会把一个维度下的所有成员取出来，然后保存在一个数组里面，使用数组的下标组合成为一个key，这样可以大大节省key的存储空间，kylin也使用了相同的方法，只不过使用了字典树（Trie树），每一个维度的字典树作为cube的元数据以二进制的方式存储在hbase中，内存中也会一直保持一份。 cube 构建 Dimension：Mandatory、hierarchy、derived 增量cube: kylin的核心在于预计算缓存数据，因此无法达到真正的实时查询效果。一个cube中包含了多个segment，每一个segment对应着一个物理cube，在实际存储上对应着一个hbase的一个表。每次查询的时候会查询所有的segment聚合之后的值进行返回，但是当segment数量较多时，查询效率会降低，这时会对segment进行合并。被合并的几个segment所对应的hbase表并没有被删除。 cube词典树：cube数据是作为key-value结构存储在HBase中的。key是每一个维度成员的组合值 Streaming cubing 支持实时数据的cub。与传统的cub一样，共享storage engine(HBase)以及query engine。kylin Streaming cubing相比其他实时分析系统来说，不需要特别大的内存，也不需要实现真正的实时分析。因为在OLAP中，存在几分钟的数据延迟是完全可以接受的。于是实现手法上采用了micro batch approach。 micro batch approach:将监听到的数据按照时间窗口的方式划分，并且为每个窗口封装了一个微量批处理，批处理后的结果直接存到HBase。 Streaming cubing data 最终会慢慢转换成普通的cubes,因为所有的数据是直接保存到HBase中的，并且保存为一个新的segment，当segment数量到达一定程度时，job engine会将segment 合并起来形成一个大的cube。 实战问题总结由于集群环境是CDH集群，所以选择了kylin CDH 1.6的版本，支持从Kafka读取消息建立Streaming cubes直接写入HDFS中 选择一个集群namenode节点，将解压包放入/opt/cloudrea/parcels/目录中。如果是部署单节点，暂时不用更改配置文件。所有的配置加载都在bin/kylin.sh中。 直接kylin.sh start/stop 运行脚本，服务就会在7070端口起一个web界面。这个界面是可以进行可视化操作的。 Hive 数据源 直接测试hive数据源是没有问题的，这一功能比较完善，也是主打功能。 kafka数据源从kylin 1.6 版本开始正式支持Kafka做数据源，将Streaming Cubes实时写入 HBase中。这一块在测试的时候也出现了问题： Kafka版本问题 由于实验环境的CDH集群Kafka版本是0.9的，而kylin 仅支持0.10以上的版本，所以需要对CDH kafka集群进行升级。 mapreduce运行环境无jar包 kylin中提交cube build之后，map reduce任务直接抛错。错误提示是，找不到Kafka的Consumer类。根本原因是kylin默认集群上的map reduce classpath是会加载kafka-clients.jar包的，所以在提交任务的时候没有将kafka-clients.jar包打进去。这时可以有三种做法： 直接修改kylin的源码，将kafka-clients.jar包给包括进去（待尝试）。 可以通过修改集群的HADOOP_ClASSPATH的路径，将jar包给包括进去。 hadoop classpath 查看classpath目录信息 将对应jar包直接拷入map reduce classpath中，这方法简单，但是缺点就是需要逐个得对node进行操作。 Property is not embedded format 现在意识到，使用开源框架不会看其源码是不行的…就在我折腾俩天终于将mapreduce任务跑起来之后，新的错误出现了:”ava.lang.RuntimeException: java.io.IOException: Property ‘xxx’ is not embedded format”。莫名奇妙的错误。迫使我直接去github上看kylin kafka模块的源码。在TimedJsonStreamParser.java中发现代码逻辑中默认json数据中，如果key存在下划线就会将该key按照下划线split… 然后看key对应的value是不是map类型，如果不是直接抛出标题的错误。 明确了问题之后，如何复写默认下划线split的配置成为问题。由于官网的文档十分鸡肋，很多坑都没有涉及到，所以继续看源码。发现StreamingParser.java这个类中会去写一些默认的配置。 123456789101112131415161718public static final String PROPERTY_TS_COLUMN_NAME = &quot;tsColName&quot;;public static final String PROPERTY_TS_PARSER = &quot;tsParser&quot;;public static final String PROPERTY_TS_PATTERN = &quot;tsPattern&quot;;public static final String EMBEDDED_PROPERTY_SEPARATOR = &quot;separator&quot;;static { derivedTimeColumns.put(&quot;minute_start&quot;, 1); derivedTimeColumns.put(&quot;hour_start&quot;, 2); derivedTimeColumns.put(&quot;day_start&quot;, 3); derivedTimeColumns.put(&quot;week_start&quot;, 4); derivedTimeColumns.put(&quot;month_start&quot;, 5); derivedTimeColumns.put(&quot;quarter_start&quot;, 6); derivedTimeColumns.put(&quot;year_start&quot;, 7); defaultProperties.put(PROPERTY_TS_COLUMN_NAME, &quot;timestamp&quot;); defaultProperties.put(PROPERTY_TS_PARSER, &quot;org.apache.kylin.source.kafka.DefaultTimeParser&quot;); defaultProperties.put(PROPERTY_TS_PATTERN, DateFormat.DEFAULT_DATETIME_PATTERN_WITHOUT_MILLISECONDS); defaultProperties.put(EMBEDDED_PROPERTY_SEPARATOR, &quot;_&quot;); } 自然而然会联想到，这个默认的配置肯定是可以在用户设置的时候通过key（separator）去覆盖的…于是发现在构建Streaming table的时候，可以通过Parse Properties去覆盖配置。于是直接写成如下的形式： 12345678910111213141516171819202122232425262728293031323334tsColName=timestamp;separator=no//源码中拿到这个配置之后会做覆盖处理，然后执行 getValueByKey：protected String getValueByKey(String key, Map&lt;String, Object&gt; rootMap) throws IOException { if (rootMap.containsKey(key)) { return objToString(rootMap.get(key)); } String[] names = nameMap.get(key); if (names == null &amp;&amp; key.contains(separator)) { names = key.toLowerCase().split(separator); nameMap.put(key, names); } if (names != null &amp;&amp; names.length &gt; 0) { tempMap.clear(); tempMap.putAll(rootMap); //这块如果复写了separator属性的话split后的names数组长度为1会跳过这一步循环，防止解析出错 for (int i = 0; i &lt; names.length - 1; i++) { Object o = tempMap.get(names[i]); if (o instanceof Map) { tempMap.clear(); tempMap.putAll((Map&lt;String, Object&gt;) o); } else { throw new IOException(&quot;Property &apos;&quot; + names[i] + &quot;&apos; is not embedded format&quot;); } } Object finalObject = tempMap.get(names[names.length - 1]); return objToString(finalObject); } return StringUtils.EMPTY; }","link":"/2017/05/02/Kylin学习笔记/"},{"title":"MR任务在Hadoop子系统中状态流转","text":"深入做hadoop相关的工作也有一段时间了，期间零零散散看了不少源码，但很多都是看完就忘了，很难形成结构化的记忆。于是决定通过流程图的方式来刻画一个MR任务在Hadoop子系统中的状态机流转过程。知乎链接 MR任务提交过程 一个MR任务在hadoop 客户端通过rpc 方式提交到yarn上；大致过程如上图 JobSubmitter 封装了向yarn(ClientRMService)提交的过程 与hdfs交互计算任务输入数据的分片大小，以及将jar包加入DistributedCache中 ClientServiceDelegate 设计的目的是统一封装monitorJob过程获取任务执行状态，counters等信息的rpc client代理；其背后通过Java反射的方式，在任务的不同阶段会分别请求RM, AM, 或MR History Server（以下简称MHS）服务 因各种情况会有部分线上任务流量降级穿透到MHS服务，而MHS服务自身实现有较大瓶颈，我们其进行了leveldb方案的改造，整体查询性能提升20倍 分片计算过程下面看一下getSplits过程，我们默认用的是CombineFileInputFormat实现，先上图 我们知道，MR计算框架强调的是数据本地性。在图中有三个结构nodeToBlocks，rackToBlocks，blockToNodes；其中nodeToBlocks代表的是local级别，优先选择此集合中的分片，当剩下的blocks不足minSizeNode阈值时会通过blockToNodes数据结构，进行次优的分片划分的过程，以此类推。 ApplicationMaster启动过程当一个任务提交到RM后，需要等待RM分配资源启动AM之后才开始后续自己的资源&amp;任务处理过程，先上图（以下板块省去了内部自实现的调度算法） 此时涉及到RMApp, RMAppAttempt，RMNode，以及RMContainer等状态机的轮转 MR任务状态机流转当Yarn RM通过ContainerManagerProtocol协议将AM Container启动之后，AM便开始了Map/Reduce（一般map执行完之后）任务调度过程 运行期间涉及到的状态机有Job, Task, 以及TaskAttempt，当然还有AM register/unregister过程Yarn RM系统对应的状态机转换；大致描述一下流程： MR AM启动，通过Job状态机初始化 初始化CommitterEventHandler，用于最后job完成时通过commit过程将temp目录的数据转移到final 目录中 初始化Map/Reduce Task以及对应的TaskAttempt（Task具体的某次尝试），通过RMContainerAllocator先对map task进行调度，后进行reduce task调度 通过ApplicationMasterService向RM注册自己，代表某个RMAppAttempt对应的AM Container已启动，可以定期向RM发送allocate心跳了 在RMContainerAllocator中通过allocate心跳向RM请求资源，得到response之后将分得的container再按优先级assign给对应的task 在TaskAttempt得到container之后通过ContainerLanucher向NodeManager请求启动Container 任务运行完成做对应的commit，clean操作之后，通过ApplicatioinMasterService告知RM任务完成，此时RMApp/Attempt做任务完成的状态转换","link":"/2020/01/07/MR任务在Hadoop子系统中状态流转/"},{"title":"Raft论文学习","text":"前言分布式系统领域自然离不开一致性协议，而其中以Paxos和Raft最为著称。Paxos和Raft早两年有接触过，受限于当时的知识水平，对实现细节难免囫囵吞枣；最近决心专供分布式系统，于是重新拾起相关Paper开始拜读。以下是Raft 论文读后总结 Raft 五大性质 Election Safety: 在每一个term里，至多（有可能没有）只能有一个leader被选出 Leader Append-Only: leader节点不会对自身的log entries 进行覆写/删除的操作；只是单纯的append Log Matching: 如果两个log entry 拥有相同的index和term，那么这两个entry是相等 Leader Completeness: 在一个term中，如果log entry被commit了，那么这个entry 将会存在于所有的其他任期的leader中（也是作为Candidate是否被选中的一个条件） State Machine Safety: 如果一个节点apply 了一个log entry，那么带有相同index却不同的log entry是不能被其他任何一个节点所apply Raft 组成部分 Raft 由 Leader，Follower以及Candidate三种角色组成，三者之间组成有限状态机，可在一定事件下互相切换，具体如下图 根据上图，角色对应的分工如下 Follower 响应candidates和leader的 rpc请求 如果leader在timeout之内未发送心跳，则主动切换为candidate发起新一轮选举 Candidate：主要是选举 将currentTerm +1，且投给自己，并发起Request Vote RPC给所有其他节点寻求投票 如果收到大多数节点投票，则变成leader，通知所有节点切换为follower 如果通过AppendEntries RPC说明新的leader选举成功，则将自己置为follower 可能出现都投自己的情况（极端）：这种情况的处理机制是所有candidate 任意sleep 一段时间（150-300ms），再触发新一轮选举 Leader: 维持心跳，防止触发leader选举 如果接收到客户端append log请求，leader 会并发地向followers 发起AppendEntries Rpc请求，等大多数follower 节点都返回成功之后再将log entry本地commit, 并将结果最终结果返回给客户端；如果失败则retry，正常的请求处理流程如下图 在收到客户端append log 请求后，检测是否最新的log index大于nexIndex 中的值，如果是，则需要给follower 发送AppendEntries RPC请求 请求成功：更新nextIndex和matchIndex 请求失败：一般是因为leader重选导致数据不一致，则减小nextIndex 重新发送AppendEntries RPC，如此往复，直到找到follower 与 leader 同步的最近一条log entry为止 如果存在N， N&gt;CommitIndex，大多数matchIndex[follower]&gt;=N，且log[N].term == currentTerm，则将commitIndex 置为N 实现Raft的数据结构 消息状态划分 123Uncommit: 未提交转态（Client发到主节点，主节点还没有得到大多数从节点的提交回执）Commited: 已提交转态（从节点收到主节点的消息提交，还未收到确认报文）Applied: 已确认转态（从节点收到主节点的确认报文，或主节点已收到大多数从节点的提交回执） State ：每个节点的状态 在所有节点上都有的 1234567//实际落盘的currentTerm：通过rpc接到的最新的任期，初始化为0，随着选举次数增加而增加votedFor: 保存着一次选举过程中所投的candidateId，为空表示还未投票log[]: log entries集合，每个entry由记录和所属任期组成 tuple2&lt;command,term&gt;//在内存中实时可见的commitIndex: 已确认被commit了的最高位的log entry indexlastApplied: 被当前节点applied的最高位的log entry index 在leader 上的状态，每一次选举过后都会在新的leader上重新初始化 12nextIndex[]: 保存着每一个follower节点的下一个log entry index;初始化中leader last log index +1matchIndex[]: 保存着每一个follower已经被确认replicate成功的最高位的log entry index；初始化为0 RequestVote RPC 工作模式 AppendEntries RPC工作模式 由leader 发起log replicate，以及维护leader to follower 心跳，防止新一轮election触发123456789101112131415//rpc 请求参数term：leader termleaderId:pervLogIndex: 上一次apply过的 log 对应的IndexprevLogTerm: 上一次apply过的log 对应的termentries[]: 要同步的log entries，之所以是数组是优化性能，减少rpc调用次数leaderCommit: leader最近一次提交的commitIndex//rpc 返回值term: follower 当前的termsuccss: 如果follower mactch了prevLogIndex和prevLogTerm返回true//replicate 处理逻辑如果term&lt; currentTerm，则返回false如果match 不上prevLogIndex和prevLogTerm 则返回fase如果当前节点存在相同index但是不同term的entry，则强制删掉该index之后所有的entry，从该节点往后同步leader log entry如果 leaderCommit &gt; commitIndex, 将commitIndex 设置为min(leaderCommit, index of last new entry) Leader崩溃如何保证follower跟新leader的数据一致性 问题：旧leader挂掉之后，follower通过心跳感知，并转为candidate，触发新一轮选举。新leader产生之后，leader和follower之间很可能存在数据不一致的情况：某些log entry在leader上不存在 Raft的做法是：leader会强制follower 完全复制自己的数据，这样会导致follower上的log entries 可能会被覆写删除（Kafka中partition leader与follower 之间的Sync参考了这一点） 如上图，通过不断的retry之后找到leader和follower之间一致的log entry；从那个entry之后开始同步（强行覆写）如何防止brain split后log entries正确性 问题：如果集群中某一个follower 由于网络问题，长时间没收到leader心跳，如果这时它选自己为leader，等到网络恢复后是不是会成为新的leader覆写之前被commit 的log entry？ Raft做法：增加被选为Leader的限制(参考性质*Leader Completeness) Raft 确保只有那些包含所有committed log entries（majority） 的candidates 才有资格被选为leader 实现：Vote RPC中包含了candidate 的log 信息，这样voter就可以通过对比自己的日志中log entry 的 index和term来判断candidate 是不是比自己日志更latest如何继续leader crash之前的commit操作 这个问题存在的前提是新一轮leader election 被选为新leader的节点上保存了上一个leader 未commit成功的log entry；在raft协议中只确保commit 当前leader中的log entries会按照副本数机制实现(num of replicas &gt; num of node / 2 ) 这种确保的是：如果一条log entry 被当前leader commit成功，那么可以认为之前所有的entries 都commit成功了（参考特性5 — Log Matching Property ），也不需将之前的log entry的term 改成current term Follower&amp;&amp;Candidate崩溃 follower 和 candidate 崩溃处理方式比较简单 如果一个follower 或者 candidate 挂掉了，RequestVote 和 AppendEntries RPC 都会失败，处理的方式就是无限次的retry，只要服务重启，就能随着rpc 同步到最新的状态 集群扩缩容 目前我们讨论的都是在一组固定的节点上操作，但是在现实中存在因为节点的down掉以及扩容的需求，需要变更集群节点。 如果直接变更的话，可能会出现一段时间brain split的情况。最稳妥的方案就是将服务全部下线，扩容完成之后再重新上线，但是这过于低效 如图表示的是滚动升级的情况，逐个重启旧server，会存在新旧两个leader同时存在的情况（各自都赢得了所在集群大多数的vote） 解决方案：引入一种特殊类型的log entry，专门用来做集群配置更替，把它叫做C (old,new)，当C(old,new)被commit之后集群进入 joint consensus（联合一致性），即新旧集群共存的状态。在这种状态下，需遵循的规则如下： Log entries将被replicate到新旧配置的所有server节点中 任何一个节点通过新旧任何一份配置都有权利在选举中成为leader 选举结果和log entry commitment的决定需要各自配置中的大多数节点认可 讨论集群扩容的例子 第一阶段：逐台变更时，部分server上处于C(old,new) 状态，此时leader选举只能从C(old, new) 或 C(old) 中产生，具体取决于candidate是否接收到了C(old,new) log entry；当C(old, new) 被最终committed，则只拥有C(new)和C(old) 的server将再无法被选举为leader（参考特性4 — Log Matching Property） 第二阶段：接着再引入一种log entry C(new) ，将它同步到所有节点，等C(new) 最终committed之后则集群切到了C(new) 需注意的点 新上的节点会存在相对于老集群数据落后的情况，需要一段时间的sync，以追上其他节点，这期间不做任何投票操作（此处可类比Doris 里面Observer的设计理念） 第二阶段结束时，下掉的节点可能不在新集群的配置里面，也就不会接收到心跳，这样可能触发下掉的server leader选举 为防止扰乱集群可以规定：server如果在timeout允许的范围内正常的接收到了leader的心跳，则会忽略其他RequestVote Rpc请求 日志压缩 日志如果不做压缩处理，理论上会无限期膨胀，期间可能很多重复多余的数据，浪费空间 最简单的做法就是利用snapshot，将系统整个的状态数据作为一个snapshot保存到stable storage上，这样在上一个时间点的snapshot就可以被删除了（FLink的 checkpoint 和Doris的metadata里面也是这么做的） 一些其他的方式如：LSM Tree, log cleaning 等都可以 客户端设计的原则 首先客户端需要具备请求超时重发机制：请求random server会被reject，如果leader 挂掉触发选举也需要再一次的retry Raft 对客户端的设计目标是要实现线性一致性语义，这样要求客户端每次command需要分配一个unique serial numer，在server端的state machine中会跟踪client最近一次的serial number，如果被serial number表示的command已经被执行完了则不会被再次执行（类似Doris 里面mini load Label的概念） 只读订阅需求：（范例可了解Doris 元数据设计）为了降低leader节点的负载，可以允许client 请求follower节点读取数据；但是有一个缺点就是随着leader选举的过程，可能会读到过期的数据（被commited的数据没有被读到，这不满足线性一致性设计理念），针对这个, 有两种预防措施 主节点选举成功之后，立即发一个空的log entry到所有节点，这样就触发了集群中所有follower节点向leader强制同步的过程 主节点在响应read-only请求之前必须确认自己是否已经过期，防止自身的信息处于过期的状态；确认方法是集群中大多数节点发送心跳 与Paxos的差异 Paxos 可以同时提交和处理多个提案，但是发生冲突时，理论上会有更高的延时（协商时间），而Raft算法会天生地把消息确定一个先后顺序。大幅减少了冲突的可能性","link":"/2019/05/01/Raft论文学习/"},{"title":"Spark实战总结","text":"前言Spark作为一款分布式计算查询引擎，在大数据领域逐渐扮演着越来越重要的作用。传统的MapReduce因计算模型缺陷导致在面对海量数据，复杂的计算场景下计算效率十分低下。于是Spark作为一种互补的即席查询实现方案被各大公司采用。下面是对Spark一些概念和使用的总结 Spark 基础Spark 的构成 ClusterManager: 在standalone模式中即为，Master主节点，控制整个集群，监控worker。在yarn模式中为资源管理器 worker :从节点，负责控制计算节点，启动Executro和Driver。在yarn模式中NodeManager,负责计算节点的控制。 Driver：运行Application的main()函数并且创建SparkContext Executor: 执行器，是为某Application运行在worker node上的一个进程，启动线程池运行任务上，每个Application拥有一组独立的executors SparkContext: 整个应用程序的上下文，控制整个应用的生命周期 RDD：Spark的基本计算单元，一组RDD形成执行的有向无环图RDD Graph(DAG) DAG Scheduler: 根据Job构建基于stage的DAG，并且提交stage给TaskScheduler TaskScheduler: 可以将提交给它的stage 拆分为更多的task并分发给Executor执行 SparkEnv: 线程级别的上下文，存储运行时的重要组件的引用 DStream: 是一个RDD的序列，由若干RDD组成。在一个batchInterval中，会产生一个RDD，产生的数据统一塞入到这个RDD中，采用内存+磁盘的模式，尽可能放到内存中，当数据量太大时会spill到磁盘中 Spark 概念释义 Transformation返回值还是一个RDD。它使用了链式调用的设计模式，对一个RDD进行计算后，变换成另外一个RDD，然后这个RDD又可以进行另外一次转换。这个过程是分布式的。 Action返回值不是一个RDD。它要么是一个Scala的普通集合，要么是一个值，要么是空，最终或返回到Driver程序，或把RDD写入到文件系统中。 Action是返回值返回给driver或者存储到文件，是RDD到result的变换，Transformation是RDD到RDD的变换。只有action执行时，rdd才会被计算生成，这是rdd懒惰执行的根本所在。 Driver是我们提交Spark程序的节点，并且所有的reduce类型的操作都会汇总到Driver节点进行整合。节点之间会将map/reduce等操作函数传递一个独立副本到每一个节点，这些变量也会复制到每台机器上，而节点之间的运算是相互独立的，变量的更新并不会传递回Driver程序。 Spark中分布式执行的条件 只要生成了task，就都是在executor中执行的，在driver中执行不会单独生成task 生成task的操作有: spark.read 读取文件，之后对文件做各种map, filter, reduce操作，都是针对partition而言的 spark 工作机制 一个Job被拆分成若干个Stage，每个Stage执行一些计算，产生一些中间结果。它们的目的是最终生成这个Job的计算结果。而每个Stage是一个task set，包含若干个task。Task是Spark中最小的工作单元，在一个executor上完成一个特定的事情。 除非用户指定持久化操作，否则转换过程中产生的中间数据在计算完毕后会被丢弃，即数据是非持久化的。 窄依赖:父RDD中的一个分区最多只会被子RDD中的一个分区使用，父RDD中，一个分区内的数据是不能被分割的，必须整个交付给子RDD中的一个分区。 宽依赖（Shuffle依赖）：父RDD中的分区可能会被多个子RDD分区使用。因为父RDD中一个分区内的数据会被分割，发送给子RDD的所有分区。因此Shuffle依赖也意味着父RDD与子RDD之间存在着Shuffle过程。 Spark作业 Application: 用户自定义的Spark程序，用户提交之后，Spark为App分配资源程序转换并执行。 Driver Program: 运行Application的main函数并且创建SparkContext RDD DAG： 当RDD遇到Action算子，将之前的所有算子形成一个有向无环图（DAG）。再在Spark中转化为Job,提交到集群进行执行，一个App中可以包含多个Job Job： RDD Graph触发的作业，由spark Action算子触发，在SparkContext中通过runJob方法向spark提交Job stage： 每个Job会根据RDD的宽依赖关系被切分很多stage ,每个stage包含一组相同的task，这一组task也叫taskset Task: 一个分区对应一个Task,Task 执行RDD中对应stage中所包含的算子，Taksk 被封装好后放入Executor的线程池中执行。 spark调度原理作业调度系统的设计很重要的一环便是资源调度。设计者将资源进行不同粒度的抽象建模，然后将资源统一放入调度器，通过一定的算法进行调度。 spark的多种运行模式：Local模式，standalone模式、YARN模式，Mesos模式。 Standalone VS Yarn 角色对比 123456standalone: yarn: client client Master ApplicationMaster Worker ExecutorRunnable Scheduler YarnClusterScheduler SchedulerBackend YarnClusterSchedulerBackend 在yarn中application Master 与Application Driver 运行于同一个JVM进程中 standalone架构图 on yarn架构图 application调度用户提交到spark中的作业集合，通过一定的算法对每个按一定次序分配集群中资源的过程。 FIFO模式，用户先提交的作业1优先分配需要的资源，之后提交的作业再分配资源，依次类推。 Mesos: 粗粒度模式和细粒度模式 YARN模式：独占模式，可以控制应用分配资源 yarn-cluster: 适用于生产环境。client将用户程序提交到到spark集群中就与spark集群断开联系了，此时client将不会发挥其他任何作用，仅仅负责提交。在此模式下。AM和driver是同一个东西，但官网上给的是driver运行在AM里，可以理解为AM包括了driver的功能就像Driver运行在AM里一样，此时的AM既能够向AM申请资源并进行分配，又能完成driver划分RDD提交task等工作 yarn-client: y适用于交互、调试，希望立即看到app的输出。Driver运行在客户端上，先有driver再用AM，此时driver负责RDD生成、task生成和分发，向AM申请资源等 ,AM负责向RM申请资源，其他的都由driver来完成 Job调度Job调度就是在application内部的一组Job集合，在application分配到的资源量，通过一定的算法，对每个按一定次序分配Application中资源的过程。 FIFO模式：先进先出模式 FAIR模式：spark在多个job之间以轮询的方式给任务进行资源分配，所有的任务拥有大致相当的优先级来共享集群的资源。这就意味着当一个长任务正在执行时，短任务仍可以分配到资源，提交并执行，并且获得不错的响应时间。 tasks延迟调度 数据本地性：尽量的避免数据在网络上的传输，传输任务为主，将任务传输到数据所在的节点 延时调度机制：拥有数据的节点当前正被其他的task占用，如果预测当前节点结束当前任务的时间要比移动数据的时间还要少，那么调度会等待，直到当前节点可用。否则移动数据到资源充足节点，分配任务执行。 spark transformation和action的算子transformation map(func) 返回一个新的分布式数据集，由每个原元素经过func函数处理后的新元素组成 filter(func) 返回一个新的数据集，由经过func函数处理后返回值为true的原元素组成 flatMap(func) 类似于map，但是每一个输入元素，会被映射为0个或多个输出元素，(因此，func函数的返回值是一个seq，而不是单一元素) mapPartitions(func) 类似于map，对RDD的每个分区起作用，在类型为T的RDD上运行时，func的函数类型必须是Iterator[T]=&gt;Iterator[U] mapPartitionsWithIndex(func) 和mapPartitions类似，但func带有一个整数参数表上分区的索引值，在类型为T的RDD上运行时，func的函数参数类型必须是(int,Iterator[T])=&gt;Iterator[U] sample(withReplacement,fraction,seed) 根据给定的随机种子seed，随机抽样出数量为fraction的数据 pipe(command,[envVars]) 通过管道的方式对RDD的每个分区使用shell命令进行操作，返回对应的结果 union(otherDataSet) 返回一个新的数据集，由原数据集合参数联合而成 intersection(otherDataset) 求两个RDD的交集 distinct([numtasks]) 返回一个包含源数据集中所有不重复元素的i新数据集 groupByKey([numtasks]) 在一个由(K,v)对组成的数据集上调用，返回一个(K,Seq[V])对组成的数据集。默认情况下，输出结果的并行度依赖于父RDD的分区数目，如果想要对key进行聚合的话，使用reduceByKey或者combineByKey会有更好的性能 reduceByKey(func,[numTasks]) 在一个(K,V)对的数据集上使用，返回一个(K,V)对的数据集，key相同的值，都被使用指定的reduce函数聚合到一起，reduce任务的个数是可以通过第二个可选参数来配置的 sortByKey([ascending],[numTasks]) 在类型为(K,V)的数据集上调用，返回以K为键进行排序的(K,V)对数据集，升序或者降序有boolean型的ascending参数决定 join(otherDataset,[numTasks]) 在类型为(K,V)和(K,W)类型的数据集上调用，返回一个(K,(V,W))对，每个key中的所有元素都在一起的数据集 cogroup(otherDataset,[numTasks]) 在类型为(K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为(K,Iterable[V],Iterable[W]) tuples cartesian(otherDataset) 笛卡尔积，但在数据集T和U上调用时，返回一个(T,U)对的数据集，所有元素交互进行笛卡尔积 coalesce(numPartitions) 对RDD中的分区减少指定的数目，通常在过滤完一个大的数据集之后进行此操作 repartition(numpartitions) 将RDD中所有records平均划分到numparitions个partition中 action算子操作 reduce(func) 通过函数func聚集数据集中的所有元素，这个函数必须是关联性的，确保可以被正确的并发执行 collect() 在driver的程序中，以数组的形式，返回数据集的所有元素，这通常会在使用filter或者其它操作后，返回一个足够小的数据子集再使用 count() 返回数据集的元素个数 first() 返回数据集的第一个元素(类似于take(1)) take(n) 返回一个数组，由数据集的前n个元素组成。注意此操作目前并非并行执行的，而是driver程序所在机器 takeSample(withReplacement,num,seed) 返回一个数组，在数据集中随机采样num个元素组成，可以选择是否用随机数替换不足的部分，seed用于指定的随机数生成器种子 saveAsTextFile(path) 将数据集的元素，以textfile的形式保存到本地文件系统hdfs或者任何其他hadoop支持的文件系统，spark将会调用每个元素的toString方法，并将它转换为文件中的一行文本 takeOrderd(n,[ordering]) 排序后的limit(n) saveAsSequenceFile(path) 将数据集的元素，以sequencefile的格式保存到指定的目录下，本地系统，hdfs或者任何其他hadoop支持的文件系统，RDD的元素必须由key-value对组成。并都实现了hadoop的writable接口或隐式可以转换为writable saveAsObjectFile(path) 使用java的序列化方法保存到本地文件，可以被sparkContext.objectFile()加载 countByKey() 对(K,V)类型的RDD有效，返回一个(K,Int)对的map，表示每一个可以对应的元素个数 foreache(func) 在数据集的每一个元素上，运行函数func,t通常用于更新一个累加器变量，或者和外部存储系统做交互 Spark常用存储格式parquet 详解 新型列式存储格式 Parquet 详解 - 后端 - 掘金 三个组成部分 存储格式(storage format) 对象模型转换器(object model converters) 对象模型(object models) ：简单理解为数据在内存中的表示 列式存储 把某一列数据连续存储，每一行数据离散存储技术 带来的优化 查询的时候不需要扫描全部的数据，而只需要读取每次查询涉及的列，这样可以将I/O消耗降低N倍，另外可以保存每一列的统计信息(min、max、sum等)，实现部分的谓词下推 由于每一列的成员都是同构的，可以针对不同的数据类型使用更高效的数据压缩算法，进一步减小I/O 由于每一列的成员的同构性，可以使用更加适合CPU pipeline的编码方式，减小CPU的缓存失效 数据模型 12345678message AddressBook { required string owner; repeated string ownerPhoneNumbers; repeated group contacts { required string name; optional string phoneNumber; }} 根被叫做message，有多个field 每个field包含三个属性:repetition, type, name repetition可以是required（出现1次）, optional（出现0次或1次），repeated（出现0次或者多次）。type可以是一个group或者一个primitive类型 parquet数据类型不需要复杂的Map, List, Set等，而是使用repeated fields 和 groups来表示。例如List和Set可以被表示成一个repeated field,Map可以表示成一个包含有Key-value对的repeated group， 而且key是required的 两个概念 repetition level ：指明该值在路径中哪个repeated field重复 针对的是repeted field的 。 它能用一个数字告诉我们在路径中的什么重复字段，此值重复了，以此来确定此值的位置 我们用深度0表示一个纪录的开头（虚拟的根节点），深度的计算忽略非重复字段（标签不是repeated的字段都不算在深度里） definition level：指明该列的路径上多少个可选field被定义了 如果一个field是定义的，那么它的所有的父节点都是被定义的 从根节点开始遍历，当某一个field的路径上的节点开始是空的时候我们记录下当前的深度作为这个field的Definition Level 如果一个field的definition Level等于这个field的最大definition Level就说明这个field是有数据的 注意：是指该路径上有定义的repeated field 和 optional field的个数，不包括required field，因为required field是必须有定义的 谓词下推：通过将一些过滤条件尽可能的在最底层执行可以减少每一层交互的数据量，从而提升性能 例如”select count(1) from A Join B on A.id = B.id where A.a &gt; 10 and B.b &lt; 100″SQL查询中 在处理Join操作之前需要首先对A和B执行TableScan操作，然后再进行Join，再执行过滤，最后计算聚合函数返回 但是如果把过滤条件A.a &gt; 10和B.b &lt; 100分别移到A表的TableScan和B表的TableScan的时候执行，可以大大降低Join操作的输入数据 无论是行式存储还是列式存储，都可以在将过滤条件在读取一条记录之后执行以判断该记录是否需要返回给调用者，在Parquet做了更进一步的优化 优化的方法时对每一个Row Group的每一个Column Chunk在存储的时候都计算对应的统计信息，包括该Column Chunk的最大值、最小值和空值个数。 通过这些统计值和该列的过滤条件可以判断该Row Group是否需要扫描。 另外Parquet未来还会增加诸如Bloom Filter和Index等优化数据，更加有效的完成谓词下推 映射下推：它意味着在获取表中原始数据时只需要扫描查询中需要的列 在Parquet中原生就支持映射下推，执行查询的时候可以通过Configuration传递需要读取的列的信息 这些列必须是Schema的子集，映射每次会扫描一个Row Group的数据，然后一次性得将该Row Group里所有需要的列的Cloumn Chunk都读取到内存中，每次读取一个Row Group的数据能够大大降低随机读的次数，除此之外，Parquet在读取的时候会考虑列是否连续，如果某些需要的列是存储位置是连续的，那么一次读操作就可以把多个列的数据读取到内存 Spark Stremaing 相关BlockRDD 由spark.streaming.blockInterval和duration决定有多少个BlockRdd Receiver模式 一个BatchDuration有几个block就会产生几个partition，可参考receiver bases approach 并行度由手动创建的receiver决定 direct模式 blockRDD不再对实际的分区数量起作用，而是会创建和kafka partitions 相同数量的RDD partitions，可参考direct approach 在实际运行的时候通过下发到executor上的task，边拉取数据边处理，这样即使每个task执行失败，对应分区下面的offset也没有提交，也能通过重启task恢复 消息消费速率限定 开启背压模式：spark.streaming.backpressure.enabled=true 此模式如果消息堆积严重，会一次性拉取kafka中所有堆积的消息进行处理。很可能会导致程序崩溃 设置每个partition消费速率, spark.streaming.kafka.maxRatePerPartition 对应每个batch拉取到的消息为: 1maxRatePerPartition*partitionNum*batch_interval Spark 优化相关优化建议 stage 的数量跟一个job中是否要进行shuffle有关，像reduceByKey，groupbyKey等等 尽量用broadcast和filter规避join操作 因为每次job partition数量过多，导致hive表中过多小文件产生，所以需要重新指定分区，有以下俩种方法：repartition(numPartitions:Int):RDD[T]和coalesce(numPartitions:Int，shuffle:Boolean=false):RDD[T]他们两个都是RDD的分区进行重新划分，repartition只是coalesce接口中shuffle为true的简易实现，（假设RDD有N个分区，需要重新划分成M个分区） N&lt;M。一般情况下N个分区有数据分布不均匀的状况，利用HashPartitioner函数将数据重新分区为M个，这时需要将shuffle设置为true。 如果N&gt;M并且N和M相差不多，(假如N是1000，M是100)那么就可以将N个分区中的若干个分区合并成一个新的分区，最终合并为M个分区，这时可以将shuff设置为false，在shuffl为false的情况下，如果M&gt;N时，coalesce为无效的，不进行shuffle过程，父RDD和子RDD之间是窄依赖关系。 如果N&gt;M并且两者相差悬殊，这时如果将shuffle设置为false，父子ＲＤＤ是窄依赖关系，他们同处在一个stage中，就可能造成Spark程序的并行度不够，从而影响性能，如果在M为1的时候，为了使coalesce之前的操作有更好的并行度，可以讲shuffle设置为true。 总之：如果shuffle为false时，如果传入的参数大于现有的分区数目，RDD的分区数不变，也就是说不经过shuffle，是无法将RDD的分区数变多的。 参数调优 美团Spark参数调优参考文章 最重要的是数据序列化和内存调优。对于大多数程序选择Kyro序列化器并持久化序列后的数据能解决常见的性能问题。 Executor 每个节点可以起一个或多个Executor。每个Executor上的一个核只能同时执行一个task,如果一个Executor被分到了多个task只能排队依次执行 Executor内存主要分三块：- 1、让task执行我们自己编写的代码，默认占总内存的20%。 - 2、让task通过shuffle过程拉取了上一个stage的task输出后，进行聚合等操作时，默认占用总内存20%； - 3、让RDD持久化使用，默认60% task的执行速度是跟每个Executor进程的CPU core数量有直接关系的。- 一个CPU core同一时间只能执行一个线程。 - 每个Executor进程上分配到的多个task，都是以每个task一条线程的方式，多线程并发运行的。如果CPU core数量比较充足，而且分配到的task数量比较合理，那么通常来说，可以比较快速和高效地执行完这些task线程。 广播大变量 当需要用到外部变量时，默认每个task都会存一份，这样会增加GC次数，使用广播变量能确保一个Executor中只有一份 使用Kryo优化序列化性能(如果希望RDD序列化存储在内存中，面临GC问题的时候，优先使用序列化缓存技术) spark没有默认使用Kryo作为序列化类库，是因为Kryo要求注册所有需要序列化的自定义类型，这对开发比较麻烦 Spark 内存管理\b 参考文章\b：apache spark内存管理详解 堆内内存\b和堆外内存\b 堆内：\bExecutor 的内存管理建立在 JVM 的内存管理之上，Spark 对 JVM 的堆内（On-heap）空间进行了更为详细的分配，以充分利用内存 缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为存储（Storage）内存 \b执行 Shuffle 时占用的内存被规划为执行（Execution）内存\b- 剩余部分\b： Spark 内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例 注意：\b在被 Spark 标记为释放的对象实例，很有可能在实际上并没有被 JVM 回收，导致实际可用的内存小于 Spark 记录的可用内存。所以 Spark 并不能准确记录实际可用的堆内内存，从而也就无法完全避免内存溢出（OOM, Out of Memory）的异常 堆外：进一步优化内存的使用以及提高 Shuffle 时排序的效率， \b可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据 \b堆外内存可以被精确地申请和释放，而且序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差 存储\b管理\b RDD 的持久化机制 RDD 的持久化由 Spark 的 Storage 模块 [7] 负责，实现了 RDD 与物理存储的解耦合 Storage 模块负责管理 Spark 在计算过程中产生的数据，将那些在内存或磁盘、在本地或远程存取数据的功能封装了起来 在具体实现时 Driver 端和 Executor 端的 Storage 模块构成了主从式的架构，即 Driver 端的 BlockManager 为 Master，Executor 端的 BlockManager 为 Slave。 Storage 模块在逻辑上以 Block 为基本存储单位，RDD 的每个 Partition 经过处理后唯一对应一个 Block（BlockId 的格式为 rdd_RDD-ID_PARTITION-ID ）。 Master 负责整个 Spark 应用程序的 Block 的元数据信息的管理和维护，而 Slave 需要将 Block 的更新等状态上报到 Master，同时接收 Master 的命令，例如新增或删除一个 RDD RDD 缓存的过程 RDD 在缓存到存储内存之后，Partition 被转换成 Block, 其中Record在堆内占有一块连续的空间\b 将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll） Block 有序列化和非序列化两种存储格式 用一个 LinkedHashMap 来集中管理所有的 Block，Block 由需要缓存的 RDD 的 Partition 转化而成 淘汰规则 被淘汰的旧 Block 要与新 Block 的 MemoryMode 相同，即同属于堆外或堆内内存 新旧 Block 不能属于同一个 RDD，避免循环淘汰 旧 Block 所属 RDD 不能处于被读状态，避免引发一致性问题 遍历 LinkedHashMap 中 Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新 Block 所需的空间。其中 LRU 是 LinkedHashMap 的特性。 Spark\b中执行内存\b管理\b shuffle write: 若在 map 端选择普通的排序方式，会采用 ExternalSorter 进行外排，在内存中存储数据时主要占用堆内执行空间。 若在 map 端选择 Tungsten 的排序方式，则采用 ShuffleExternalSorter 直接对以序列化形式存储的数据排序，在内存中存储数据时可以占用堆外或堆内执行空间，取决于用户是否开启了堆外内存以及堆外执行内存是否足够。 shuffle read: 在对 reduce 端的数据进行聚合时，要将数据交给 Aggregator 处理，在内存中存储数据时占用堆内执行空间。 如果需要进行最终结果排序，则要将再次将数据交给 ExternalSorter 处理，占用堆内执行空间。 Spark 用 AppendOnlyMap 来存储 Shuffle 过程中的数据，在 Tungsten 排序中甚至抽象成为页式内存管理，开辟了全新的 JVM 内存管理机制","link":"/2018/10/15/Spark学习笔记/"},{"title":"ReentrantLock与condition应用后的思考","text":"一直在断断续续看《java并发编程实战》这本书，每次看都有不一样的体会，前些日子在知乎上回答了一个关于ReentrantLock的问题java里是怎么通过condition接口是获取监视器方法的 ,那次回答之后也引发了我对其实现的进一步探究。 一个例子举一个简单的例子，是基本上各个公司招聘的时候都会出现的关于多线程间通信的问题：利用多线程循环打印n次”ABC”。当然，这个题目有很多实现方法，有经典的wait和notify的原生方法,也有时髦一点的ReentrantLock写法，如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Created by lichao on 2016/1/20. */public class PrintABC { static ReentrantLock lock = new ReentrantLock(); static Condition conditionA = lock.newCondition(); static Condition conditionB = lock.newCondition(); static Condition conditionC = lock.newCondition(); static int signal = 1;//1=&gt;A, 2=&gt;B 3=&gt;C static int loopValue = 10; class taskA implements Runnable { @Override public void run() { lock.lock(); try { for (int i = 0; i &lt; loopValue; i++) { if (signal != 1) { conditionA.await(); conditionB.signalAll(); conditionC.signalAll(); } signal = 2; System.out.print(&quot;A&quot;); conditionB.signal(); conditionA.await(); } } catch (Exception ex) { } finally { lock.unlock(); } } } class taskB implements Runnable { @Override public void run() { lock.lock(); try { for (int i = 0; i &lt; loopValue; i++) { if (signal != 2) { conditionB.await(); conditionA.signalAll(); conditionC.signalAll(); } signal = 3; System.out.print(&quot;B&quot;); conditionC.signal(); conditionB.await(); } } catch (Exception ex) { } finally { lock.unlock(); } } } class taskC implements Runnable { @Override public void run() { lock.lock(); try { for (int i = 0; i &lt; loopValue; i++) { if (signal != 3) { conditionC.await(); conditionB.signalAll(); conditionA.signalAll(); } signal = 1; System.out.print(&quot;C&quot;); conditionA.signal(); conditionC.await(); } } catch (Exception ex) { } finally { lock.unlock(); } } } public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(3); executorService.submit(new PrintABC().new taskC()); executorService.submit(new PrintABC().new taskB()); executorService.submit(new PrintABC().new taskA()); }} 首先定义了一个可重入锁，然后起了三个监视器用于控制任务a,b,c的状态，signal作为信号量用于表明当前应该哪个线程执行打印操作，实现无论任务往线程池中提交的顺序如何都能正确打印ABC的顺序 讲讲原理 ReentrantLock（重入锁）是jdk的concurrent包提供的一种独占锁的实现。它继承自Dong Lea的 AbstractQueuedSynchronizer（同步器）。回到上面的代码，我们提交任务是按照CBA的次序来提交的，也就是打印C的任务会先开始执行，而当前的信号量signal为1,也就是A而不是3，所以通过conditonC.await()来释放锁，同时线程休眠等待唤醒，这时A拿到了，并且打印后将signal置为2即B，同时通过conditionA.await()方法使自己休眠，并唤醒B进行打印。以此类推，总的来说，ReentrantLock�与condition配合，优雅的完成了wait和notify做的事情。 我们来看看其中是如何实现这种线程的调度过程的：reentrantLock.newCondition() 返回的是Condition的一个实现，该类在AbstractQueuedSynchronizer中被实现，可以访问AbstractQueuedSynchronizer中的方法和其余内部类,await被调用时的代码如下：12345678910111213141516171819202122public final void await() throws InterruptedException {if (Thread.interrupted()) throw new InterruptedException(); //将当前线程包装下后，添加到Condition自己维护的一个链表中。 Node node = addConditionWaiter(); //释放当前线程占有的锁int savedState = fullyRelease(node);int interruptMode = 0; while (!isOnSyncQueue(node)) { //释放完毕后，不断AQS的队列，看当前节点是否在队列中，不在 说明它还没有竞争锁的资格，所以继续将自己沉睡。直到它被重新加入到队列中. LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; }//被唤醒后，重新开始正式竞争锁，同样，如果竞争不到还是会将自己沉睡，等待唤醒重新开始竞争。if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } signal方法的调用代码123456789101112131415161718192021222324252627282930313233343536373839public final void signal() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; //firstWaiter为condition自己维护的一个链表的头结点， //取出第一个节点后开始唤醒操作 if (first != null) doSignal(first); } private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) //修改头结点，完成旧头结点的移出工作 lastWaiter = null; first.nextWaiter = null; } while (!transferForSignal(first) &amp;&amp;//将老的头结点，加入到AQS的等待队列中 (first = firstWaiter) != null); }final boolean transferForSignal(Node node) { /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false;/* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ Node p = enq(node); int ws = p.waitStatus;//如果该结点的状态为cancel 或者修改waitStatus失败，则直接唤醒。 if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; } 其实condition内部维护了一个等待队列，用于存放等待signal的任务123456789101112131415161718192021222324252627public class ConditionObject implements Condition, java.io.Serializable { private static final long serialVersionUID = 1173984872572414699L; /** First node of condition queue. */ private transient Node firstWaiter; /** Last node of condition queue. */ private transient Node lastWaiter; ** * Adds a new waiter to wait queue. * @return its new wait node */ private Node addConditionWaiter() { Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; }} 而AbstractQueuedSynchronizer中也维护了一个队列，就是获取当前资源的等待队列，当资源释放掉之后，会依次从队列中恢复线程，直至为空。每个线程会在这俩个队列中来回切换，但同一时刻仅存在于一个队列中。1234567线程1-&gt;AQS: ReentrantLock.lock（加入AQS队列，获取资源）线程1-&gt;AQS: condition.await()（移除队列，释放资源）AQS-&gt;condition队列: 线程1加入condition等待队列线程2-&gt;AQS: 线程2加入AQS队列并获取资源线程2-&gt;AQS: condition2.await()（移除AQS队列，释放资源）线程2-&gt;线程1: condition.signal()（线程2调用signal唤醒线程1）线程1-&gt;AQS: ReentrantLock.lock(重新加入AQS队列，获取资源) ###总结还是得深入源码去看问题，不能只关注业务，否则会成为彻头彻尾的搬砖工，不仅要会用轮子，还要会造轮子。最后分享一片陈浩写的技术人员的职业生涯文章，共勉。技术人员的发展之路","link":"/2017/01/20/ReentrantLock与condition应用后的思考/"},{"title":"Spring源码解读(-)","text":"IOC设计理念先来看看接口设计预览图： bean 实例化总体步骤 资源定位与注册容器的初始化过程是IOC实现的入口，过程如下： Resource定位。BeanDefitioin的资源定位，由ResourceLoader通过统一的Resource接口完成，这个Resource对各种形式的BeanDefinition使用都提供了统一接口。 BeanDefition的载入。这个载入过程是用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器的数据结构就是BeanDefition。BeanDefition实际上就是POJO对象在IOC容器中的抽象，通过这个BeanDefition定义的数据结构，使得IOC容器能够方便地对POJO对象也就是Bean进行管理。 向IOC容器注册这些BeanDefition的过程。调用BeanDefitionRegistry接口的实现来完成。把解析得到的BeanDefition向容器中进行注册。在IOC内部将BeanDefition注入到一个HasMap中去(BeanDefitionHolder),IOC容器就是通过这个HashMap来持有这些BeanDefition数据的。 值得注意：容器初始化过程不包括依赖注入的实现，Bean定义的载入和依赖注入是俩个独立的过程。依赖注入一般发生在第一次getBean的时候或者通过设置lazyinit实现预先注入Bean。 说明 AbstractApplicationContext定义了基本的refresh方法，其他的由子类去实现扩展,即AbstractApplicationContext是容器初始化的入口 DefaultListableBeanFactory是IOC容器的基础，FileSystemXmlApplicationContext、WebXmlApplicationContext都是建立在DefaultListableBeanFactory之上，实现自定义BeanDefinition的载入方式 依赖注入 初始化过程完成的主要工作是在IOC容器中建立BeanDefinition数据映射。此过程中并没有实现IOC容器对Bean依赖关系进行注入。 对于依赖注入，其触发条件是用户第一次向IOC容器索要Bean时触发的。当然也可以通过控制lazy-init属性来让容器完成对bean的预实例化。 依赖注入的起点： IOC容器接口BeanFactory中定义了一个getBean接口，这个接口的实现就是触发依赖注入的地方。可以在DefaultListableBeanFactory的类AbstractBeanFactory入手看看getBean的实现。 SimpleInstsntiationStrategy类，这个Strategy是Spring用来生成Bean对象的默认类，提供了俩种实例化Java对象的方法，一种是通过BeanUtils，它使用了JVM的反射功能，一种是CGLIB来生成，代码如下: 1234567891011121314151617181920212223242526272829303132333435363738@Override public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) { // Don&apos;t override the class with CGLIB if no overrides. if (bd.getMethodOverrides().isEmpty()) { Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) { constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) { final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) { throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;); } try { if (System.getSecurityManager() != null) { constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() { @Override public Constructor&lt;?&gt; run() throws Exception { return clazz.getDeclaredConstructor((Class[]) null); } }); } else { constructorToUse = clazz.getDeclaredConstructor((Class[]) null); } bd.resolvedConstructorOrFactoryMethod = constructorToUse; } catch (Throwable ex) { throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex); } } } return BeanUtils.instantiateClass(constructorToUse); } else { // Must generate CGLIB subclass. return instantiateWithMethodInjection(bd, beanName, owner); } } 依赖注入最终步骤：在实例化Bean对象生成的基础上，对于Bean对象生成以后，怎样对这些Bean对象的依赖关系处理好，完成整个依赖注入过程？即通过populateBean方法完成，这个方法在AbstractAutowireCapableBeanFactory中实现，AutoWire的依赖注入等，都做了集中处理。 Bean的初始化(InitializeBean)：：在initializeBean方法中，需要使用Bean的名字，完成依赖注入以后的Bean对象，以及这个Bean对应的BeanDefinition。然后开始初始化工作： 为类型是BeanNameAware的Bean设置Bean的名字 为类型是BeanClassLoaderAware的Bean设置类装载器， 类型是BeanFactoryAware的Bean设置自身所在的IOC容器以供回调使用，对PostProcessBeforeInitialization/postAfterInitialization的回调和初始化属性init-method的处理等。 最后，就可以正常的使用由IOC容器托管的Bean了 讲讲预先注入我们讲过依赖注入一般发生在用户第一次请求，但是也可以设置lazy-init属性实现预先依赖注入。这部分过程依然属于AbstractApplicationContext的 refresh方法中。在finishBeanFactoryInitialization的方法中，封装了lazy-init属性的处理，实际的处理是在DefaultListableBeanFactory这个基本容器的preInstantiateSingletons方法中完成的。该方法对单件Bean完成预先实例化。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public void refresh() throws BeansException, IllegalStateException { Object var1 = this.startupShutdownMonitor; synchronized(this.startupShutdownMonitor) { this.prepareRefresh(); ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory(); this.prepareBeanFactory(beanFactory); try { this.postProcessBeanFactory(beanFactory); this.invokeBeanFactoryPostProcessors(beanFactory); this.registerBeanPostProcessors(beanFactory); this.initMessageSource(); this.initApplicationEventMulticaster(); this.onRefresh(); this.registerListeners(); //预先实例化入口 this.finishBeanFactoryInitialization(beanFactory); this.finishRefresh(); } catch (BeansException var9) { if(this.logger.isWarnEnabled()) { this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9); } this.destroyBeans(); this.cancelRefresh(var9); throw var9; } finally { this.resetCommonCaches(); } } } //在finishBeanFactoryInitialization方法中进行具体的处理过程 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { ... beanFactory.setTempClassLoader((ClassLoader)null); beanFactory.freezeConfiguration(); beanFactory.preInstantiateSingletons(); } public void preInstantiateSingletons() throws BeansException { List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); // Trigger initialization of all non-lazy singleton beans... for (String beanName : beanNames) { RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) { if (isFactoryBean(beanName)) { final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() { @Override public Boolean run() { return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); } }, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } else { getBean(beanName); } } } // Trigger post-initialization callback for all applicable beans... for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { smartSingleton.afterSingletonsInstantiated(); return null; } }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } } }} 存疑： spring 2 中preInstantiateSingletons的实现是加了个Synchronized内置锁，而在当前版本中，这一步去掉了锁，why? AOPAOP名词解释 方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用spring的 Advisor或拦截器实现。 连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。 通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice 切入点（Pointcut 一系列连接点的集合）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上 引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口 目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入 设计原理及流程Advice、PointCut、Advisor(通知器，组织起Advice与PointCut) AopProxy代理对象生成过程：ProxyFactoryBean和ProxyFactory都提供了AOP的功能封装，但是ProxyFactoryBean与IOC进行了结合，利用BeanFactoryAware获取ApplicationContext,从而可以利用context对IOC注入的bean进行获取 1初始化通知链—— &gt;获取单例，没有的话去创建——&gt;判断是否为接口，如果为接口使用JDK,如果不是使用CGlib最后返回AopProxy AOP调用invoke方法，里面逐个去应用配置好的拦截器链,在逐个应用之前先进行一系列的判断： 12345678910111213141516171819202122232425262728293031／／如果目标对象没有实现object的基本法方法：equals、如果目标对象没有实现object的基本方法： hashcode、根据代理对象的配置来调用服务if(!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) { Boolean retVal3 = Boolean.valueOf(this.equals(args[0])); return retVal3;}if(!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) { Integer retVal2 = Integer.valueOf(this.hashCode()); return retVal2;}if(method.getDeclaringClass() == DecoratingProxy.class) { Class retVal1 = AopProxyUtils.ultimateTargetClass(this.advised); return retVal1;}Object retVal;if(!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) { retVal = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args); return retVal;}if(this.advised.exposeProxy) { oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true;}target = targetSource.getTarget();if(target != null) { targetClass = target.getClass();} 然后获取配置好的拦截器： 1List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); 判断是否为空，为空的话直接调用invokeJoinpointUsingReflection方法。这个方法直接调用目标方法的实现，代码如下： 123456789101112131415161718192021222324252627282930public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable { try { ReflectionUtils.makeAccessible(method); return method.invoke(target, args); } catch (InvocationTargetException var4) { throw var4.getTargetException(); } catch (IllegalArgumentException var5) { throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; + method + &quot;] on target [&quot; + target + &quot;]&quot;, var5); } catch (IllegalAccessException var6) { throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, var6); }}如果不为空，则创建ReflectiveMethodInvocation传入chain（拦截器链）,然后调用proceed方法，这个方法去递归调用拦截器链中的invoke方法，代码如下（在拦截器的调用一节还会详细展开介绍）：ReflectiveMethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);retVal = invocation.proceed();public Object proceed() throws Throwable { if(this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) { return this.invokeJoinpoint(); } else { Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if(interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) { InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice; return dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)?dm.interceptor.invoke(this):this.proceed(); } else { return ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this); } }} 对于最后的目标对象的调用：JDK 直接通过AopUtils的反射机制而cglib则是通过 MethodProxy完成调用，这是cglib自己封住好的功能。 1retval=methodProxy.invoke(target,args); AOP拦截器链的调用了解了AOP的调用之后，再来看看AOP是怎么实现对目标对象增强的。在运行拦截器链的拦截方法时，需要对代理方法完成一个匹配判断，通过这个匹配判断来决定是否满足切面增强的要求。确定是否执行拦截方法。获取interceptors的操作是由advised的对象完成的。是一个AdvisedSupport对象。AdvisedSupport是ProxyFactoryBean的基类。在其中，我们可以看到getInterceptorsAndDynamicInterceptionAdvice 方法的实现： 12345678910public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class&lt;?&gt; targetClass) { AdvisedSupport.MethodCacheKey cacheKey = new AdvisedSupport.MethodCacheKey(method); List cached = (List)this.methodCache.get(cacheKey); if(cached == null) { cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass); this.methodCache.put(cacheKey, cached); } return cached;} 这里AdvisedSupport被配置成一个DefaultAdvisedSupport对象，里面实现了具体的getInterceptorsAndDynamicInterceptionAdvice方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class&lt;?&gt; targetClass) { ArrayList interceptorList = new ArrayList(config.getAdvisors().length); Class actualClass = targetClass != null?targetClass:method.getDeclaringClass(); boolean hasIntroductions = hasMatchingIntroductions(config, actualClass); AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); Advisor[] var8 = config.getAdvisors(); int var9 = var8.length; for(int var10 = 0; var10 &lt; var9; ++var10) { Advisor advisor = var8[var10]; MethodInterceptor[] interceptors1; if(advisor instanceof PointcutAdvisor) { PointcutAdvisor var20 = (PointcutAdvisor)advisor; if(config.isPreFiltered() || var20.getPointcut().getClassFilter().matches(actualClass)) { interceptors1 = registry.getInterceptors(advisor); MethodMatcher mm = var20.getPointcut().getMethodMatcher(); if(MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) { if(mm.isRuntime()) { MethodInterceptor[] var15 = interceptors1; int var16 = interceptors1.length; for(int var17 = 0; var17 &lt; var16; ++var17) { MethodInterceptor interceptor = var15[var17]; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors1)); } } } } else if(advisor instanceof IntroductionAdvisor) { IntroductionAdvisor var19 = (IntroductionAdvisor)advisor; if(config.isPreFiltered() || var19.getClassFilter().matches(actualClass)) { interceptors1 = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors1)); } } else { MethodInterceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } return interceptorList;} DefaultAdvisorChainFactory 会通过一个AdvisorDapterRegister实现拦截器的注册，注册完成之后,List中的拦截器会被JDK生成的AopProxy中的代理对象的invoke调用，这里通过配置的Intercepters获得拦截器列表然后逐一应用在目标方法上。 12345678910111213141516171819202122public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException { ArrayList interceptors = new ArrayList(3); Advice advice = advisor.getAdvice(); if(advice instanceof MethodInterceptor) { interceptors.add((MethodInterceptor)advice); } Iterator var4 = this.adapters.iterator(); while(var4.hasNext()) { AdvisorAdapter adapter = (AdvisorAdapter)var4.next(); if(adapter.supportsAdvice(advice)) { interceptors.add(adapter.getInterceptor(advisor)); } } if(interceptors.isEmpty()) { throw new UnknownAdviceTypeException(advisor.getAdvice()); } else { return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[interceptors.size()]); } }","link":"/2017/02/07/Spring源码解读/"},{"title":"impala集群搭建","text":"前言说起Impala，很多人都不会陌生。它区别于MapReduce\b\b 中间结果溢写，跨节点数据获取的低效，采用MPP\b 查询引擎，各\b\b查询节点并发执行查询\b语句，并将生成的查询结果汇总\b输出。近期开始真正的使用impala，之前只是\b\b\b小玩过\b已经集成好的\b环境\b，并没有真正的从0到1的去构建Impala集群\b。基于我司\b所有的大数据组件都是采用容器的方式\b部署以便统一\b管理\b，我们需要\b先构建\bImpala镜像\b impala 相关介绍 \bimpala是由cloudera公司\b主导开发的一款\b大数据\b实时查询的分析工具\b\b，区别于Hive底层传统的MapReduce批处理方式，采用MPP\b查询引擎架构\b，相比于Hive 能带来查询性能30-90倍的提升\b 特点 查询速度快: 底层MPP\b查询引擎。\b基于内存计算，\b中间结果不写入磁盘\b，由coordinator\b汇总\b数据结果 灵活性高：\u001f可以\b兼容存储在\b\bHDFS上的原生数据，也可以\b兼容\b优化处理过的压缩数据\b，与Hive共用metastore兼容从Hive上\b导入的所有sql\b语句 可伸缩性：可以很好的和一些BI工具去配合使用，如Microstrategy、Tableau、Qlikview等。 架构 集群角色 impalad(query planner,coordinator, exec engine)： 分布在\bdatanode节点上\b，接受客户端的查询请求 接收查询请求的impalad \b会作为本次查询的coordinator，\b生成查询计划树，并分发给具有相应数据的impalad执行 汇总\b各个impalad上\b执行的查询结果，\b返回给客户端 statestore 跟踪集群中impalad的健康状态及信息位置，\b并把\b健康状况同步到所有的impalad进程节点 catalog 将元数据的变化通知给集群的各个节点，\b减少refresh和invalidate metadata语句使用 镜像构建篇hive镜像构建 因为Impala依赖hive metastore，所以在构建impala镜像之前，先要构建hive镜像 构建过程\b impala 不支持 hive 2.x\b以上的系列，于是选择1.1.0版本，在cloudera官网下载编译好的tar\bball 原本的hive lib 中\b缺少连接metastore的mysql jdbc驱动，自己下载jdbc connector jar\b放入lib目录下即可 由于我hive 用的cdh的版本，而hadoop用的是apache\b的版本\b，导致真正运行hive的时候会找不到mapreduce指定的类，为此lib目录下需加入hadoop-core-2.6.0-mr1-cdh5.9.1.jar \b\b使用自带的schematool \b创建\b元数据表 1./schematool -initSchema -dbType mysql impala镜像构建 impala 我使用的是2.12.0的版本，这个版本\bcloudera官方没有提供\btarball\b文件，只提供的rpm包。考虑到\b自身编译\bimpala 成本比较大，\b于是采用rpm \b\b安装的方法 详细的\b安装\b流程参考链接 Impala安装配置–RPM方式 我这边只记录一下安装过程中遇到的坑 坑一：跟hive一样，由于我使用的hadoop是apache开源版本，有些class对应的包中没有 软链hadoop-core-2.6.0-mr1-cdh5.9.1.jar到impala/lib中 需要对服务的启动文件catalogd, impalad, stastored改动 1234567for JAR_FILE in ${IMPALA_HOME}/lib/*.jar; do export CLASSPATH=&quot;${JAR_FILE}:${CLASSPATH}&quot;done#hadoop share libfor HADOOP_JAR_FILE in $HADOOP_HOME/share/hadoop/tools/lib/*.jar; do export CLASSPATH=&quot;${HADOOP_JAR_FILE}:${CLASSPATH}&quot;done 坑二：软链jdbc driver到impala/lib 并修改catalogd，其他启动文件相应都要修改 坑三：启动catalogd,impala-server时报错 123 E0804 16:42:09.008862 543 MetaStoreUtils.java:1274] Got exception: java.io.IOException No FileSystem for scheme: hdfsJava exception follows: java.io.IOException: No FileSystem for scheme: hdfs core-site.xml中加入\b配置 12345678910&lt;property&gt; &lt;name&gt;fs.file.impl&lt;/name&gt; &lt;value&gt;org.apache.hadoop.fs.LocalFileSystem&lt;/value&gt; &lt;description&gt;The FileSystem for file: uris.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.hdfs.impl&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hdfs.DistributedFileSystem&lt;/value&gt; &lt;description&gt;The FileSystem for hdfs: uris.&lt;/description&gt; &lt;/property&gt; - 坑四 (class org.apache.hdfs.DistributedFileSystem not found)： 12在hadoop2.8.3的版本中org.apache.hadoop.hdfs.DistributedFileSystem can be found in hadoop-hdfs-client jar. 只需要\b将包引入\b\bimpala/lib \b目录下即可 - 坑五：HBase client各种依赖包没有 1234 ln -s $HBASE_HOME/lib/hbase-shaded-miscellaneous-2.1.0.jar hbase-shaded-miscellaneous.jar ln -s $HBASE_HOME/lib/hbase-shaded-protobuf-2.1.0.jar hbase-shaded-protobuf.jar ln -s $HBASE_HOME/lib/commons-lang3-3.6.jar commons-lang3.jar以 - 坑六: \b\b\b\b启动\bimpala-server提示\bsasl plugin\b \b\b\bnot found 12yum install cyrus-sasl* restart impala service impala 集群搭建集群规划 20 个 impalad服务 与datanode混部，以最大化利用分布式本地查询的优势 catalog, statestore 与namenode节点混部以减少namenode网络IO带来的影响 全部服务部署docker化，脚本化，提供200与503脚本以便统一批量操作服务启动终止 200启动脚本是对impala提供的原生的启动命令的封装，包括监听运行进程的存活，便于对集群机器批量操作 200脚本封装代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/env bashEXEC_FILE=/impala/impala-serverPROGRESS=/usr/lib/impala/bin/impaladfunction usage() { echo -e &quot;\\n A tool used for starting impala servicesUsage: 200.sh {statestore|catalog|server}&quot;}check_alive() { PID=`ps -ef | grep $IMPALA_USER_NAME | grep &quot;$PROGRESS&quot; | awk &apos;{print $2}&apos;` [ -n &quot;$PID&quot; ] &amp;&amp; return 0 || return 1}start_service() { if [ ! -f $EXEC_FILE ];then echo &quot;file not exists&quot; exit 1 fi check_alive if [ $? -ne 0 ];then $EXEC_FILE restart sleep 10 check_alive if [ $? -ne 0 ];then echo &quot;service start error&quot; exit 1 else echo &quot;service start success&quot; exit 0 fi else echo &quot;service alreay started&quot; exit 0 fi}function main() { # $SERVICE_POOL是对应的服务池，通过docker run -e 参数传入 [[ -f /data0/hcp/conf/pools/${SERVICE_POOL}/init-env.sh ]] &amp;&amp; source /data0/hcp/conf/pools/${HCP_POOL}/init-env.sh [[ -f /data0/hcp/sbin/impala/init-impala.sh ]] &amp;&amp; source /data0/hcp/sbin/impala/init-impala.sh case &quot;$1&quot; in statestore) echo &quot;starting impala statestore&quot; EXEC_FILE=/data0/hcp/sbin/impala/impala-state-store PROGRESS=/usr/lib/impala/sbin/statestored start_service ;; server) echo &quot;starting impala server&quot; EXEC_FILE=/data0/hcp/sbin/impala/impala-server PROGRESS=/usr/lib/impala/sbin/impalad start_service ;; catalog) echo &quot;starting impala catalog&quot; EXEC_FILE=/data0/hcp/sbin/impala/impala-catalog PROGRESS=/usr/lib/impala/sbin/catalogd start_service ;; *) usage exit 1 esac}main &quot;$@&quot; 503脚本设计思路类似","link":"/2018/08/12/impala集群搭建/"},{"title":"Yarn Federation源码串读","text":"知乎链接 Federation架构总览 Federation: 主要有四个模块，Router ，StateStore，AMRMProxy, Global Policy Generator；从架构上来看，有点类似于后端的微服务架构中服务注册发现模块 Router模块 类似于微服务的网关模块；通过state store获取具体的集群配置策略，将client端submit请求转发到对应的subCluster中 代码结构 hadoop-yarn-server-router：router组件核心实现，分为对接admin用户的协议和client用户协议，以及web server三个子模块实现 hadoop-yarn-server-common-federation-router：包含了Router的各种Policy，具体控制router给子集群分配app的策略 Router- clientrm 负责接收客户端命令请求，并根据对应router具体配置的policy将客户端请求转发到HomeSubcluster上 在每一个router服务上随着启动，用来监听客户端作业提交，实现了Client与RM沟通的RPC协议接口(ApplicationClientProtocol)；作为client的proxy，执行一系列的chain interceptor），通常FederationClientInterceptor需作为最后一个拦截器 当然RouterClientRMService某种程度上针对的是Server测，取代原来RM侧RMClientService；在客户端具体的调用还是在YarnClientImpl；之间通过RPC通信 初始化： 获取配置文件中配置的拦截器，默认是DefaultClientRequestInterceptor DefaultClientRequestInterceptor只是做了简单的请求透明转发；没涉及到多子集群的处理 FederationClientInterceptor：面向client，隐藏了多个sub cluster RM；但是目前只实现了四个接口：getNewApplication, submitApplication, forceKillApplication and getApplicationReport FederationClientInterceptor clientRMProxies: 子集群id与对应的通信client的key value集合 federationFacade: 对应的state store具体实现 policyFacade: 路由策略的工厂 一个任务的提交需经过FederationClientInterceptor.getNewApplication和submitApplication接口，前者获得新的applicationId, 后者通过获得的applicationId将任务提交到具体的sub Cluster RM；这一个阶段没有经过与state store的写操作 getNewApplication实现只是随机的选择一个active sub cluster来获取一个新的applicationId；而subClustersActive是通过具体实现的state store来获取，此处有过滤active的字段 submitApplication，方法注释有讨论各种failover的处理情况； RM没挂的情况：如果state store 更新成功了，则多次提交任务都是幂等的 RM挂了：则router time out之后重试，选择其他的sub cluster Client挂了：跟原来的/ClientRMService/一样 通过policyFacade加载策略，根据context与blacklist为当前提交选择sub cluster；具体逻辑在FederationRouterPolicy.getHomeSubcluster 同步提交任务至目标sub cluster 疑问&amp;&amp;待确定的点 client —&gt; router —&gt; rm： 这条链路如果router挂了如何failover；在submitApplication方法上方有较为详细的边界情况处理解释 是否支持多个router？以及在配置中如何指定多个router？防止一个router挂掉的情况 需要确定是否有机制来维系真正存活的cluster，是否会动态摘除down掉的RM Policy State Store模块FederationStateStoreFacade 作为statestore的封装，抽象出一些重试和缓存的逻辑 FederationStateStore 一般采用ZookeeperFederationStateStore的方式 ZookeeperFederationStateStore 实现中，对应的数据存储结构如下 通过心跳维系了RM是否是active；通过filterInactiveSubClusters来决定是否需要过滤存活的RM 实例化过程 加载配置yarn.federation.state-store.class：默认实现是MemoryFederationStateStore SubClusterResolver 用来判断某个指定的node是属于哪个子集群的工具类;主要有getSubClusterForNode，getSubClustersForRack方法 实例化过程 加载配置yarn.federation.subcluster-resolver.class: 默认实现是DefaultSubClusterResolverImpl 在load方法中，获取了machineList，定义list的地方是在一个文件中通过yarn.federation.machine-list获取文件位置；且文件中的内容格式如下 解析文件之后，将machine依次添加到nodeToSubCluster，rackToSubClusters集合中 AMRMProxy模块 看完client—&gt;rm侧的提交任务模块之后（router），接下来可以分析AM与RM侧的交互模块(AMRMProxy) AMRMProxyService ：如上图所示，起于所有的NM之上的服务，作为AM与RM之间通信的代理；会将AM请求转发到正确的HomeSubCluster FederationInterceptor: 作为AMRMProxyService中的拦截器，主要做AM与RM之间请求转发 AMRMProxyService — FederationInterceptor 类比Router，FederationInterceptor作为AMRMProxy的请求拦截处理 在AM的视角，FederationInterceptor的作用就RM上的ApplicationMasterService；AM通过AMRMClientAsyncImpl或AMRMClientImpl 走RPC协议与AMRMProxyService 交互 registerApplicationMaster详解 按照正常的AM流程分析，由AMLauncher启动container之后须首先会调用registerApplicationMaster方法初始化权限信息以及将自己注册到对应的RM上去；对应到FederationInterceptor是如下方法 制造一种假象：RM永不会挂掉；有可能会因为超时或者RM挂掉等原因而导致发出多个重复注册的请求，此时都会返回最近一次成功的注册结果；所以这也就是为什么registermaster这个方法必须为线程安全的原因 目前只是往HomeSubCluster上注册AM，而不会往其他子集群上注册。是为了不影响扩展性；即不会随着集群的增多AM呈线性扩展；应该是后续按需注册sub-cluster rm this.homeRMRelayer是具体的跟RM通信的代理，其创建方式在FederationInterceptor.init方法中 最后在返回response之前，会根据作业所属的queue信息从statestore中获取对应的策略，并初始化policyInterpreter Allocate详解 周期性的通过心跳与HomeCluster和SubCluster RMs交互；期间可能伴随有SubCluster 上AM的启动和注册 splitAllocateRequest：将原来的request重新构造成面向所有已经注册的sub-cluster rm request 具体到实现：通过requestMap来放置clusterId与allocateRequest的对应关系；通过uamPool获取已经注册UAM的sub clusterId并构建request 后面的步骤是根据所有已经注册的home cluster和sub cluster id构建release, ask, blacklist等请求 对于资源的请求拆分：这里会去调federation policy interpreter将原来request中的askList(Resource Request List)根据策略拆分到各个子集群；所以这里会涉及到Federation Policy调用，具体的分析接下来会单独拎出一小节解释 拿到asks后，会将的对应关系，加入到requestMap中 注意：这里借助findOrCreateAllocateRequestForSubCluster方法实现如果requestMap中不存在asks中对应的subClusterId，会新new一个request塞入map；后续这个request会在对应的subCluster上启动UAM 因为对于新的job，刚开始确实是只在homeCluster上启动了AM sendRequestsToResourceManagers splitAllocateRequest之后就是将构造好的请求发送到对应的cluster上；顺带在所有的subcluster启动UAM并注册上(如果之前没有启动的话)；返回值是所有新注册上的UAM registerWithNewSubClusters 用来在其他子集群中创建新的UAM实例 在uamPool中不存在的被认为是新集群（有点与splitAllocateRequest） 取AllUAMIds逻辑矛盾） 对newSubClusters集合迭代，依次在subClaster上启动UAM，并注册UAM 最后针对不同的cluster，调用不同的clientRPC请求资源 mergeAllocateResponses 用于合并所有资源请求返回的allocateResponse。实现里面是对asyncResponseSink容器的迭代，而asyncResponseSink的写入是在HeartBeatCallback逻辑里的 对于allocateResponse的合并操作在mergeAllocateResponse中 mergeRegistrationResponses 是在注册完其他的sub cluster之后将UAM加入到最终合并的AllocateResponse中；主要是对allocatedContainers以及NMTokens集合做增加 finishApplicationMaster详解 结束任务的时候有点类似allocate，需要向所有的sub cluster发送finish请求；目前是丢到一个compSvc线程池中批量执行*finshApplicationMaster 在线程池中执行sub cluster finish的同时，也会调用home cluster rm进行finish操作 Federation Policy模块 federation policy模块通过FederationPolicyManager的接口实现来统一加载 FederationPolicyInitializationContext：初始化FederationAMRMProxyPolicy和FederationRouterPolicy的上下文类 federationStateStoreFacade: policy state strore的具体实现实例 federationPolicyConfiguration: 具体的策略配置 federationSubclusterResolver：用来判断某个指定的node是属于哪个子集群的工具类 homeSubcluster：当前application实际AM运行的集群ID Policy 具体的实现列举amrmproxy模块的policy实现 LocalityMulticastAMRMProxyPolicy \\1. 如果是有偏好的host的话，会根据SubClusterResolver resolve cluster的结果转发到对应的cluster，但如果没有resolve的话，会默认将请求转向home cluster \\2. 如果有机架的限制，策略同上 \\3. 如果没有host/rack偏好的话，会根据weights转发到对应的集群；weights的计算根据WeightedPolicyInfo以及headroom中的信息 \\4. 所有请求量为0的请求都会转发到所有我们曾经调度过的子集群中（以防用户在尝试取消上一次的请求） 注：该实现始终排除当前未活跃的RM 具体实现细节待深究 router模块的policy实现 总体来说router端的策略偏简单，自己定制也容易 默认实现是UniformRandomRouterPolicy，随机转发client请求到某个alive的cluster 一些问题 在NM侧，不能开启FederationRMFailoverProxyProvider，这个统一在获取RMAddress逻辑上有不足，导致NM启动时拿到的RMAddress是localhost无法通过ResourceTracker连上RM，最终注册失败","link":"/2019/11/05/Yarn-Federation源码串读/"},{"title":"kylin master-slave同步原理及问题排查","text":"背景最近俩个月，团队整个数据基础架构慢慢转移到kylin上面来。而kylin也不负众望，对于一些复杂的聚合查询响应速度远超于hive。随着数据量的上来，kylin的单体部署逐渐无法支撑大量的并行读写任务。于是，自然而然的考虑到kylin的读写分离。一写多读，正好也符合kylin官方文档上的cluster架构。然而在实际的使用中也出现了一些问题: 主节点更新了schema而从节点未sync 从节点中部分sync成功，而不是全部 而很明显的是kylin中所有的数据，包括所有元数据都是落地在HBase中的，那唯一导致节点间数据不一致的可能就只有各个节点都有本地缓存的情况了。为了理解原理方便debug，我对kylin master-slave的同步原理做了一些源代码层面的剖析。 原理剖析主从配置方式关于配置的格式，不得不吐槽官方文档的滑水。并没有给出详细的节点配置格式，查阅相关源码才发现正确的配置格式： 12//kylin.properties下面的配置，根据源码，配置的格式为：user:pwd@host:portkylin.server.cluster-servers=user:password@host:port,user:password@host:port,user:password@host:port 流程解析 源码解析 先来看看整个同步机制的核心BroadCaster类的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Broadcaster的构造函数private Broadcaster(final KylinConfig config) { this.config = config; //获取kylin.properties中&quot;kylin.server.cluster-servers&quot;配置的值 //也就是集群中所有节点的配置了 final String[] nodes = config.getRestServers(); if (nodes == null || nodes.length &lt; 1) { logger.warn(&quot;There is no available rest server; check the &apos;kylin.server.cluster-servers&apos; config&quot;); broadcastEvents = null; // disable the broadcaster return; } logger.debug(nodes.length + &quot; nodes in the cluster: &quot; + Arrays.toString(nodes)); //开一个单线程，不间断的循环从broadcastEvents队列里面获取注册的事件。 Executors.newSingleThreadExecutor(new DaemonThreadFactory()).execute(new Runnable() { @Override public void run() { final List&lt;RestClient&gt; restClients = Lists.newArrayList(); for (String node : config.getRestServers()) { //根据配置的节点信息注册RestClient restClients.add(new RestClient(node)); } final ExecutorService wipingCachePool = Executors.newFixedThreadPool(restClients.size(), new DaemonThreadFactory()); while (true) { try { final BroadcastEvent broadcastEvent = broadcastEvents.takeFirst(); logger.info(&quot;Announcing new broadcast event: &quot; + broadcastEvent); for (final RestClient restClient : restClients) { wipingCachePool.execute(new Runnable() { @Override public void run() { try { restClient.wipeCache(broadcastEvent.getEntity(), broadcastEvent.getEvent(), broadcastEvent.getCacheKey()); } catch (IOException e) { logger.warn(&quot;Thread failed during wipe cache at &quot; + broadcastEvent, e); } } }); } } catch (Exception e) { logger.error(&quot;error running wiping&quot;, e); } } } }); } 通过Broadcaster的构造函数其实就能清楚整个同步过程的大概逻辑了。无非就是启动一个线程去轮询阻塞队列里面的元素，有的话就消费下来广播到其他从节点从而达到清理缓存的目的。 再来看看广播的实际逻辑实现,基本封装在RestClient中 123456789101112131415//此处是根据配置的节点信息正则匹配：&quot;user:pwd@host:port&quot;public RestClient(String uri) { Matcher m = fullRestPattern.matcher(uri); if (!m.matches()) throw new IllegalArgumentException(&quot;URI: &quot; + uri + &quot; -- does not match pattern &quot; + fullRestPattern); String user = m.group(1); String pwd = m.group(2); String host = m.group(3); String portStr = m.group(4); int port = Integer.parseInt(portStr == null ? &quot;7070&quot; : portStr); init(host, port, user, pwd); } 根据配置的节点信息实例化RestClient，然后在init方法中，拼接wipe cache的url 1234567891011121314151617private void init(String host, int port, String userName, String password) { this.host = host; this.port = port; this.userName = userName; this.password = password; //拼接rest接口 this.baseUrl = &quot;http://&quot; + host + &quot;:&quot; + port + &quot;/kylin/api&quot;; client = new DefaultHttpClient(); if (userName != null &amp;&amp; password != null) { CredentialsProvider provider = new BasicCredentialsProvider(); UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(userName, password); provider.setCredentials(AuthScope.ANY, credentials); client.setCredentialsProvider(provider); }} 发现kylin所有的交互接口基本上底层都是调用的自己的rest接口，它自己所谓的jdbc的查询方式其实也只是在rest接口上封装了一层，底层还是http请求。可谓是挂羊头卖狗肉了。看看RestClient中怎么去通知其他节点wipe cache的 12345678910111213141516public void wipeCache(String entity, String event, String cacheKey) throws IOException { String url = baseUrl + &quot;/cache/&quot; + entity + &quot;/&quot; + cacheKey + &quot;/&quot; + event; HttpPut request = new HttpPut(url); try { HttpResponse response = client.execute(request); String msg = EntityUtils.toString(response.getEntity()); if (response.getStatusLine().getStatusCode() != 200) throw new IOException(&quot;Invalid response &quot; + response.getStatusLine().getStatusCode() + &quot; with cache wipe url &quot; + url + &quot;\\n&quot; + msg); } catch (Exception ex) { throw new IOException(ex); } finally { request.releaseConnection(); } } 已经很明了了，就是调的rest接口：/kylin/api/cache/{entity}/{cacaheKey}/{event} 当slave节点接收到wipeCache的指令时的处理逻辑如下： 12345678910111213141516171819202122232425262728public void notifyMetadataChange(String entity, Event event, String cacheKey) throws IOException { Broadcaster broadcaster = Broadcaster.getInstance(getConfig()); //这里会判断当前节点是否注册为listener了，如果注册了，此逻辑会被ignored broadcaster.registerListener(cacheSyncListener, &quot;cube&quot;); broadcaster.notifyListener(entity, event, cacheKey); } //注册listener的逻辑 public void registerListener(Listener listener, String... entities) { synchronized (CACHE) { // ignore re-registration List&lt;Listener&gt; all = listenerMap.get(SYNC_ALL); if (all != null &amp;&amp; all.contains(listener)) { return; } for (String entity : entities) { if (!StringUtils.isBlank(entity)) addListener(entity, listener); } //注册几种事件类型 addListener(SYNC_ALL, listener); addListener(SYNC_PRJ_SCHEMA, listener); addListener(SYNC_PRJ_DATA, listener); }} notifyListener主要就是对所有事件处理逻辑的划分，根据事件类型选择处理逻辑，一般sheme的更新走的是默认逻辑 12345678910111213141516171819202122232425262728293031323334353637383940public void notifyListener(String entity, Event event, String cacheKey) throws IOException { synchronized (CACHE) { List&lt;Listener&gt; list = listenerMap.get(entity); if (list == null) return; logger.debug(&quot;Broadcasting metadata change: entity=&quot; + entity + &quot;, event=&quot; + event + &quot;, cacheKey=&quot; + cacheKey + &quot;, listeners=&quot; + list); // prevents concurrent modification exception list = Lists.newArrayList(list); switch (entity) { case SYNC_ALL: for (Listener l : list) { l.onClearAll(this); } clearCache(); // clear broadcaster too in the end break; case SYNC_PRJ_SCHEMA: ProjectManager.getInstance(config).clearL2Cache(); for (Listener l : list) { l.onProjectSchemaChange(this, cacheKey); } break; case SYNC_PRJ_DATA: ProjectManager.getInstance(config).clearL2Cache(); // cube&apos;s first becoming ready leads to schema change too for (Listener l : list) { l.onProjectDataChange(this, cacheKey); } break; //大部分的走向 default: for (Listener l : list) { l.onEntityChange(this, entity, event, cacheKey); } break; } logger.debug(&quot;Done broadcasting metadata change: entity=&quot; + entity + &quot;, event=&quot; + event + &quot;, cacheKey=&quot; + cacheKey); } } 看到default分支会执行onEntityChange这个方法，看一下这个方法干的是什么 123456789101112131415161718192021222324252627282930313233343536private Broadcaster.Listener cacheSyncListener = new Broadcaster.Listener() { @Override public void onClearAll(Broadcaster broadcaster) throws IOException { removeAllOLAPDataSources(); cleanAllDataCache(); } @Override public void onProjectSchemaChange(Broadcaster broadcaster, String project) throws IOException { removeOLAPDataSource(project); cleanDataCache(project); } @Override public void onProjectDataChange(Broadcaster broadcaster, String project) throws IOException { removeOLAPDataSource(project); // data availability (cube enabled/disabled) affects exposed schema to SQL cleanDataCache(project); } @Override public void onEntityChange(Broadcaster broadcaster, String entity, Event event, String cacheKey) throws IOException { if (&quot;cube&quot;.equals(entity) &amp;&amp; event == Event.UPDATE) { final String cubeName = cacheKey; new Thread() { // do not block the event broadcast thread public void run() { try { Thread.sleep(1000); cubeService.updateOnNewSegmentReady(cubeName); } catch (Throwable ex) { logger.error(&quot;Error in updateOnNewSegmentReady()&quot;, ex); } } }.start(); } } }; 看到对于cache的同步是单独实现了一个listener的，Event为update的时候，会单独启动一个线程去执行刷新缓存操作 加入简单的重试逻辑由于目前对于同步失败的猜想是目标服务短暂不可用（响应超时或者处于失败重启阶段），于是我只是单纯的将失败的任务重新塞入broadcastEvents队列尾部供再一次调用。当然这种操作过于草率和暴力，却也是验证猜想最简单快速的方式。 1234567891011121314151617181920212223242526for (final RestClient restClient : restClients) { wipingCachePool.execute(new Runnable() { @Override public void run() { try { restClient.wipeCache(broadcastEvent.getEntity(), broadcastEvent.getEvent(), broadcastEvent.getCacheKey()); } catch (IOException e) { logger .warn(&quot;Thread failed during wipe cache at {}, error msg: {}&quot;, broadcastEvent, e.getMessage()); try { //这里重新塞入队列尾部，等待重新执行 broadcastEvents.putLast(broadcastEvent); logger.info(&quot;put failed broadcastEvent to queue. broacastEvent: {}&quot;, broadcastEvent); } catch (InterruptedException ex) { logger.warn(&quot;error reentry failed broadcastEvent to queue, broacastEvent:{}, error: {} &quot;, broadcastEvent, ex); } } } }); } } 编译部署之后，日志中出现了如下错误： 1Thread failed during wipe cache at java.lang.IllegalStateException: Invalid use of BasicClientConnManager: connection still allocated. 比较意外，不过也终于发现了问题的所在。Kylin在启动的时候会按照配置的nodes实例化一次RestClient，之后就直接从缓存中拿了，而kylin用的DefaultHttpClient每次只允许一次请求，请求完必须释放链接，否则无法复用HttpClient。所以需要修改wipeCache方法的逻辑如下: 123456789101112131415161718192021public void wipeCache(String entity, String event, String cacheKey) throws IOException { String url = baseUrl + &quot;/cache/&quot; + entity + &quot;/&quot; + cacheKey + &quot;/&quot; + event; HttpPut request = new HttpPut(url); HttpResponse response =null; try { response = client.execute(request); String msg = EntityUtils.toString(response.getEntity()); if (response.getStatusLine().getStatusCode() != 200) throw new IOException(&quot;Invalid response &quot; + response.getStatusLine().getStatusCode() + &quot; with cache wipe url &quot; + url + &quot;\\n&quot; + msg); } catch (Exception ex) { throw new IOException(ex); } finally { //确保释放连接 if(response!=null) { EntityUtils.consume(response.getEntity()); } request.releaseConnection(); }}","link":"/2017/07/06/kylin-master-slave同步原理及问题排查/"},{"title":"kylin query原理剖析","text":"前言最近我们组负责数据建模的同学抱怨kylin的relization选择策略：同一个project下一条查询语句本来期望命中某一个cube的，结果系统却选择了其他cube。之前也有大概翻阅过kylin这块的实现源码，知道如果同一个project下如果有多个满足条件的的实现，会按照成本排序并选择成本最低的那个实现。对于成本这块的度量标准，没有做过多研究，于是带着问题，对这块源码进行了一次梳理。 源码剖析为使博文简洁相关实现只贴部分核心代码，以下所指的Realization对应于构建好的Cube。 查询入口 QueryService.doQueryWithCache() 123456789101112131415161718192021 //kylin.query.cache-enabled是否开启，如果开启将会从cache里面去读结果 if (queryCacheEnabled) { sqlResponse = searchQueryInCache(sqlRequest); } try {if (null == sqlResponse) { if (isSelect) { //查询入口 sqlResponse = query(sqlRequest); } else if (kylinConfig.isPushDownEnabled() &amp;&amp; kylinConfig.isPushDownUpdateEnabled()) { //如果开启了pushDown的话允许非查询的sql，如update sqlResponse = update(sqlRequest); } else { logger.debug(&quot;Directly return exception as the sql is unsupported, and query pushdown is disabled&quot;); throw new BadRequestException(msg.getNOT_SUPPORTED_SQL()); } ... catch(){ ... } 这里，我们忽略从缓存中查找（searchQueryInCache），以及非select查询的情况，单单从一次正常的查询进行分析，进入query方法。 QueryService.query() query方法相对来说比较简单，记录了query开始和结束的信息，相当于做了一个切面的工作 1234567891011121314public SQLResponse query(SQLRequest sqlRequest) throws Exception { SQLResponse ret = null; try { final String user = SecurityContextHolder.getContext().getAuthentication().getName(); badQueryDetector.queryStart(Thread.currentThread(), sqlRequest, user); ret = queryWithSqlMassage(sqlRequest); return ret; } finally { String badReason = (ret != null &amp;&amp; ret.isPushDown()) ? BadQueryEntry.ADJ_PUSHDOWN : null; badQueryDetector.queryEnd(Thread.currentThread(), badReason); }} 其中badQueryDetector是一个单起的线程，用来统计和监测bad query的。当有bad query时notify相关的观察者，做一些操作，如打印日志，记录bad query等。kylin 中很多事件的通知都是通过生产者消费者模式订阅发布的。继续进入queryWithSqlMessage() QueryService.queryWithSqlMessage() 12345678910Connection conn = null;try { conn = QueryConnection.getConnection(sqlRequest.getProject()); ... return execute(correctedSql, sqlRequest, conn); ... } finally { DBUtils.closeQuietly(conn); } 这个方法里首先获取了数据库连接，kylin的查询的中间层是基于Calcite的，接下来会看一下QueryConnection背后的逻辑。不过话说回来kylin这种整个大块的try catch异常捕获的机制某种意义上来说是种不负责任的表现。 QueryConnection.getConnection(): 12345678910public static Connection getConnection(String project) throws SQLException { if (!isRegister) { DriverManager.registerDriver(new Driver()); isRegister = true; } File olapTmp = OLAPSchemaFactory.createTempOLAPJson(project, KylinConfig.getInstanceFromEnv()); Properties info = new Properties(); info.put(&quot;model&quot;, olapTmp.getAbsolutePath()); return DriverManager.getConnection(&quot;jdbc:calcite:&quot;, info);} 方法比较简单，主要是通过OLAPSchemaFactory.createTempOLAPJson()生成了连接的元数据文件，用来创建连接 OLAPSchemaFactory OLAPSchemaFactory 实现了calcite的 SchemaFactory接口，实现了create方法，用来创建连接时生成Schema 123456@Overridepublic Schema create(SchemaPlus parentSchema, String schemaName, Map&lt;String, Object&gt; operand) { String project = (String) operand.get(SCHEMA_PROJECT); Schema newSchema = new OLAPSchema(project, schemaName, false); return newSchema;} 在OLAPSchema的init方法中调用了KylinConfigBase.getStorageUrl方法，此方法返回了我们在配置文件中配置的kylin数据的存储信息 12345678910public StorageURL getStorageUrl() { String url = getOptional(&quot;kylin.storage.url&quot;, &quot;default@hbase&quot;); // for backward compatibility // 对2.0早期版本的配置做了兼容 if (&quot;hbase&quot;.equals(url)) url = &quot;default@hbase&quot;; return StorageURL.valueOf(url);} 这里也可以看出kylin默认的存储系统是HBase QueryService.execute() 从之前的QueryService.queryWithSqlMessage()方法继续往下深入到 execute()方法 1234567891011121314ResultSet resultSet = null;if (isPrepareStatementWithParams(sqlRequest)) { stat = conn.prepareStatement(correctedSql); // to be closed in the finally PreparedStatement prepared = (PreparedStatement) stat; processStatementAttr(prepared, sqlRequest); for (int i = 0; i &lt; ((PrepareSqlRequest) sqlRequest).getParams().length; i++) { setParam(prepared, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]); } resultSet = prepared.executeQuery();} else { stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql);} OLAPTable 最后查出的结果是在resultSet里，追踪到这一步发现再往下追踪都是Calcite底层的逻辑了，kylin肯定是对Calcite 做了一定的扩展，并且将结果按照kylin预定义的规则做了各种聚合操作。Calcite文档中表示，可以实现三种类型的Table: a simple implementation of Table, using the ScannableTable interface, that enumerates all rows directly; a more advanced implementation that implements FilterableTable, and can filter out rows according to simple predicates; advanced implementation of Table, using TranslatableTable, that translates to relational operators using planner rules. 发现在core-query模块中OLAPTable 实现了TranslatableTable。而OLAPTable 中实现的asQueryable方法有三种Enumerator的实现，这里默认选的是OLAP的实现。 1234567891011121314151617181920212223242526public &lt;T&gt; Queryable&lt;T&gt; asQueryable(QueryProvider queryProvider, SchemaPlus schema, String tableName) { return new AbstractTableQueryable&lt;T&gt;(queryProvider, schema, this, tableName) { @SuppressWarnings(&quot;unchecked&quot;) public Enumerator&lt;T&gt; enumerator() { final OLAPQuery query = new OLAPQuery(EnumeratorTypeEnum.OLAP, 0); return (Enumerator&lt;T&gt;) query.enumerator(); } }; } OLAPQuery.enumeratorpublic Enumerator&lt;Object[]&gt; enumerator() { OLAPContext olapContext = OLAPContext.getThreadLocalContextById(contextId); switch (type) { case OLAP: return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new OLAPEnumerator(olapContext, optiqContext); case LOOKUP_TABLE: return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new LookupTableEnumerator(olapContext); case HIVE: return BackdoorToggles.getPrepareOnly() ? new EmptyEnumerator() : new HiveEnumerator(olapContext); default: throw new IllegalArgumentException(&quot;Wrong type &quot; + type + &quot;!&quot;); }} OLAPEnumerator.queryStorage() 由OLAPTable.asQueryable进入，到了OLAPEnumerator.queryStorage()，终于能看到真实的查库操作了。 123456789101112131415161718private ITupleIterator queryStorage() { logger.debug(&quot;query storage...&quot;); // bind dynamic variables bindVariable(olapContext.filter); olapContext.resetSQLDigest(); SQLDigest sqlDigest = olapContext.getSQLDigest(); // query storage engine IStorageQuery storageEngine = StorageFactory.createQuery(olapContext.realization); ITupleIterator iterator = storageEngine.search(olapContext.storageContext, sqlDigest, olapContext.returnTupleInfo); if (logger.isDebugEnabled()) { logger.debug(&quot;return TupleIterator...&quot;); } return iterator;} 这里StorageEngine 由StorageFactory创建，且有三种不同的实现，默认还是HBase 123456789101112131415161718192021 private static ThreadLocal&lt;ImplementationSwitch&lt;IStorage&gt;&gt; storages = new ThreadLocal&lt;&gt;(); public static IStorage storage(IStorageAware aware) { ImplementationSwitch&lt;IStorage&gt; current = storages.get(); if (storages.get() == null) { current = new ImplementationSwitch&lt;&gt;(KylinConfig.getInstanceFromEnv().getStorageEngines(), IStorage.class); storages.set(current); } return current.get(aware.getStorageType()); } //KylinConfig.getInstanceFromEnv().getStorageEngines()public Map&lt;Integer, String&gt; getStorageEngines() { Map&lt;Integer, String&gt; r = Maps.newLinkedHashMap(); // ref constants in IStorageAware r.put(0, &quot;org.apache.kylin.storage.hbase.HBaseStorage&quot;); r.put(1, &quot;org.apache.kylin.storage.hybrid.HybridStorage&quot;); r.put(2, &quot;org.apache.kylin.storage.hbase.HBaseStorage&quot;); r.putAll(convertKeyToInteger(getPropertiesByPrefix(&quot;kylin.storage.provider.&quot;))); return r; } OLAPTableScan.register() 由于OLAPTable实现了TranslatableTable，它会通过一系列的relation operators将结果聚合,relation operators的注册逻辑在OLAPTableScan中。 1234567891011121314151617@Override public void register(RelOptPlanner planner) { // force clear the query context before traversal relational operators OLAPContext.clearThreadLocalContexts(); // register OLAP rules planner.addRule(OLAPToEnumerableConverterRule.INSTANCE); planner.addRule(OLAPFilterRule.INSTANCE); planner.addRule(OLAPProjectRule.INSTANCE); planner.addRule(OLAPAggregateRule.INSTANCE); planner.addRule(OLAPJoinRule.INSTANCE); planner.addRule(OLAPLimitRule.INSTANCE); planner.addRule(OLAPSortRule.INSTANCE); planner.addRule(OLAPUnionRule.INSTANCE); planner.addRule(OLAPWindowRule.INSTANCE); ... } 这里着重看OLAPToEnumerableConverterRule 里返回的 OLAPToEnumerableConverter的实现，它是解释我在前言里提到的问题的关键。 OLAPToEnumerableConverter.implement() 这里面有对所有满足query条件的realization选择的实现 12345678910111213141516171819public Result implement(EnumerableRelImplementor enumImplementor, Prefer pref) { ... // identify model &amp; realization List&lt;OLAPContext&gt; contexts = listContextsHavingScan(); // intercept query List&lt;QueryInterceptor&gt; intercepts = QueryInterceptorUtil.getQueryInterceptors(); for (QueryInterceptor intercept : intercepts) { intercept.intercept(contexts); }//RealizationChooser 中有对Realization选择的具体实现 RealizationChooser.selectRealization(contexts); ...return impl.visitChild(this, 0, inputAsEnum, pref); } RealizationChooser.attemptSelectRealization() attemptSelectRealization方法里面主要干了两件事： 1）拉取属于该project与factTableName下的所有Realization，经过一系列的条件过滤掉不符合query的Realization，并将符合条件的Realization按照RealizationCost排序。2）对第一步收集的Realization map，调用QueryRouter.selectRealization()，一旦QueryRouter.selectRealization()有返回值立即中断循环返回最终选择的Realization RealizationChooser.makeOrderedModelMap() 部分的实现逻辑如下： 12345678910111213141516171819202122232425262728293031323334353637 //按条件过滤realization for (IRealization real : realizations) { //过滤disabled cube if (real.isReady() == false) { context.realizationCheck.addIncapableCube(real, RealizationCheck.IncapableReason.create(RealizationCheck.IncapableType.CUBE_NOT_READY)); continue; } //过滤不包含querycontext里面全部的columns if (containsAll(real.getAllColumnDescs(), first.allColumns) == false) { context.realizationCheck.addIncapableCube(real, RealizationCheck.IncapableReason .notContainAllColumn(notContain(real.getAllColumnDescs(), first.allColumns))); continue; } ／／过滤存在黑名单里面的cube if (RemoveBlackoutRealizationsRule.accept(real) == false) { context.realizationCheck.addIncapableCube(real, RealizationCheck.IncapableReason .create(RealizationCheck.IncapableType.CUBE_BLACK_OUT_REALIZATION)); continue; }//过滤完，按RealizationCost排序 RealizationCost cost = new RealizationCost(real); DataModelDesc m = real.getModel(); Set&lt;IRealization&gt; set = models.get(m); if (set == null) { set = Sets.newHashSet(); set.add(real); models.put(m, set); costs.put(m, cost); } else { set.add(real); RealizationCost curCost = costs.get(m); if (cost.compareTo(curCost) &lt; 0) costs.put(m, cost); } } 重点就在RealizationCost的实现里了 12345678910111213public RealizationCost(IRealization real) { // ref Candidate.PRIORITIES this.priority = Candidate.PRIORITIES.get(real.getType()); // ref CubeInstance.getCost() int c = real.getAllDimensions().size() * CubeInstance.COST_WEIGHT_DIMENSION + real.getMeasures().size() * CubeInstance.COST_WEIGHT_MEASURE; for (JoinTableDesc join : real.getModel().getJoinTables()) { if (join.getJoin().isInnerJoin()) c += CubeInstance.COST_WEIGHT_INNER_JOIN; } this.cost = c; } 到此，对于kylin的Realization的成本计算规则清楚了。就是对dimension，measure,jointable三个维度的数量进行加权求和，得到的就是每个Realization对应的成本。相对的，每个维度对应的权重是有所斟酌的，dimension对应的是10，measure为1（考虑到是预计算的结果），jointable为100。从这也能看出建模时应该考虑的优化方向：避免过多的dimension，以及jointable的操作，结果尽量从预计算中出。 总结这次经过对kylin query源码的分析，基本上对kylin的核心代码都过了一遍，学习了不少优秀的代码解耦方式，也对底层原理加深了理解。关于RealizationCost的实现，目前kylin实现比较简单，在遍历所有满足条件的实现时找到Realization便返回处理的有些过于仓促。对于其是map的结构或许kylin在之后的扩展方面也是有所考虑。目前我们还不打算扩展Realizaiton的选择策略，了解了源码就可以在建模层面将查询结果不如意的情况给规避了。","link":"/2017/10/31/kylin-query原理剖析/"},{"title":"airflow实战总结","text":"介绍\bairflow是一款开源的，分布式任务调度框架，它将一个具有上下级依赖关系的工作流，组装成一个有向无环图。 特点: 分布式任务调度：允许一个工作流的task在多台worker上同时执行 可构建任务依赖：以有向无环图的方式构建任务依赖关系 task原子性：工作流上每个task都是原子可重试的，一个工作流某个环节的task失败可自动或手动进行重试，不必从头开始任务 工作流示意图 一个dag\b表示一个定时的工作流\b，\b包含一个或者多个具有依赖关系的task task依赖图 架构图及集群角色 webserver\b : 提供web端服务\b，以及会定时生成\b子进程去扫描对应的目录下的dags，\b并更新数据库\b scheduler : 任务调度\b服务，\b根据dags生成任务，并提交到消息中间件队列中 (redis或rabbitMq) celery worker : \b分布在不同的机器上，作为任务真正的的执行节点。通过监听\b消息中间件: redis或rabbitMq 领取任务\b flower : 监控worker进程的存活性，启动或关闭worker进程，查看运行的task 实战 构建docker镜像 采用的airflow是未发行的1.10.0版本，原因是从1.10.0开始，支持时区的设置，而不是统一的UTC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//self.registry.domain 为docker私有镜像仓库//self.mvn.registry.com maven 私有镜像仓库//data0 为数据目录，data1为日志目录，运维统一配置日志清楚策略#docker build --network host -t self.registry.domain/airflow_base_1.10.7:1.0.0 .FROM self.registry.domain/airflow/centos_base_7.4.1708:1.0.0LABEL AIRFLOW=1.10.7ARG CELERY_REDIS=4.1.1ARG DOCKER_VERSION=1.13.1ARG AIRFLOW_VERSION=1.10.7ADD sbin /data0/airflow/sbinENV SLUGIFY_USES_TEXT_UNIDECODE=yes \\ #如果构建镜像的机器需要代理才能连接外网的话，配置https_proxy https_proxy=https://ip:port RUN curl http://self.mvn.registry.com/python/python-3.5.6.jar -o /tmp/Python-3.5.6.tgz &amp;&amp; \\ curl http://self.mvn.registry.com/airflow/${AIRFLOW_VERSION}/airflow-${AIRFLOW_VERSION}.jar -o /tmp/incubator-airflow-${AIRFLOW_VERSION}.tar.gz &amp;&amp; \\ curl http:/self.mvn.registry.com/docker/${DOCKER_VERSION}/docker-${DOCKER_VERSION}.jar -o /tmp/docker-${DOCKER_VERSION}.tar.gz &amp;&amp; \\ tar zxf /tmp/docker-${DOCKER_VERSION}.tar.gz -C /data0/software &amp;&amp; \\ tar zxf /tmp/Python-3.5.6.tgz -C /data0/software &amp;&amp; \\ tar zxf /tmp/incubator-airflow-${AIRFLOW_VERSION}.tar.gz -C /data0/software &amp;&amp; \\ yum install -y libtool-ltdl policycoreutils-python &amp;&amp; \\ rpm -ivh --force --nodeps /data0/software/docker-${DOCKER_VERSION}/docker-engine-selinux-${DOCKER_VERSION}-1.el7.centos.noarch.rpm &amp;&amp; \\ rpm -ivh --force --nodeps /data0/software/docker-${DOCKER_VERSION}/docker-engine-${DOCKER_VERSION}-1.el7.centos.x86_64.rpm &amp;&amp; \\ yum -y install gcc &amp;&amp; yum -y install gcc-c++ &amp;&amp; yum -y install make &amp;&amp; \\ yum -y install zlib-devel mysql-devel python-devel cyrus-sasl-devel cyrus-sasl-lib libxml2-devel libxslt-devel &amp;&amp; \\ cd /data0/software/Python-3.5.6 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install &amp;&amp; \\ ln -sf /usr/local/bin/pip3 /usr/local/bin/pip &amp;&amp; \\ ln -sf /usr/local/bin/python3 /usr/local/bin/python &amp;&amp; \\ cd /data0/software/incubator-airflow-${AIRFLOW_VERSION} &amp;&amp; python setup.py install &amp;&amp; \\ pip install -i https://pypi.douban.com/simple/ apache-airflow[crypto,celery,hive,jdbc,mysql,hdfs,password,redis,devel_hadoop] &amp;&amp; \\ pip install -i https://pypi.douban.com/simple/ celery[redis]==$CELERY_REDIS &amp;&amp; \\ pip install -i https://pypi.douban.com/simple/ docutils &amp;&amp; \\ ln -sf /usr/local/lib/python3.5/site-packages/apache_airflow-1.10.0-py3.5.egg/airflow /data0/software/airflow &amp;&amp; \\ mkdir -p /data0/airflow/bin &amp;&amp; \\ ln -sf /data0/airflow/sbin/airflow-200.sh /data0/airflow/bin/200.sh &amp;&amp; \\ ln -sf /data0/airflow/sbin/airflow-503.sh /data0/airflow/bin/503.sh &amp;&amp; \\ chown -R root:root /data0/software/ &amp;&amp; \\ chown -R root:root /data0/airflow/ &amp;&amp; \\ chmod -R 775 /data0/airflow/sbin/* &amp;&amp; \\ chmod -R 775 /data0/airflow/bin/* &amp;&amp; \\ echo &apos;source /data0/airflow/sbin/init-airflow.sh&apos; &gt;&gt; ~/.bashrc &amp;&amp; \\ rm -rf /tmp/* /data0/software/Python-3.5.6 /data0/software/incubator-airflow-${AIRFLOW_VERSION} /data0/software/docker-${DOCKER_VERSION} ENV PATH=$PATH:/data0/software/jdk/bin:/data0/software/airflow/bin:/data0/airflow/sbin/:/data0/airflow/sbin/airflow/:/data0/airflow/bin/WORKDIR /data0/airflow/bin/ 通过docker 启动容器的话需要暴露几个端口 12345webserver: 8081worker: 8793flower: 5555//启动示例docker run --name airflow -it -d --privileged --net=host -p 8081:8081 -p 5555:5555 -p 8793:8793 -v /var/run/docker.sock:/var/run/docker.sock -v /data1:/data1 -v /data0/airflow:/data0/airflow self.registry.domain/airflow_1.10.7:1.0.0 airflow 升级到未release的1.10.0的版本 12345678//如果之前用的是低版本的话，需要执行airflow upgradedb 来更新迁移数据库的schema//执行之前首先需要set mysql propertyset global explicit_defaults_for_timestamp=1 //会提示is readonly variable需要在my.cnf中添加这个设置:explicit_defaults_for_timestamp=1 并重启mysql//update celery几个设置celeryd_concurrency -&gt; worker_concurrencycelery_result_backend -&gt; result_backend 修改时区，以及界面上执行时间的显示(airlfow 默认界面上还是按照UTC显示) 123456789101112//需要update configurationdefault_timezone = Etc/GMT-8//修改dags.html中的显示时间，使得界面上看起来方便// jinjia2 传入转换函数，在views.py 的homeview的render中 //（方法验证有点问题，再优化）def utc2local(utc): epoch = time.mktime(utc.timetuple()) offset = datetime.fromtimestamp(epoch) - datetime.utcfromtimestamp(epoch) return utc + offsetutc2local(last_run.execution_date).strftime(&quot;%Y-%m-%d %H:%M&quot;)utc2local(last_run.start_date).strftime(&quot;%Y-%m-%d %H:%M&quot;)` airflow plugins 定制化开发 官方文档 plugin 这个没法传给worker，还是得重新分发到各个worker节点，建议打入airflow基础镜像中 增加operator时需要重启webserver和scheduler 由于dag的删除现在官方没有暴露直接的api,而完整的删除又牵扯到多个表，总结出删除dag的sql如下 12345678set @dag_id = &apos;BAD_DAG&apos;;delete from airflow.xcom where dag_id = @dag_id;delete from airflow.task_instance where dag_id = @dag_id;delete from airflow.sla_miss where dag_id = @dag_id;delete from airflow.log where dag_id = @dag_id;delete from airflow.job where dag_id = @dag_id;delete from airflow.dag_run where dag_id = @dag_id;delete from airflow.dag where dag_id = @dag_id; 自己实现的200和503脚本，用于集群统一的上下线操作 200脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!/usr/bin/env bashfunction usage() { echo -e &quot;\\n A tool used for starting airflow servicesUsage: 200.sh {webserver|worker|scheduler|flower}&quot;}PORT=8081ROLE=webserverENV_ARGS=&quot;&quot;check_alive() { PID=`netstat -nlpt | grep $PORT | awk &apos;{print $7}&apos; | awk -F &quot;/&quot; &apos;{print $1}&apos;` [ -n &quot;$PID&quot; ] &amp;&amp; return 0 || return 1}check_scheduler_alive() { PIDS=`ps -ef | grep &quot;/usr/local/bin/airflow scheduler&quot; | grep &quot;python&quot; | awk &apos;{print $2}&apos;` [ -n &quot;$PIDS&quot; ] &amp;&amp; return 0 || return 1}function get_host_ip(){ local host=$(ifconfig | grep &quot;inet &quot; | grep &quot;\\-\\-&gt;&quot; | awk &apos;{print $2}&apos; | tail -1) if [[ -z &quot;$host&quot; ]]; then host=$(ifconfig | grep &quot;inet &quot; | grep &quot;broadcast&quot; | awk &apos;{print $2}&apos; | tail -1) fi echo &quot;${host}&quot;}start_service() { if [ $ROLE = &apos;scheduler&apos; ];then check_scheduler_alive else check_alive fi if [ $? -ne 0 ];then nohup airflow $ROLE $ENV_ARGS &gt; $BASE_LOG_DIR/$ROLE/$ROLE.log 2&gt;&amp;1 &amp; sleep 5 if [ $ROLE = &apos;scheduler&apos; ];then check_scheduler_alive else check_alive fi if [ $? -ne 0 ];then echo &quot;service start error&quot; exit 1 else echo &quot;service start success&quot; exit 0 fi else echo &quot;service alreay started&quot; exit 0 fi}function main() { if [ -z &quot;${POOL}&quot; ]; then echo &quot;the environment variable POOL cannot be empty&quot; exit 1 fi source /data0/hcp/sbin/init-hcp.sh case &quot;$1&quot; in webserver) echo &quot;starting airflow webserver&quot; ROLE=webserver PORT=8081 start_service ;; worker) echo &quot;starting airflow worker&quot; ROLE=worker PORT=8793 local host_ip=$(get_host_ip) ENV_ARGS=&quot;-cn ${host_ip}@${host_ip}&quot; start_service ;; flower) echo &quot;starting airflow flower&quot; ROLE=flower PORT=5555 start_service ;; scheduler) echo &quot;starting airflow scheduler&quot; ROLE=scheduler start_service ;; *) usage exit 1 esac}main &quot;$@&quot; 503脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env bashfunction usage() { echo -e &quot;\\n A tool used for stop airflow servicesUsage: 200.sh {webserver|worker|scheduler|flower}&quot;}function get_host_ip(){ local host=$(ifconfig | grep &quot;inet &quot; | grep &quot;\\-\\-&gt;&quot; | awk &apos;{print $2}&apos; | tail -1) if [[ -z &quot;$host&quot; ]]; then host=$(ifconfig | grep &quot;inet &quot; | grep &quot;broadcast&quot; | awk &apos;{print $2}&apos; | tail -1) fi echo &quot;${host}&quot;}function main() { if [ -z &quot;${POOL}&quot; ]; then echo &quot;the environment variable POOL cannot be empty&quot; exit 1 fi source /data0/hcp/sbin/init-hcp.sh case &quot;$1&quot; in webserver) echo &quot;stopping airflow webserver&quot; cat $AIRFLOW_HOME/airflow-webserver.pid | xargs kill -9 ;; worker) echo &quot;stopping airflow worker&quot; PORT=8793 PID=`netstat -nlpt | grep $PORT | awk &apos;{print $7}&apos; | awk -F &quot;/&quot; &apos;{print $1}&apos;` kill -9 $PID local host_ip=$(get_host_ip) ps -ef | grep celeryd | grep ${host_ip}@${host_ip} | awk &apos;{print $2}&apos; | xargs kill -9 ;; flower) echo &quot;stopping airflow flower&quot; PORT=5555 PID=`netstat -nlpt | grep $PORT | awk &apos;{print $7}&apos; | awk -F &quot;/&quot; &apos;{print $1}&apos;` kill -9 $PID start_service ;; scheduler) echo &quot;stopping airflow scheduler&quot; PID=`ps -ef | grep &quot;/usr/local/bin/airflow scheduler&quot; | grep &quot;python&quot; | awk &apos;{print $2}&apos;` kill -9 $PID ;; *) usage exit 1 esac}main &quot;$@&quot; 遇到的坑以及定制化解决方案 问题1: airflow worker 角色不能使用根用户启动 原因：不能用根用户启动的根本原因，在于airflow的worker直接用的celery，而celery 源码中有参数默认不能使用ROOT启动，否则将报错, 源码链接 1234567891011121314151617181920C_FORCE_ROOT = os.environ.get(&apos;C_FORCE_ROOT&apos;, False)ROOT_DISALLOWED = &quot;&quot;&quot;\\Running a worker with superuser privileges when theworker accepts messages serialized with pickle is a very bad idea!If you really want to continue then you have to set the C_FORCE_ROOTenvironment variable (but please think about this before you do).User information: uid={uid} euid={euid} gid={gid} egid={egid}&quot;&quot;&quot;ROOT_DISCOURAGED = &quot;&quot;&quot;\\You&apos;re running the worker with superuser privileges: this isabsolutely not recommended!Please specify a different user using the --uid option.User information: uid={uid} euid={euid} gid={gid} egid={egid}&quot;&quot;&quot; 解决方案一：修改airlfow源码，在celery_executor.py中强制设置C_FORCE_ROOT 1234from celery import Celery, platforms 在app = Celery(…)后新增 platforms.C_FORCE_ROOT = True重启即可 解决方案二：在容器初始化环境变量的时候，设置C_FORCE_ROOT参数，以零侵入的方式解决问题 12#强制celery worker运行采用root模式export C_FORCE_ROOT=True 问题2: docker in docker 在dags中以docker方式调度任务时，为了container的轻量话，不做重型的docker pull等操作，我们利用了docker cs架构的设计理念，只需要将宿主机的/var/run/docker.sock文件挂载到容器目录下即可 docker in docker 资料 问题3: 由于我们运行airlfow的机器是高配机器切分的虚机，host并非是传统的ip段，多节点执行后无法在master节点上通过worker节点提供的日志服务获取执行日志 查看celery源码(celery/celery/worker/worker.py) 1234567891011from celery.utils.nodenames import default_nodename, worker_directself.hostname = default_nodename(hostname)// 查看default_nodename方法def default_nodename(hostname): &quot;&quot;&quot;Return the default nodename for this process.&quot;&quot;&quot; name, host = nodesplit(hostname or &apos;&apos;) return nodename(name or NODENAME_DEFAULT, host or gethostname())//默认在worker.py 的构造方法中没有传入hostname 所以在celery nodenames.py中default_nodename方法里面调用了gethostname//可以看到gethostname的实现，调用了socket.gethostname，这个直接得到了虚拟机的hostgethostname = memoize(1, Cache=dict)(socket.gethostname) 解决方案：发现airflow worker的启动命令中其实提供了设置celery host name的参数 1airflow worker -cn=ip@ip 问题4: 多个worker节点进行调度反序列化dag执行的时候，报找不到module的错误 当时考虑到文件更新的一致性，采用所有worker统一执行master下发的序列化dag的方案，而不依赖worker节点上实际的dag文件，开启这一特性操作如下 12worker节点上： airflow worker -cn=ip@ip -p //-p为开关参数，意思是以master序列化的dag作为执行文件，而不是本地dag目录中的文件master节点上： airflow scheduler -p 错误原因在于远程的worker节点上不存在实际的dag文件，反序列化的时候对于当时在dag中定义的函数或对象找不到module_name 解决方案一：在所有的worker节点上同时发布dags目录，缺点是dags一致性成问题 解决方案二：修改源码中序列化与反序列化的逻辑，主体思路还是替换掉不存在的module为main。修改如下: 12345678910111213141516171819202122232425//models.py 文件，对 class DagPickle(Base) 定义修改import dillclass DagPickle(Base):id = Column(Integer, primary_key=True)# 修改前: pickle = Column(PickleType(pickler=dill))pickle = Column(LargeBinary)created_dttm = Column(UtcDateTime, default=timezone.utcnow)pickle_hash = Column(Text)__tablename__ = &quot;dag_pickle&quot;def __init__(self, dag): self.dag_id = dag.dag_id if hasattr(dag, &apos;template_env&apos;): dag.template_env = None self.pickle_hash = hash(dag) raw = dill.dumps(dag) # 修改前: self.pickle = dag reg_str = &apos;unusual_prefix_\\w*{0}&apos;.format(dag.dag_id) result = re.sub(str.encode(reg_str), b&apos;__main__&apos;, raw) self.pickle =result//cli.py 文件反序列化逻辑 run(args, dag=None) 函数// 直接通过dill来反序列化二进制文件，而不是通过PickleType 的result_processor做中转修改前: dag = dag_pickle.pickle修改后：dag = dill.loads(dag_pickle.pickle) 解决方案三：源码零侵入，使用python的types.FunctionType重新创建一个不带module的function，这样序列化与反序列化的时候不会有问题（待验证) 注意，使用types.FunctionType的方式装饰函数时，由于所有的引用都会从golbals里面找，所以对于module的导入，建议在被装饰的函数里面变成local的方式引入 12//这里把globals()传入是为了把builtlins等一些模块传入，省事new_func = types.FunctionType((lambda df: df.iloc[:, 0].size == xx).__code__, globals()) 问题5：由于airflow在master查看task执行日志是通过各个节点的http服务获取的，但是存入task_instance表中的host_name不是ip，可见获取hostname的方式有问题. 解决方案：修改airflow/utils/net.py 中get_hostname函数，添加优先获取环境变量中设置的hostname的逻辑 12345678910111213141516171819202122232425262728//models.py TaskInstanceself.hostname = get_hostname()//net.py 在get_hostname里面加入一个获取环境变量的逻辑import osdef get_hostname(): &quot;&quot;&quot; Fetch the hostname using the callable from the config or using `socket.getfqdn` as a fallback. &quot;&quot;&quot; # 尝试获取环境变量 if &apos;AIRFLOW_HOST_NAME&apos; in os.environ: return os.environ[&apos;AIRFLOW_HOST_NAME&apos;] # First we attempt to fetch the callable path from the config. try: callable_path = conf.get(&apos;core&apos;, &apos;hostname_callable&apos;) except AirflowConfigException: callable_path = None # Then we handle the case when the config is missing or empty. This is the # default behavior. if not callable_path: return socket.getfqdn() # Since we have a callable path, we try to import and run it next. module_path, attr_name = callable_path.split(&apos;:&apos;) module = importlib.import_module(module_path) callable = getattr(module, attr_name) return callable()","link":"/2018/08/30/airflow实战总结/"},{"title":"lombok builder 泛型擦除","text":"前言 众所周知，Java长期以来比较遭业界嫌弃的是太笨重，代码冗余过大。然而依托于Java庞大健全的开源社区，这些缺点正在逐渐改善。Java 8 引进的lambda以及函数式编程的思想让我们的代码越来越简洁。lombok等各大开源神器让我们的冗余代码越来越少。 使用lombok已经很长时间了，一直很好用，然而最近发现使用lombok builder构造泛型的时候会出现泛型擦除的情况，导致得到的对象是Object类型 案例 定义一个待使用builder构造的泛型类 1234567891011@NoArgsConstructor@AllArgsConstructor@Builderpublic class PageableResponse&lt;T&gt; { List&lt;T&gt; results; @SerializedName(&quot;total_pages&quot;) long totalPages; @SerializedName(&quot;total_elements&quot;) long totalElements;} 正常情况下，我是可以这样使用的: 12345678public PageableResponse&lt;String&gt; getPageableResponse() { return PageableResponse .builder() .results(Lists.newArrayList()) .totalElements(0) .totalPages(0) .build();} 然而出现类型转换错误，PageableResponse.builder()生成的是PageableResponse.PageableResponseBuilder&lt;Object&gt; 想来也是，我这里调用builder方法时候并没有指定任何类型。 泛型基础知识那为什么会得到这样的结果？这里就要回顾一下泛型的知识了，这里我们的场景比较复杂一点，属于泛型类里面的静态泛型方法。这里提一下知识点： java泛型转换的几个事实： 虚拟机中没有泛型，只有普通的类和方法 无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，替换为限定类型（无限定的变量用Object）。当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换 所有的类型参数都用它们的限定类型替换 如:Pair&lt;T&gt; 擦除类型之后就变成了Pair&lt;Object&gt; 桥方法被合成来保持多态 为保证类型安全性，必要时插入强制类型转换 泛型的约束与局限性 不能用基本类型实例化类型参数 运行时类型查询只适用于原始类型: if(a instanceof Pair&lt;String&gt;)//ERROR 同理getClass方法也总是返回原始类型: 1234Pair&lt;String&gt; stringPair=...Pair&lt;Employ&gt; employPair=...if(stringPair.getClass()==employPair.getClass()) //True//两次调用都将返回Pair.class 不能创建参数化类型数组 1234567Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]//ERROR//类型擦除之后，table的类型是Pair[]。可以把它转换为Object[]Object[] arr = table//数组会记住它的元素类型，如果试图存储其他类型的元素，会抛出ArrayStoreException异常//只是不允许创建这些数组，但是声明类型为Pair&lt;String&gt;[]的变量仍是合法的，只是不能用new Pair&lt;String&gt;[10]初始化这个变量//可以声明通配类型的数组，然后进行类型转换，导致的结果将是不安全的Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10]; 不能实例化类型变量: 不能new T(….) 类型擦除会将T改变成Object，而且，本意肯定不希望调用new Object() 可以通过反射调用Class.newInstance方法来构造泛型对象，细节有点复杂 1234567891011//不能以下方式调用first = T.class.newInstance();//ERROR//表达式T.class是不合法的，必须如下方式才可以支配Class对象：public static&lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl){ try { return new Pair&lt;&gt;(cl.newInstance(),cl.newInstance()) } catch (Exception ex) { return null; }}Pair&lt;String&gt; p = Pair.makePair(String.class);//注意，Class类本身就是泛型，String.class是一个Class&lt;String&gt;的实例（唯一实例）。因此makePair方法能够判断出pair的类型。 不能以如下的方式构造泛型数组 123456789101112131415161718//类型擦除会让这个方法永远构造Object[2]数组，而要求extends Comparable，这显然会抛出转换异常// 此时可以把 extends Comparable去掉，这样能保证强制转换的正确性public static &lt;T extends Comparable&gt; T[] minmax(T... a) { Object[] mm = new Object[2]; mm[0] = a[0]; mm[1] = a[1]; return (T[]) mm; } 或者使用反射，调用Array.newInstance: public static &lt;T extends Comparable&gt; T[] minmax(T... a) { T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), 2); ... } 泛型类里面的泛型方法和静态泛型方法是有区别的： 泛型类定义的泛型 在整个类中有效 如果被方法使用，当泛型类确定类型之后，泛型方法也就确定类型了 而对于静态泛型方法而言，其泛型的类型是不依赖于泛型类的类型，也就是这两者的类型完全不相干（依据上一条的事实一） 泛型类型的继承规则 考虑一个类和一个子类，如Employee和Manager。Pair&lt;Manager&gt; 却不是Pair&lt;Employee&gt;的子类。事实上，它们的关系如下图所示 泛型类可以扩展或实现其他泛型类。这一点与普通的类没什么区别。如：ArrayList&lt;T&gt; 类实现List&lt;T&gt;接口，意味着一个ArrayList&lt;Manager&gt; 可以被转换为一个List&lt;Manager&gt;。但是一个ArrayList&lt;Manager&gt; 不是一个ArrayList&lt;Employee&gt; 或者List&lt;Employee&gt;，它们的关系如下图: 案例解释 泛型知识作了一番复习之后，我们再回到上面的案例。之所以无法正常的使用builder，是因为静态泛型方法不继承泛型类的类型。下面是案例类生成的代码： 123456789101112131415161718public class PageableResponse&lt;T&gt; { List&lt;T&gt; results; @JSONField( name = &quot;total_pages&quot; ) long totalPages; @JSONField( name = &quot;total_elements&quot; ) long totalElements; //这个T不依赖于PageableResponse&lt;T&gt;的T public static &lt;T&gt; PageableResponse.PageableResponseBuilder&lt;T&gt; builder() { return new PageableResponse.PageableResponseBuilder(); } ... } 而正常的没有泛型的生成代码如下： 12345678910111213141516171819202122232425262728293031323334353637public class Address { private String city; //不带泛型 public static Address.AddressBuilder builder() { return new Address.AddressBuilder(); } public Address() { } @ConstructorProperties({&quot;city&quot;}) public Address(String city) { this.city = city; } public static class AddressBuilder { private String city; AddressBuilder() { } public Address.AddressBuilder city(String city) { this.city = city; return this; } public Address build() { return new Address(this.city); } public String toString() { return &quot;Address.AddressBuilder(city=&quot; + this.city + &quot;)&quot;; } }} 所以如果必须要使用泛型且如果这种情况不是太多的话，可以自己实现lombok的builder生成的代码，以案例定义的类为例，改造完的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142@NoArgsConstructor@AllArgsConstructorpublic class PageableResponse&lt;T&gt; { List&lt;T&gt; results; @SerializedName(&quot;total_pages&quot;) long totalPages; @SerializedName(&quot;total_elements&quot;) long totalElements; //这里使用非静态方法的写法可以达到继承泛型类型的目的 public PageableResponseBuilder&lt;T&gt; builder() { return new PageableResponseBuilder&lt;T&gt;(); } public class PageableResponseBuilder&lt;T&gt; { List&lt;T&gt; results; long totalPages; long totalElements; public PageableResponseBuilder&lt;T&gt; totalPages(long totalPages) { this.totalPages = totalPages; return this; } public PageableResponseBuilder&lt;T&gt; totalElements(long totalElements) { this.totalElements = totalElements; return this; } public PageableResponseBuilder&lt;T&gt; results(List&lt;T&gt; results) { this.results = results; return this; } public PageableResponse&lt;T&gt; build() { return new PageableResponse&lt;&gt;(results, totalPages, totalElements); } }}","link":"/2017/09/23/lombok-builder-泛型擦除问题/"},{"title":"Spring源码解析--事务处理","text":"事务处理相关类的层次结构 在 Spring事务处理中，可以通过设计一个TransactionProxyFactoryBean来使用AOP功能，通过它可以生成Proxy代理对象。在代理对象中，通过TranscationInterceptor来完成对代理对象方法的拦截。实现声明式事务处理时，是AOP和IOC集成的部分，而对于具体的事物处理实现，是通过设计PlatformTransactionManager，AbstractPlatforTransactionmanager以及一系列具体事务处理器来实现的。PlatformTransactionManager又实现了TransactionInterceptor，这样就能将一系列处理给串联起来。 Spring声明式事务处理设计原理与过程在实现声明式的事务处理时，常用的方式是结合IOC容器和Spring已有的TransactionProxyFactoryBean对事务管理进行配置，实现可分为以下几个步骤： 读取和处理在IOC容器中配置的事务处理属性，并转化为Spring事务处理需要的内部数据结构。 Spring事务处理模块实现统一的事务处理过程。 底层的事务处理实现。Spring委托给具体的事务处理器来完成。 从TransactionProxyFactoryBean入手，通过代码来了解Spring是如何通过AOP功能来完成事务管理配置的，从图中可以看到Spring为声明式事务处理的实现所做的一些准备工作：包括为AOP配置基础设施，这些基础设施包括设置拦截器TransactionInterceptor、通过DefaultPointcutAdvisor或TransactionAttributeSourceAdvisor。同时，在TransactionProxyFactoryBean的实现中，还可以看到注入进来的PlatformTransactionManager和事务处理属性TransactionAttribute等。 123456789101112131415161718192021222324252627282930313233343536public class TransactionProxyFactoryBean extends AbstractSingletonProxyFactoryBean implements BeanFactoryAware { private final TransactionInterceptor transactionInterceptor = new TransactionInterceptor();／／这个拦截器通过AOP发挥作用，通过这个拦截器的实现，Spring封装了事务处理实现 private Pointcut pointcut; public TransactionProxyFactoryBean() { } public void setTransactionManager(PlatformTransactionManager transactionManager) { this.transactionInterceptor.setTransactionManager(transactionManager); } //通过依赖注入的事务属性以Properties的形式出现，把BeanDefinition中读到的事务管理的属性信息注入到TransactionInterceptor中 public void setTransactionAttributes(Properties transactionAttributes) { this.transactionInterceptor.setTransactionAttributes(transactionAttributes); } public void setTransactionAttributeSource(TransactionAttributeSource transactionAttributeSource) { this.transactionInterceptor.setTransactionAttributeSource(transactionAttributeSource); } public void setPointcut(Pointcut pointcut) { this.pointcut = pointcut; } public void setBeanFactory(BeanFactory beanFactory) { this.transactionInterceptor.setBeanFactory(beanFactory); }//这里创建Spring AOP对事务处理的Advisor protected Object createMainInterceptor() { this.transactionInterceptor.afterPropertiesSet();//事务处理完成AOP配置的地方 return this.pointcut != null?new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor):new TransactionAttributeSourceAdvisor(this.transactionInterceptor); } protected void postProcessProxyFactory(ProxyFactory proxyFactory) { proxyFactory.addInterface(TransactionalProxy.class); }} 完成了AOP配置，Spring的TransactionInterceptor配置是IOC容器完成Bean的依赖注入时，通过initializeBean方法被调用。 在建立TransactionProxyFactoryBean的事务处理拦截器的时候， afterPropertiesSet方法首先对 ProxyFactoryBean的目标Bean设置进行检查，如果这个目标Bean的设置是正确的，就会创建ProxyFactory对象，从而实现AOP的使用。 1234567public void afterPropertiesSet() { if(this.getTransactionManager() == null &amp;&amp; this.beanFactory == null) { throw new IllegalStateException(&quot;Set the \\&apos;transactionManager\\&apos; property or make sure to run within a BeanFactory containing a PlatformTransactionManager bean!&quot;); } else if(this.getTransactionAttributeSource() == null) { throw new IllegalStateException(&quot;Either \\&apos;transactionAttributeSource\\&apos; or \\&apos;transactionAttributes\\&apos; is required: If there are no transactional methods, then don\\&apos;t use a transaction aspect.&quot;); }} 事务处理配置的读入在AOP配置完成的基础上，以TransactionAttributeSourceAdvisor的实现为入口，了解具体的事务属性配置是如何读入的，实现如下：123456private TransactionInterceptor transactionInterceptor;／／同样需要AOP中用到的Interceptro和Pointcut，通过内部类，调用TransactionInterceptor来得到事务的配置属性，在对Proxy的方法进行匹配调用时，会使用到这些配置属性。private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() { protected TransactionAttributeSource getTransactionAttributeSource() { return TransactionAttributeSourceAdvisor.this.transactionInterceptor != null?TransactionAttributeSourceAdvisor.this.transactionInterceptor.getTransactionAttributeSource():null; }}; 在声明式事务处理中，通过对目标对象的方法调用进行拦截实现，这个拦截通过AOP发挥作用。在AOP中，对于拦截的启动，首先需要对方法调用是否需要拦截进行判断，依据时那些在TransactionProxyFactoryBean中为目标对象设置的事务属性。这个匹配判断在TransactionAttributeSourcePointcut中完成。实现如下： 12345678public boolean matches(Method method, Class&lt;?&gt; targetClass) { if(TransactionalProxy.class.isAssignableFrom(targetClass)) { return false; } else { TransactionAttributeSource tas = this.getTransactionAttributeSource(); return tas == null || tas.getTransactionAttribute(method, targetClass) != null; }} 在方法中，首先把事务方法的属性配置读取到TransactionAttributeSource对象中，有了这些事务处理的配置以后，根据当前方法调用的method对象和目标对象，对是否需要启动事务处理拦截器进行判断。 在Pointcut的matches判断过程中，会用到transactionAttributeSource对象，这个transactionAttributeSource对象是在对TransactionInterceptor进行依赖注入时就配置好的，它的设置是在TransactionInterceptor的基类TransactionAspectSupport中完成的。配置的是一个NameMatchTransactionAttributeSouce对象。 12345public void setTransactionAttributes(Properties transactionAttributes) { NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource(); tas.setProperties(transactionAttributes); this.transactionAttributeSource = tas;} 可知，NameMatchTransactionAttributeSouce作为TransacionAttributeSource的具体实现，是实际完成事务处理属性读入和匹配的地方。对于NameMatchTransactionAttributeSouce是怎样实现事务处理属性的读入和匹配的，可看如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void setProperties(Properties transactionAttributes) {//设置配置的事务方法 TransactionAttributeEditor tae = new TransactionAttributeEditor(); Enumeration propNames = transactionAttributes.propertyNames(); while(propNames.hasMoreElements()) { String methodName = (String)propNames.nextElement(); String value = transactionAttributes.getProperty(methodName); tae.setAsText(value); TransactionAttribute attr = (TransactionAttribute)tae.getValue(); this.addTransactionalMethod(methodName, attr); }}private Map&lt;String, TransactionAttribute&gt; nameMap = new HashMap();public void addTransactionalMethod(String methodName, TransactionAttribute attr) { if(logger.isDebugEnabled()) { logger.debug(&quot;Adding transactional method [&quot; + methodName + &quot;] with attribute [&quot; + attr + &quot;]&quot;); } this.nameMap.put(methodName, attr);}／／对调用的方法进行判断，判断它是否是事务方法，如果是，那么取出相应的事务配置属性public TransactionAttribute getTransactionAttribute(Method method, Class&lt;?&gt; targetClass) { if(!ClassUtils.isUserLevelMethod(method)) { return null; } else { String methodName = method.getName();／／判断当前目标调用的方法与配置的事务方法是否直接匹配 TransactionAttribute attr = (TransactionAttribute)this.nameMap.get(methodName); if(attr == null) {//如果不能直接匹配，就通过调用PatternMatchUtils的simpleMatch方法来进行匹配判断。 String bestNameMatch = null; Iterator var6 = this.nameMap.keySet().iterator(); while(true) { String mappedName; do { do { if(!var6.hasNext()) { return attr; } mappedName = (String)var6.next(); } while(!this.isMatch(methodName, mappedName)); } while(bestNameMatch != null &amp;&amp; bestNameMatch.length() &gt; mappedName.length()); attr = (TransactionAttribute)this.nameMap.get(mappedName); bestNameMatch = mappedName; } } else { return attr; } }}／／事务方法的匹配判断，详细的匹配过程在PatternMatchUtils中实现protected boolean isMatch(String methodName, String mappedName) { return PatternMatchUtils.simpleMatch(mappedName, methodName);} 事务处理拦截器的设计与实现：经过TransactionProxyFactoryBean的AOP包装，此时如果对目标对象进行方法调用，起作用的对象实际傻姑娘是一个Proxy代理对象。对目标对象方法的调用，不会直接作用在TransactionProxyFactoryBean设置的目标对象上。而是会被设置的事务处理器拦截。而在TransactionProxyFactoryBean的AOP实现中，获取Proxy对象的过程并不复杂，TransactionProxyFactoryBean作为一个FactoryBean，对Bean对象的引用通过getObejct方法来得到的： 12345678public Object getObject() { ／／TransactionProxyFactoryBean 的父类 AbstractSingletonProxyFactoryBean中／／返回的是一个Proxy，是ProxyFactory生成的AOP代理，已经封装了对事务处理的拦截器设置 if(this.proxy == null) { throw new FactoryBeanNotInitializedException(); } else { return this.proxy; }} 对于AOP代理对象的作用方法入口，我们一般都知道invoke方法，这个invke方法在事务处理拦截器TransactionInterceptor中，实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public Object invoke(final MethodInvocation invocation) throws Throwable { Class targetClass = invocation.getThis() != null?AopUtils.getTargetClass(invocation.getThis()):null; return this.invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() { public Object proceedWithInvocation() throws Throwable { return invocation.proceed(); } });}protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final TransactionAspectSupport.InvocationCallback invocation) throws Throwable { final TransactionAttribute txAttr = this.getTransactionAttributeSource().getTransactionAttribute(method, targetClass);／／这里读取事务的属性配置，通过TransactionAttributeSource对象取得 final PlatformTransactionManager tm = this.determineTransactionManager(txAttr);／／根据TransactionProxyFactoryBean的配置信息获得具体的事务处理器 final String joinpointIdentification = this.methodIdentification(method, targetClass, txAttr); if(txAttr != null &amp;&amp; tm instanceof CallbackPreferringPlatformTransactionManager) { try { Object ex1 = ((CallbackPreferringPlatformTransactionManager)tm).execute(txAttr, new TransactionCallback() { public Object doInTransaction(TransactionStatus status) { TransactionAspectSupport.TransactionInfo txInfo = TransactionAspectSupport.this.prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);／／创建事务，同时把事务过程中得到的信息放到TransactionInfo中去，TransactionInfo是保存当前事务状态的对象。 TransactionAspectSupport.ThrowableHolder var4; try { Object ex = invocation.proceedWithInvocation(); return ex; } catch (Throwable var8) { if(txAttr.rollbackOn(var8)) { if(var8 instanceof RuntimeException) { throw (RuntimeException)var8; } throw new TransactionAspectSupport.ThrowableHolderException(var8); } var4 = new TransactionAspectSupport.ThrowableHolder(var8); } finally { TransactionAspectSupport.this.cleanupTransactionInfo(txInfo); } return var4; } }); if(ex1 instanceof TransactionAspectSupport.ThrowableHolder) { throw ((TransactionAspectSupport.ThrowableHolder)ex1).getThrowable(); } else { return ex1; } } catch (TransactionAspectSupport.ThrowableHolderException var14) { throw var14.getCause(); } } else { TransactionAspectSupport.TransactionInfo ex = this.createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try { retVal = invocation.proceedWithInvocation();／／这里的调用使处理沿着拦截器链进行，使最后目标对象的方法得到调用 } catch (Throwable var15) { this.completeTransactionAfterThrowing(ex, var15);／／如果事务处理方法中调用出现了异常，事务处理如何进行需要根据具体情况考虑是否会滚或者提交 throw var15; } finally { this.cleanupTransactionInfo(ex); } this.commitTransactionAfterReturning(ex);//这里通过事务处理器来对事务进行提交 return retVal; }} 对于Spring而言，事务管理实际上是通过一个TransactionInfo对象来完成的，在该对象中，封装了事务对象和事务处理的状态信息，这是事务处理的抽象。在这一步完成以后，会对拦截器链进行处理，因为有可能在该事务对象中还配置了除事务处理AOP之外的其他拦截器，在结束对拦截器链处理之后，会对 TransactionInfo中的信息进行更新，以反映最近的事务处理情况，在这个时候，也就完成了事务提交的准备，通过调用事务处理器PlatformTransactionManager的commitTransactionAfterReturning方法来完成事务的提交。这个提交的处理过程已经封装在事务处理器中了，而与具体数据源相关的处理过程，最终委托给相关的事务处理器完成，如：DataSourceTransactionManager、HibernateTransactionManager等。 这个invoke方法的实现中，可以看到整个事务处理在AOP拦截器中实现的全过程。同时，它也是Spring采用AOP封装事务处理和实现声明式事务处理的核心部分。 Spring事务处理的设计与实现Spring事务传播属性 PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED –如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。 事务的创建声明式事务中，TransactionInterceptor拦截器的invoke方法作为事务处理实现的起点，invoke方法中createTransactionIfNeccessary方法作为事务创建的入口。以下是createTransactionIfNeccessary方法的时序图 在createTransactionIfNeccessary中首先会向AbstractTransactionManager执行getTransaction，这个获取Transaction事务对象的过程，在AbstractTransactionManager中需要对事务不同的情况作出处理，然后创建一个TransactionStatus，并把这个TransactionStatus设置到对应的TransactionInfo中去，同时将TransactionInfo和当前的线程绑定，从而完成事务的创建过程。TransactionStatus和TransactionInfo这俩个对象持有的数据是事务处理器对事务进行处理的主要依据。对这俩个对象的使用贯穿整个事务处理的全过程。 123456789101112131415161718192021222324252627282930313233343536protected TransactionAspectSupport.TransactionInfo createTransactionIfNecessary(PlatformTransactionManager tm, final TransactionAttribute txAttr, final String joinpointIdentification) { if(txAttr != null &amp;&amp; ((TransactionAttribute)txAttr).getName() == null) { txAttr = new DelegatingTransactionAttribute((TransactionAttribute)txAttr) { public String getName() { return joinpointIdentification; } }; } TransactionStatus status = null; if(txAttr != null) { if(tm != null) { status = tm.getTransaction((TransactionDefinition)txAttr);／／这里使用了定义好的事务方法的配置信息。事务创建由事务处理器来完成，同时返回TransactionStatus来记录当前的事务状态，包括已经创建的事务。 } else if(this.logger.isDebugEnabled()) { this.logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification + &quot;] because no transaction manager has been configured&quot;); } } return this.prepareTransactionInfo(tm, (TransactionAttribute)txAttr, joinpointIdentification, status);}protected TransactionAspectSupport.TransactionInfo prepareTransactionInfo(PlatformTransactionManager tm, TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) { TransactionAspectSupport.TransactionInfo txInfo = new TransactionAspectSupport.TransactionInfo(tm, txAttr, joinpointIdentification); if(txAttr != null) { if(this.logger.isTraceEnabled()) { this.logger.trace(&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;); } txInfo.newTransactionStatus(status); } else if(this.logger.isTraceEnabled()) { this.logger.trace(&quot;Don\\&apos;t need to create transaction for [&quot; + joinpointIdentification + &quot;]: This method isn\\&apos;t transactional.&quot;); } txInfo.bindToThread(); return txInfo;} getTansaction实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Overridepublic final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException { Object transaction = doGetTransaction(); // Cache debug flag to avoid repeated checks. boolean debugEnabled = logger.isDebugEnabled(); if (definition == null) { // Use defaults if no transaction definition given. definition = new DefaultTransactionDefinition(); } if (isExistingTransaction(transaction)) { // Existing transaction found -&gt; check propagation behavior to find out how to behave. return handleExistingTransaction(definition, transaction, debugEnabled); } // Check definition settings for new transaction. if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) { throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout()); }／／没有事务存在，需要根据事务传播属性设置来创建事务，这里会看到事务传播属性的设置：mandatory、required required_new nested等 // No existing transaction found -&gt; check propagation behavior to find out how to proceed. if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) { throw new IllegalTransactionStateException( &quot;No existing transaction found for transaction marked with propagation &apos;mandatory&apos;&quot;); } else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) { SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) { logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition); } try { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } catch (RuntimeException ex) { resume(null, suspendedResources); throw ex; } catch (Error err) { resume(null, suspendedResources); throw err; } } else { // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization. if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) { logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; + &quot;isolation level will effectively be ignored: &quot; + definition); } boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null); }} handleExsitingTransaction方法是理解Spring事务传播属性的关键： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*** Create a TransactionStatus for an existing transaction.*/private TransactionStatus handleExistingTransaction( TransactionDefinition definition, Object transaction, boolean debugEnabled) throws TransactionException { if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) { throw new IllegalTransactionStateException( &quot;Existing transaction found for transaction marked with propagation &apos;never&apos;&quot;); } if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) { if (debugEnabled) { logger.debug(&quot;Suspending current transaction&quot;); } Object suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus( definition, null, false, newSynchronization, debugEnabled, suspendedResources); } if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) { if (debugEnabled) { logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; + definition.getName() + &quot;]&quot;); } SuspendedResourcesHolder suspendedResources = suspend(transaction); try { boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } catch (RuntimeException beginEx) { resumeAfterBeginException(transaction, suspendedResources, beginEx); throw beginEx; } catch (Error beginErr) { resumeAfterBeginException(transaction, suspendedResources, beginErr); throw beginErr; } } if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) { if (!isNestedTransactionAllowed()) { throw new NestedTransactionNotSupportedException( &quot;Transaction manager does not allow nested transactions by default - &quot; + &quot;specify &apos;nestedTransactionAllowed&apos; property with value &apos;true&apos;&quot;); } if (debugEnabled) { logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;); } if (useSavepointForNestedTransaction()) {／／在Spring管理的事务中，创建事务保存点 // Create savepoint within existing Spring-managed transaction, // through the SavepointManager API implemented by TransactionStatus. // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization. DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); status.createAndHoldSavepoint(); return status; } else { // Nested transaction through nested begin and commit/rollback calls. // Usually only for JTA: Spring synchronization might get activated here // in case of a pre-existing JTA transaction. boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, null); doBegin(transaction, definition); prepareSynchronization(status, definition); return status; } } // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED. if (debugEnabled) { logger.debug(&quot;Participating in existing transaction&quot;); } if (isValidateExistingTransaction()) { if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) { Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel(); if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) { Constants isoConstants = DefaultTransactionDefinition.constants; throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; + definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; + (currentIsolationLevel != null ? isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) : &quot;(unknown)&quot;)); } } if (!definition.isReadOnly()) { if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) { throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; + definition + &quot;] is not marked as read-only but existing transaction is&quot;); } } } boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);} 事务挂起1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException {／／返回的SuspendedResourcesHolder会作为参数传给TransactionStatus if (TransactionSynchronizationManager.isSynchronizationActive()) { List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization(); try { Object suspendedResources = null;／／把挂起事务的处理交给具体事务处理器去完成，如果具体的事务处理器不支持事务挂起，则默认抛出TransactionSuspensionNotSupportedException if (transaction != null) { suspendedResources = doSuspend(transaction); }//这里在线程中保存与事务处理有关的信息，并重置线程中相关的ThreadLocal变量 String name = TransactionSynchronizationManager.getCurrentTransactionName(); TransactionSynchronizationManager.setCurrentTransactionName(null); boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly(); TransactionSynchronizationManager.setCurrentTransactionReadOnly(false); Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel(); TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null); boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive(); TransactionSynchronizationManager.setActualTransactionActive(false); return new SuspendedResourcesHolder( suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive); } catch (RuntimeException ex) { // doSuspend failed - original transaction is still active… 如果处理失败，则恢复原始的事务 doResumeSynchronization(suspendedSynchronizations); throw ex; } catch (Error err) { // doSuspend failed - original transaction is still active... doResumeSynchronization(suspendedSynchronizations); throw err; } } else if (transaction != null) { // Transaction active but no synchronization active. Object suspendedResources = doSuspend(transaction); return new SuspendedResourcesHolder(suspendedResources); } else { // Neither transaction nor synchronization active. return null; }}/** * Reactivate transaction synchronization for the current thread * and resume all given synchronizations. * @param suspendedSynchronizations List of TransactionSynchronization objects */doSuspend 失败则恢复事务private void doResumeSynchronization(List&lt;TransactionSynchronization&gt; suspendedSynchronizations) { TransactionSynchronizationManager.initSynchronization();／／维护着ThreadLocal变量 for (TransactionSynchronization synchronization : suspendedSynchronizations) { synchronization.resume(); TransactionSynchronizationManager.registerSynchronization(synchronization); }} 事务的提交在声明式事务处理中，事务的提交在TransactionInteceptor的invoke方法中实现：1commitTransactionAfterReturning(txInfo) txInfo是TransactionInfo对象，是创建事务时生成的。同时，Spring的事务管理框架的生成的TransactionStatus对象就包含在TransactionInfo对象中。commitTransactionAfterReturning具体实现如下： 12345678910protected void commitTransactionAfterReturning(TransactionAspectSupport.TransactionInfo txInfo) { if(txInfo != null &amp;&amp; txInfo.hasTransaction()) { if(this.logger.isTraceEnabled()) { this.logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;); } txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()); }} 调用具体的事务管理器实现。而在事务管理器中的实现在AbstractPlatformTransactionManager中存在一个模版：12345678910111213141516171819202122232425262728293031323334353637383940/*** This implementation of commit handles participating in existing* transactions and programmatic rollback requests.* Delegates to {@code isRollbackOnly}, {@code doCommit}* and {@code rollback}.* @see org.springframework.transaction.TransactionStatus#isRollbackOnly()* @see #doCommit* @see #rollback*/@Overridepublic final void commit(TransactionStatus status) throws TransactionException { if (status.isCompleted()) { throw new IllegalTransactionStateException( &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;); } DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status; if (defStatus.isLocalRollbackOnly()) {／／如果事务处理过程中发生了异常，调用回滚。 if (defStatus.isDebug()) { logger.debug(&quot;Transactional code has requested rollback&quot;); } processRollback(defStatus); return; } if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) { if (defStatus.isDebug()) { logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;); }／／处理回滚 processRollback(defStatus); // Throw UnexpectedRollbackException only at outermost transaction boundary // or if explicitly asked to. if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) { throw new UnexpectedRollbackException( &quot;Transaction rolled back because it has been marked as rollback-only&quot;); } return; } ／／处理提交入口 processCommit(defStatus);} 可以看出rollback和commit都在这个方法中实现。看看 processCommit的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private void processCommit(DefaultTransactionStatus status) throws TransactionException { try { boolean beforeCompletionInvoked = false; try {／／事务的提交准备工作由具体的事务处理器来完成 prepareForCommit(status); triggerBeforeCommit(status); triggerBeforeCompletion(status); beforeCompletionInvoked = true; boolean globalRollbackOnly = false; if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) { globalRollbackOnly = status.isGlobalRollbackOnly(); }／／嵌套事务的处理过程。 if (status.hasSavepoint()) { if (status.isDebug()) { logger.debug(&quot;Releasing transaction savepoint&quot;); } status.releaseHeldSavepoint(); } else if (status.isNewTransaction()) {／／根据当前线程中保存的事务状态进行处理，如果当前的事务是一个新的事务，调用具体事务处理器的完成提交，如果当前所持有的事务不是一个新事务，则不提交，由已经存在的事务来完成提交 if (status.isDebug()) { logger.debug(&quot;Initiating transaction commit&quot;); } doCommit(status); } // Throw UnexpectedRollbackException if we have a global rollback-only // marker but still didn&apos;t get a corresponding exception from commit. if (globalRollbackOnly) { throw new UnexpectedRollbackException( &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;); } } catch (UnexpectedRollbackException ex) { // can only be caused by doCommit triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK); throw ex; } catch (TransactionException ex) { // can only be caused by doCommit if (isRollbackOnCommitFailure()) { doRollbackOnCommitException(status, ex); } else { triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN); } throw ex; } catch (RuntimeException ex) { if (!beforeCompletionInvoked) { triggerBeforeCompletion(status); } doRollbackOnCommitException(status, ex); throw ex; } catch (Error err) { if (!beforeCompletionInvoked) { triggerBeforeCompletion(status); } doRollbackOnCommitException(status, err); throw err; } // Trigger afterCommit callbacks, with an exception thrown there // propagated to callers but the transaction still considered as committed. try { triggerAfterCommit(status); } finally { triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED); } } finally { cleanupAfterCompletion(status); }} 可以看出，对事务的提交处理都是紧紧围绕TransactionStatus保存的事务处理相关状态进行判断。具体的提交处理过程都设计成抽象方法，交由具体的事务处理器来完成。 事务的回滚在事务的提交方法中看到了事务的回滚入口，即processRollback方法，其实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void processRollback(DefaultTransactionStatus status) { try { try { triggerBeforeCompletion(status); if (status.hasSavepoint()) {／／嵌套事务的回滚处理 if (status.isDebug()) { logger.debug(&quot;Rolling back transaction to savepoint&quot;); } status.rollbackToHeldSavepoint(); }／／当前事务调用方法中新建事务的回滚处理 else if (status.isNewTransaction()) { if (status.isDebug()) { logger.debug(&quot;Initiating transaction rollback&quot;); } doRollback(status); }／／如果在当前事务调用方法中没有新建事务的回滚处理 else if (status.hasTransaction()) { if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) { if (status.isDebug()) { logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;); } doSetRollbackOnly(status); }／／由线程的前一个事务来处理回滚，这里不执行任何操作。 else { if (status.isDebug()) { logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;); } } } else { logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;); } } catch (RuntimeException ex) { triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN); throw ex; } catch (Error err) { triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN); throw err; } triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK); } finally { cleanupAfterCompletion(status); }} 显然，看了代码我们很快就能理解，Spring 事务传播属性中的 Required_New和NESTED（嵌套事务）的本质区别 PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行. 另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,它将取得一个 savepoint. 如果这个嵌套事务失败,我们将回滚到此savepoint潜套事务是外部事务的一部分,只有外部事务结束后它才会被提交。 由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back. 也就是说： PROPAGATION_REQUIRES_NEW事务不受外部事务的影响，是隔离的。 PROPAGATION_NESTED，如果内部事务失败且内部，它会回到savepoint之前的状态不会产生脏数据，而外部事务catch住异常后可以选择回滚或者提交；如果外部事务失败，由于嵌套事务是外部事务的一部分，则会导致外部事务与嵌套事务一起回滚。","link":"/2017/02/12/Spring源码解析-事务处理/"},{"title":"okhttp support 100-continue for palo","text":"前言虽然百度的Palo是个很强大的，基于MPP Search Engine的OLAP框架，但是由于处于开源的早期阶段，各方面都不是很完善。其中，Palo集群的稳定性对于日渐依赖Palo的核心的业务来说显得尤为重要。最近也一直在做Palo稳定性建设相关的工作。在对全链路监控这块，自然而然地想到对业务中使用频繁的http-mini-load接口进行SDK封装，以实现对请求进行失败重试以及失败率的监控报警的功能。 遇到的问题问题描述 在实际的SDK封装中，用到了流行的okhttp，发送请求如下: 12345678910PaloHttpUtil paloHttpUtil = PaloHttpUtil.builder().build();String bodyStr = &quot;1 1 2018-04-12 20:13:00 4101628087476389 1\\n1 1 2018-04-12 20:13:00 4205819141030267 2&quot;;System.out.println(paloHttpUtil .put(String.format(&quot;http://xxxx:8030/api/feed/comment_trend/_load?&quot; + &quot;label=comment_trend_load_%s&amp;columns=trend_type,user_type,timestamp,mid,count&quot;, prefix)) .auth(&quot;feed&quot;, &quot;feed&quot;) .header(&quot;Expect&quot;, &quot;100-continue&quot;) .body(bodyStr, ContentType.WILDCARD) .asyncSend(3, 10000, TimeUnit.MILLISECONDS) .string() response: code 307 Temporary {“Status”:”Failed”} 也就是说发生了重定向。对于服务器为何不在一个request中直接接收PUT的数据，这块贴一下100-continue的定义。 123 100 (Continue/继续) :如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。 至于为什么发生了重定向先不考虑，先研究一下为什么okhttp不支持307重定向。 源码追踪 我们通过debug深入源码看看在哪一步处理的307重定向 由图，我们可以看到对于request/response的处理，okhttp采取了插件的形式，类似于Spring AOP 源码中切面invoke方法的处理方式。这种插件的方式意味着我们可以定制化请求处理逻辑。借官方原图： 由于interceptor里面是可以执行重试逻辑或直接返回response，所以，我们再深入看看在哪个Interceptor里直接返回了response。断点打到RetryAndFollowUpInterceptor里如下的代码块： 123456789Request followUp = this.followUpRequest(response, streamAllocation.route()); //这里followUP返回null if (followUp == null) { if (!this.forWebSocket) { streamAllocation.release(); } return response; } 由于followUp返回了null，导致response直接返回。说明当前的redirect策略不支持307重定向，再深入具体的重定向策略followUpRequest 发现307，308如果request method不等于GET且不为HEAD时直接返回了null，由此对于307 的PUT重定向操作okhttp是不支持的 问题的解决okhttp 添加自定义redirect interceptor 前面提到，我们可以往okhttpClient里面添加自定义的interceptor来达到对request/response灵活劫持的目的。于是考虑加一个支持palo put 307 重定向的redirect interceptor. 大致的策略还是跟RetryAndFollowUpInterceptor一样，对followUpRequest的方法做了修改 12345case 300: case 301:case 302:case 303:case 307: 将307放到了300-303并列的位置，进入redirect逻辑。去掉将method统一替换成GET的逻辑: 123456if (HttpMethod.redirectsToGet(method)) { requestBuilder.method(&quot;GET&quot;, (RequestBody)null);} else { RequestBody requestBody = maintainBody ?userResponse.request().body() : null; requestBuilder.method(method, requestBody);} 改为: 123boolean maintainBody = HttpMethod.requiresRequestBody(method); RequestBody requestBody = maintainBody ? userResponse.request().body() : null; requestBuilder.method(method, requestBody); 为了带上用户名密码，去掉逻辑: 123 if (!this.sameConnection(userResponse, url)){ requestBuilder.removeHeader(&quot;Authorization&quot;);} 至此，Palo http-mini-load put 307 Temporary 重定向问题得到了解决 使用apache httpcomponents 在apache httpcomponents中，可以设置redirectStrategy，来达到重定向的策略，且不受http code的约束 可以看到本身的redirect机制还是比较强大的 不过鉴于本人习惯用okhttp，且用自定义的interceptro也能解决问题，所以暂时没有采用这种方法。 总结 okhttp 不支持307除get意外其他request method重定向的原因不得而知。不过对于开源的组件，也不必要满足各种各样奇怪的胃口，对于需求的定制化留好可扩展接口就行。","link":"/2018/04/24/okhttp-support-100-continue-for-palo/"},{"title":"superset customization","text":"前言 由于数据组目前重度依赖kylin，然而kylin并没有官方开源的数据可视化工具。所幸kylin提供了丰富的查询API供我们直接传入SQL进行查询，与此同时发现superset有非官方对接kylin的开源插件，虽然两年没有维护了，对代码进行了部分重构也就成功将superset和kylin对接起来了。 通常一个开源框架在使用过程中，总是会有各种各样的针对具体场景的定制化需求，superset自然不例外。于是下面简单记录一下superset定制化的过程中干的一些事情，算是做一个小的总结。 python2升级python3虽然python2.7是superset官方推荐的版本，但是由于python2.7默认的Encoding的问题导致使用过程中一旦出现中文就出错。为了避免这种情况，我选择将python2.7升级到python3.5。当然升级还算顺利，碰到的最大的坑就是python2中的MysqlDB模块在python3中已经不维护了，于是修改superset源码如下 12345#init.py#pip install pymysqlimport pymysqlpymysql.install_as_MySQLdb() superset ldap配置 基本上各大开源组件都支持ldap的配置，superset也不例外。ldap的好处就是给企业用户提供统一的账户授权，方便权限管理。 由于google上基本上查不到相关的资料或者都是配置出错了没法解决的提问，这一块踩了不少的坑。然后发现superset其实是直接用的flask-appbuilder里提供的security组件支持ldap的，通过熟悉ldap的原理以及查看flask-appbuilder的官方文档和security组件的源代码最终解决了ldap的配置问题。 先在config.py中引入flask-appbuilder的相关依赖 123456#引入引用：from flask_appbuilder.security.manager import AUTH_OID,AUTH_REMOTE_USER,AUTH_DB, AUTH_LDAP,AUTH_OAUTH,AUTH_OAUTH 再在config.py AUTH一块的区域中加入如下配置 123456789101112131415161718//最终配置（这里用到二次验证，即bind给定账户，然后根据权限去搜索输入的用户，拉 取用户的dn，最后用得到的密码和拉取到的dn去bind_user即可）#2表示使用ldapAUTH_TYPE = 2 #自己公司的ldap服务器AUTH_LDAP_SERVER = &quot;ldap://ldap.example.com&quot; #ldap有两种认证方式，这里用到二次验证，需要配置一个admin账号AUTH_LDAP_BIND_USER = &quot;cn=admin,dc=ldap,dc=mobvoi,dc=com&quot;#admin账号的密码AUTH_LDAP_BIND_PASSWORD = &quot;xxxx&quot;AUTH_LDAP_USE_TLS = False#在哪个节点查找用户AUTH_LDAP_SEARCH = &quot;ou=users,dc=ldap,dc=mobvoi,dc=com&quot;#查找用户的字段AUTH_LDAP_UID_FIELD = &quot;uid&quot;#是否允许superset数据库中没有记录的ldap用户自动注册AUTH_USER_REGISTRATION = True#注册新用户时默认分配的权限AUTH_USER_REGISTRATION_ROLE = &quot;Dashboard Readonly&quot; superset docker化为了减轻运维服务器升级时服务的迁移成本，决定将统一修改的源码托管起来，每一次修改重新发布docker，这样能大大降低运维成本。 拉取ubuntu镜像，挂载本地磁盘，并进入后台运行模式 1sudo docker run -it -v /home/:/home/ leemiracle/unbuntu /bin/bash 在ubuntu中安装python3.5 1wget https://www.python.org/ftp/python/3.5.4/Python-3.5.4rc1.tgz 拖下superset、pylin源代码，安装pyklin 与ldap 123456git clonet git@github.com:lichaojacobs/superset.gitgit clone git@github.com:lichaojacobs/pykylin.gitcd pykylinpip install -r ./requirements.txt python setup.py install pip install pyldap 修改flask-appbuilder代码（重写了权限部分逻辑） 1234567flask-appbuilder/security/manager.py auth_user_ldap (method)try: user_db = self.auth_user_db(username,password) if user_db!=None: return user_db except Exception: log.info(&quot;using ldap and first try db_auth failed&quot;) 修改superset源码（增加status接口，主要是对服务状态进行监测） 123456789from flask import jsonify class MyIndexView(IndexView): @expose(&apos;/&apos;) def index(self): return redirect(&apos;/superset/welcome&apos;) @expose(&apos;/status&apos;) def status(self): return jsonify(status=&apos;ok&apos;) 修改superset config.py，加入缓存配置，ldap配置等 1234567891011加上缓存： CACHE_DEFAULT_TIMEOUT = 7200 CACHE_CONFIG = { &apos;CACHE_TYPE&apos;:&apos;redis&apos;, &apos;CACHE_DEFAULT_TIMEOUT&apos;:7200, &apos;CACHE_KEY_PREFIX&apos;:&apos;superset_&apos;, &apos;CACHE_REDIS_HOST&apos;:&apos;xxxxxx.aliyuncs.com&apos;, &apos;CACHE_REDIS_PORT&apos;:6379, &apos;CACHE_REDIS_DB&apos;:&apos;&apos;, &apos;CACHE_REDIS_PASSWORD&apos;:&apos;xxxxx&apos; } 加上GA脚本用于统计页面PV UV 12345678910111213&lt;script&gt; (function(i,s,o,g,r,a,m){i[&apos;GoogleAnalyticsObject&apos;]=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,&apos;script&apos;,&apos;https://www.google-analytics.com/analytics.js&apos;,&apos;ga&apos;); {% if g.user.get_full_name %} ga(&apos;set&apos;, &apos;userId&apos;, &apos;{{g.user.get_full_name()}}&apos;); {% endif %} ga(&apos;create&apos;, &apos;UA-64695573-19&apos;, &apos;auto&apos;); ga(&apos;send&apos;, &apos;pageview&apos;); &lt;/script&gt; 自编译superset 123cd $SUPERSET_HOME/superset/assets./js_build.sh#由于实际编译过程中出现了各种测试异常，我将npm run test,npm run cover去掉了 安装superset 12345apt-get install build-essential libssl-dev libffi-dev python-dev python-pip libsasl2-dev libldap2-dev apt-get install python3.5-devpip install --upgrade setuptools pip#直接运行上一步编译好的文件python superset/setup.py install 打包镜像，重新commit修改，并打上tag 1sudo docker commit -m &quot;superset docker init&quot; -a &quot;author&quot; &lt;container id&gt; &lt;docker repository host&gt;/superset:&lt;version&gt; 运行docker 1sudo docker run -m 1G --net=host &lt;docker repository host&gt;/superset:&lt;version&gt; superset runserver -p 8088 -t 500 总结虽然目前步子迈得有点小，但好在还在进步。在自己努力下，从之前痛苦的数据架构升级到现在，数据组的基础架构平台也算是稳定的在提供服务了。kylin也在啃了很久的源代码，做了一些优化之后从之前每天要挂三四次，数据主从同步问题每次执行任务都要重现到现在也能平稳运行。路还很长，想往底层钻的深一点，继续加油吧～","link":"/2017/10/13/superset-customization/"},{"title":"【Spark源码分析】Broadcast","text":"前言Spark的broadcast机制本意在于两表做join时，如果其中某一个表足够的小，且又不是join的基表时（left或right join），可以将小表通过网络全量分发到各个executor节点上；通过在各个分区本地做join的方式来减少一次shuffle带来的开销 Broadcast 原理满足broadcast join的条件源码分析 来看SparkStrategies.scala文件 Broadcast 策略入口 broadcastSideBySizes 可以发现broadcast 左表或者是右表是根据两个策略来控制的：canBuildLeft/canBuildRight， canBroadcast； canBroadcast控制的是数据大小是否符合参数设定 canBuildLeft/canBuildRight是判断被广播的表是否作为left或right join基表的情况；如果作为基表的话是不能被broadcast的；当然Inner join不用管是不是基表 基表不能被广播的原因 left/right join 之所以基表不能broadcast是因为这样做会破坏left join语义，产生重复的数据(比如广播了n份基表，因为最后都要保留基表的数据，不管有没有匹配上，所以会导致归并的时候有重复的情况) 翻阅其他博客对broadcast的解释，也能发现基表不能被广播的事实 Spark SQL中Join常用的几种实现","link":"/2019/06/02/【Spark源码分析】Broadcast/"},{"title":"python 爬取新浪微博","text":"最近因为课设的要求，开始了对新浪微博数据的爬取研究，看了不少博客文章，也试了不少方法，原理无非就是模拟登录，但是感觉目前可用的方法太过分散，而且自从微博改版之后，很多以前适用的方法都基本没有用处了。这里总结一下几种可用的方法以及自己研究之后稳定可用的方法(所有的方法都是基于python2.7)： ###1、绕过.com域名 如果没有爬取主站的刚需，只是对微博相关的数据感兴趣，可以尝试爬取微博cn域名下的内容(即http://weibo.cn)，亲测可用...最简单的办法就是先预先登录一下然后获取返回的cookie，贴入代码中作为请求的headers即可。 123456_header={ &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.86 Safari/537.36&quot;, &quot;Cookie&quot;:&quot;_T_WM=03e77f532a8c1a437da863b36a62207d; SUB=_2A256KfecDeRxGeVP61MX9yzKyT-IHXVZ1ZnUrDV6PUNbvtANLRTVkW1LHesQJOUc8nbbLnoALvjmulMBSwDnAw..; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9WhPUuFTXg4zll8rx_8Ap-XA5JpX5KMhUgL.Foepeh2cS0zceoet; SUHB=0cSXC9tcKk2RM7; SSOLoginState=1462601676; gsid_CTandWM=4uTtCpOz5hhWcws1tVSIdd0SYa3&quot; } request = urllib2.Request(url=url, headers=self._header) response = urllib2.urlopen(request) html = response.read() 接下来对爬取下来的html就可以通过xpath,或者bs来完成数据提取了。 ###2、使用urllib模拟登录微博.com主站 这个过程比较麻烦，前人有了很多铺垫做相应的改动直接拿来用就好啦，以下代码亲测可用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116-*- coding: utf-8 -*-import urllib2import reimport rsaimport cookielib #从前的cookielibimport base64import jsonimport urllibimport binasciifrom lxml import etreeimport json 用于模拟登陆新浪微博class launcher(): cookieContainer=None _headers={ &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36&quot; } def __init__(self,username, password): self.password = password self.username = username def get_prelogin_args(self): json_pattern = re.compile(&apos;\\((.*)\\)&apos;) url = &apos;http://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=&amp;&apos; + self.get_encrypted_name() + &apos;&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.18)&apos; try: request = urllib2.Request(url) response = urllib2.urlopen(request) raw_data = response.read().decode(&apos;utf-8&apos;) print &quot;get_prelogin_args&quot;+raw_data; json_data = json_pattern.search(raw_data).group(1) data = json.loads(json_data) return data except urllib2.HTTPError as e: print(&quot;%d&quot;%e.code) return None def get_encrypted_pw(self,data): rsa_e = 65537 #0x10001 pw_string = str(data[&apos;servertime&apos;]) + &apos;\\t&apos; + str(data[&apos;nonce&apos;]) + &apos;\\n&apos; + str(self.password) key = rsa.PublicKey(int(data[&apos;pubkey&apos;],16),rsa_e) pw_encypted = rsa.encrypt(pw_string.encode(&apos;utf-8&apos;), key) self.password = &apos;&apos; #清空password passwd = binascii.b2a_hex(pw_encypted) print(passwd) return passwd def get_encrypted_name(self): username_urllike = urllib.quote(self.username) byteStr=bytes(username_urllike) byteStrEncod=byteStr.encode(encoding=&quot;utf-8&quot;) username_encrypted = base64.b64encode(byteStrEncod) return username_encrypted.decode(&apos;utf-8&apos;) def enableCookies(self): #建立一个cookies 容器 self.cookieContainer = cookielib.MozillaCookieJar(&quot;/Users/lichao/desktop/weibo/cookie/cookie.txt&quot;); # ckjar=cookielib.MozillaCookieJar(&quot;/Users/Apple/Desktop/cookie.txt&quot;) #将一个cookies容器和一个HTTP的cookie的处理器绑定 cookie_support = urllib2.HTTPCookieProcessor(self.cookieContainer) #创建一个opener,设置一个handler用于处理http的url打开 opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler) #安装opener，此后调用urlopen()时会使用安装过的opener对象 # proxy_handler = urllib2.ProxyHandler({&quot;http&quot;: &apos;http://localhost:5000&apos;}) # opener=urllib2.build_opener(proxy_handler) urllib2.install_opener(opener) def build_post_data(self,raw): post_data = { &quot;entry&quot;:&quot;weibo&quot;, &quot;gateway&quot;:&quot;1&quot;, &quot;from&quot;:&quot;&quot;, &quot;savestate&quot;:&quot;7&quot;, &quot;useticket&quot;:&quot;1&quot;, &quot;pagerefer&quot;:&quot;Sina Visitor System&quot;, &quot;vsnf&quot;:&quot;1&quot;, &quot;su&quot;:self.get_encrypted_name(), &quot;service&quot;:&quot;miniblog&quot;, &quot;servertime&quot;:raw[&apos;servertime&apos;], &quot;nonce&quot;:raw[&apos;nonce&apos;], &quot;pwencode&quot;:&quot;rsa2&quot;, &quot;rsakv&quot;:raw[&apos;rsakv&apos;], &quot;sp&quot;:self.get_encrypted_pw(raw), &quot;sr&quot;:&quot;1280*800&quot;, &quot;encoding&quot;:&quot;UTF-8&quot;, &quot;prelt&quot;:&quot;77&quot;, &quot;url&quot;:&quot;http://weibo.com/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack&quot;, &quot;returntype&quot;:&quot;META&quot; } data = urllib.urlencode(post_data).encode(&apos;utf-8&apos;) return data def login(self): url = &apos;新浪通行证&apos; self.enableCookies() data = self.get_prelogin_args() post_data = self.build_post_data(data) headers = { &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36&quot; } try: request = urllib2.Request(url=url,data=post_data,headers=headers) response = urllib2.urlopen(request) html = response.read().decode(&apos;GBK&apos;) #print(html) except urllib2.HTTPError as e: print(e.code) p = re.compile(&apos;location\\.replace\\(\\&apos;(.*?)\\&apos;\\)&apos;) p2 = re.compile(r&apos;&quot;userdomain&quot;:&quot;(.*?)&quot;&apos;) try: login_url = p.search(html).group(1) print(login_url) request = urllib2.Request(login_url) response = urllib2.urlopen(request) page = response.read().decode(&apos;utf-8&apos;) print(page) login_url = &apos;http://weibo.com/&apos; + p2.search(page).group(1) request = urllib2.Request(login_url) response = urllib2.urlopen(request) final = response.read().decode(&apos;utf-8&apos;) print(&quot;Login success!&quot;) self.cookieContainer.save(ignore_discard=True, ignore_expires=True) except Exception, e: print(&apos;Login error!&apos;) print e return 0 ###3、使用selenium实现模拟登录 selenium +phantomjs 第二种方法有一个问题，因为目前新版的微博页面的渲染方式采用的是分片渲染的，这就导致我们通过第二种静态方式爬取到的页面并不是最终的页面，而是内容嵌在 js里的中间页面，这肯定不是我们想看到的结果。于是，考虑模拟浏览器渲染页面的方式获取到最终的呈现页面。selenium这个工具正好完美的解决了我们的问题，它可以模拟浏览器的行为，并且我们拿到的source可以向jquery操作dom对象那样查找定位元素，非常方便，实现的核心代码如下： 123456789101112131415161718192021222324252627282930import timefrom selenium import webdriverimport urllib2import selenium.webdriver.support.ui as uiimport sysreload(sys)sys.setdefaultencoding( &quot;utf-8&quot; )from selenium.webdriver.common.keys import KeysChrome PhantomJS#driver = webdriver.PhantomJS(&quot;/Users/test/documents/phantomjs/bin/phantomjs&quot;)driver.get(&apos;http://weibo.com/&apos;)try: print &quot;登录开始&quot; username = driver.find_element_by_xpath(&apos;//input[@name=&quot;username&quot;]&apos;) password = driver.find_element_by_xpath(&apos;//input[@name=&quot;password&quot;]&apos;) sbtn = driver.find_element_by_xpath(&apos;//a[@action-type=&quot;btn_submit&quot;]&apos;) username.send_keys(&apos;&apos;) #send username password.send_keys(&apos;&apos;) #send password sbtn.click() # 提交表单 time.sleep(3) # 等待页面加载 # get the session cookie cookie = {item[&quot;name&quot;] + &quot;:&quot; + item[&quot;value&quot;] for item in driver.get_cookies()} cookie=driver.get_cookies() for item in driver.get_cookies(): cookieItem={&quot;name&quot;:item[&quot;name&quot;],&quot;value&quot;:item[&quot;value&quot;],&quot;domain&quot;:item[&quot;domain&quot;],&quot;httponly&quot;:item[&quot;httponly&quot;],&quot;path&quot;:item[&quot;path&quot;],&quot;secure&quot;:item[&quot;secure&quot;]} cookie.append(cookieItem) cookie_file= open(&quot;/Users/test/desktop/weibo/cookie/cookie.txt&quot;,&apos;w&apos;) cookie_file.write(str(cookie)) print str(str(cookie))except urllib2.HTTPError as e: print e print &quot;登录失败&quot;print &quot;开始爬取谣言大厅&quot;driver.get(&quot;http://service.account.weibo.com/show?rid=K1CaN7gJl8q8f&quot;)page = driver.page_sourceprint pagedriver.quit() 我们将登录之后获取的cookie以键值对的形式存入文本文件中，方便下次直接load而不需要重复登录: 123456789def loadCookie(self):self._driver.get(&quot;http://www.sina.com.cn&quot;) cookie_file=open(&quot;/Users/test/desktop/weibo/cookie/cookie.txt&quot;,&apos;r&apos;) cookieStr=cookie_file.read();print &quot;cookie is: &quot;+cookieStr cookieList=list(eval(cookieStr))for item in cookieList:cookieDic= type(eval(item)) self._driver.add_cookie(item) selenium +chromedirver 使用phantomjs存在一个问题，登录过程老是失败，因为验证码无法识别获取导致登录经常失败，这里我们使用chromedirver这工具结合selenium实现开挂级别的python数据爬取，模拟登录万无一失，核心代码如下： 12345print &quot;登录开始&quot;username = driver.find_element_by_xpath(&apos;//input[@name=&quot;username&quot;]&apos;)password = driver.find_element_by_xpath(&apos;//input[@name=&quot;password&quot;]&apos;)sbtn = driver.find_element_by_xpath(&apos;//a[@action-type=&quot;btn_submit&quot;]&apos;)veryfiCode=driver.find_element_by_xpath(&apos;//input[@name=&quot;verifycode&quot;]&apos;) 程序启动时会自动开启一个chrome窗口，只不过这个浏览器的行为我们可以通过程序控制，这样是不是方便多了！我们在username这一行打一个断点，然后程序执行到这一步，在浏览器中输入相应的用户名，密码，验证码，然后在pycharm中点击继续，登录成功！真实浏览器结合程序，真是开挂级别的爬取微博啊…","link":"/2016/12/01/python-爬取新浪微博/"},{"title":"【Spark源码分析】Dynamic Resource Allocation设计的思考","text":"前言最近在用spark的dynamicAllocation时发现：如果一个executor超过了设置的executorIdleTimeout时间，触发了回收策略，停止executor之后在sparkUI上会显示该executor的状态为Dead的情况 这引起了我的疑问，因为凭我自身的经验判断会误以为这个executor是一种被动退出的情况；也即是executor进程因为某种原因被nodemanager kill了，导致driver将这个executor状态置为dead并进行一系列的清理工作。而如果是dynamicAllocation的话，我认为是一种主动退出的情况，是安全的。spark自身系统设计不应该将这两个概念的状态笼统的用一个Dead来混淆视听 本着对真理追求到底的态度，我决定对sparkUI统计数据的来源这块代码逻辑进行梳理，以给自己提出的问题寻求答案 源码分析Spark UI Server启动 我们知道启动一个spark application之后相应的也会启动一个sparkUI server，用于实时监控展示 jobs，stages， executors等一些统计信息，那这些统计数据来自哪里呢？spark内部通过LiveListenerBus实现了一种监听订阅的模式，application内部所有的变更状态通过发布变更事件，交由订阅这些变更事件的实现去处理（这里称之为spark listener）。处理完之后的最新状态将反应在sparkUI上。 从图中我们可以看出DAGSchedule是主要产生各类SparkListenerEvent的起源，SparkListenerEvent通过ListenerBus事件队列，期间定时器匹配将事件匹配到不同的SparkListener实现上去 Executor页面渲染 在SparkUI的初始化方法中可以看到绑定了我们在界面中见到的几个Tab，如Executors，stages，storage等 跟进ExecutorsTab中看具体的页面渲染逻辑 整个代码层次分明，页面渲染包括页面顶部通用的bar以及body里面具体的内容，这里将渲染页面顶部的逻辑模块化了；我们主要看的是executorspage.js这个文件，这里面是获取executor summary数据并渲染的主逻辑。在executorspage.js内部，发现为获取all-executors数据，发送了一个ajax请求 这个allexecutors接口有我们想要的executors数据来源信息。全局搜索这个endpoint，发现在AbstractApplicationResource 声明定义了该接口实现 意外的发现做了一个类似于请求存储的操作，跟进去发现是AppStatusStore 查看类说明，发现这是一个spark 自身kv store的的访问封装实现 追踪到这里，算是对数据来源钻到了尽头，可以知道最终sparkUI上executors summary数据是存在自身实现的kvstore里的 关于kvstore的由来，可以详细看这个issule 。大致的点和思路是：Spark History server在查看某一个application运行记录的时候需要从eventlog里面拿出数据渲染；对于少数几个任务来说，目前的实现没有问题，但是如果管理了大量的application，history server就会变的几乎不可用；于是思路是实现一套存储(基于LevelDB或Inmemory结合) 可供history server读写，能大幅提升其页面加载速度 现在我们需要关注一下executorAdded或者removed事件对kvstore里面的数据处理逻辑，看SparkListener中对executor增减接口的定义，追溯到AppStatusListener实现，这也恰好是改变AppStatusStore的入口 可见当executor被remove的时候只是将状态置为false，并更新了kvstore里面的值，而不是将其删除，所以前端查询的时候如果发现executor状态不是active且没在blacklist里面的话，默认就把状态format称Dead了 DynamicAllocation 实现机制 这里再补充一下DynamicAllocation的底层实现分析。回到之前SparkListener里定义的两个事件处理接口：onExecutorAdded，onExecutorRemoved；其实不止AppStatusListener对这两个事件做了处理，还有ExecutorAllocationListener。这个监听器是触发ExecutorAllocationManager增删executors的入口 可以看出里面都是调用的allocationManger里面的具体实现。在onExecutorAdded的callback处理逻辑中，会对新加入的executor做idle记录（onExecutorIdle中实现），先判断当前executor有没有缓存的blocks，走不同的计算timeout分支。其中cachedExecutorIdleTimeoutS默认是Integer.MAX_VALUE ，然后将记录存入hash结构()里，方便ExecutorAllocationManager在定时任务下一个周期做检查排除过期的executor 检查逻辑如下： 总结 从源码分析来看，确实主动和被动释放executor，在sparkUI上面对应的executor状态都会变为Dead。对于使用者来说，如果不清楚spark是否开启了dynamic allocation也确实会引起歧义。毕竟Dead总归是一种不好的状态，甚至逼迫着运维同学去分析一波日志。不知道spark以后的版本中是否会增加一个新的状态？比如引入Released之类的状态将主动和被动区分开，我想这样的话用户体验会更好。","link":"/2019/05/26/【Spark源码分析】Dynamic-Resource-Allocation设计的思考/"},{"title":"【Spark源码分析】Job提交执行过程详解","text":"前言最近恰好有点时间梳理一下整个Spark job提交执行流程的相关源码。首先，给一个总的代码流程图（在Executor那块还需补充完整），方便理解整个处理逻辑 Spark Job 提交处理过程源码解析submitJob解析 macos IntelliJ 中 command+7 查看DagScheduler所有方法，从submitJob方法开始分析，提交了JobSubmitted事件进事件队列，等待处理 在DagScheduler中有DAGSchedulerEventProcessLoop类，主要用来集中分发处理事件队列中的事件 移步DagScheduler.handleJobSubmitted方法，更新UI数据，同时调用submitStage方法；这里finalStage是createResultStage这个方法从最后一个stage生成所有stage的过程 submitStage解析 可以看到getOrCreateParentStages方法中只有shuffle操作时才会创建新的stage 再来看SubmitStage方法实现细节，看之前如果对spark运行有了解的话，也大概知道，submitStage里面是提交task的细节 这里先判断几个集合：waitingStages,runningStages,failedStages中是否已经存在该stage，防止重复提交stage；通过getMissingParentStages，深度遍历地从后往前判断当前stage是否存在需要重新计算的stage，加入missing stages集合中。那么什么条件下才算是一个missing stage呢？我们来分析getMissingParentStages实现 可以发现判断当前rdd是否被cache了是通过DagScheduler.getCacheLocs获取缓存的location，观察到cacheLocs的数据结构是一个HashMap，key为rdd id，value为TaskLocation集合；虽说HashMap是个非线程安全集合，不过这里写操作线程安全通过加锁实现，所以说用HashMap实现倒也无妨 这个集合是在getCacheLocs中写入的 如果当前rdd本身没有设置storage level的话，也就无需查找缓存了，直接返回，否则通过blockManagerMaster.getLocations查找具体block对应的位置；blockManagerMaster上存储了所有Executor汇报上来的所有block位置元数据信息（后面有一小节来分析block的写入和上报过程） 接着，对于rdd如果没有显式缓存的情况，需要遍历rdd所有的依赖，对于是宽依赖的stage，调用getOrCreateShuffleMapStage获取或者创建mapStage，通过isAvailable判断所有output是否都已经准备好，isAvailable是通过查询mapOutputTracker已经注册的task output信息得到的，对于isAvailable为false的情况，说明output没有，或丢失。需要重新计算 123456789/** * Number of partitions that have shuffle outputs. * When this reaches [[numPartitions]], this map stage is ready. */ def numAvailableOutputs: Int = mapOutputTrackerMaster.getNumAvailableOutputs(shuffleDep.shuffleId) /** * Returns true if the map stage is ready, i.e. all partitions have shuffle outputs. */def isAvailable: Boolean = numAvailableOutputs == numPartitions submitMissingTasks解析 接下来分析submitStage中submitMissingTasks实现，这个方法是根据需要计算的stage来提交stage中的taskset。taskIdToLocation获取task要处理的数据的所在节点 然后根据task所属的stage类型来创建实际的task实例(ShuffleMapTask与ResultTask) 最后如果待计算的tasks集合不为空，则通过taskScheduler引用将task set提交到TaskScheduler中去调度 具体看TaskSchedulerImpl.submitTasks实现，首先会创建一个TaskSetManager。TaskSetManager实际调度TaskSet的的实现，跟踪并且根据数据优先级分发task，以及重试失败的task。因为一个stage同一时刻只能有至多一个TaskSetManager处于活跃状态，所以创建完TaskSetManager实例之后，需要将Stage中其他TaskSetManager实例标记为Zombie状态 随后，根据运行模式来判断要不要启动资源分配情况是否是饥饿状态的监控线程，最后调用CoarseGrainedSchedulerBackend.reviveOffers() 方法开始task调度 实际上是发了一个actor消息，直接看receive中针对ReviveOffers消息的处理方法(CoarseGrainedSchedulerBackend.makeOffers)实现 Scheduler.resourceOffers解析 先筛选出存活的executor，然后调用TaskSchedulerImpl.resourceOffers方法开始为每个TaskSet中的task分配具体执行节点 在分配前将那些之前被加入黑名单又重新生效的节点包括进来；然后打散workerOffer集合，防止task分配不均 获取shuffleOffer中节点剩余cpu以及slot(cores/CPU_PER_TASK(default 1))集合availableCpus，availableSlots 12val availableCpus = shuffledOffers.map(o =&gt; o.cores).toArrayval availableSlots = shuffledOffers.map(o =&gt; o.cores / CPUS_PER_TASK).sum 获取sortedTaskSets，在循环期间随时关注是否有新的executor加入 对sortedTaskSets集合的每个taskSet，如果taskSet是barrier模式，且可用slot小于taskSet中的task数量，则直接跳过分配；因为barrier模式中，所有的task都需要并行启动 对于非barrier模式的taskSet，根据taskSet中所有tasks的数据优先级调度task。如下图，myLocalityLevels是taskSet中所有tasks数据本地性优先级集合。由TaskSetManager. computeValidLocalityLevels方法计算得到 优先级从高到低依次为PROCESS_LOCAL, NODE_LOCAL, NO_PREF, RACK_LOCAL, ANY 也是按照这个顺序优先调度task 具体的调度见TaskSchedulerImpl.resourceOfferSingleTaskSet方法，里面实际依赖TaskSetManager.resourceOffer方法 首先对应的executor不能是被拉入黑名单，且当前TaskSetManager不能被标记为zombie 从taskSet中出队一个指定locality的 task（实现见TaskSetManager.dequeueTask）加入runningTasks结合中。对于非barrier模式的stage来说，只要有task被调度成功了就可以跑起来 这里再回过头看CoarseGrainedSchedulerBackend.makeOffers实现。当调用scheduler.resourceOffers之后如果有TaskDescription集合返回的的话，就可以调用launchTasks了 在launchTasks方法中，发送了LaunchTask消息，将序列化的Task信息通过rpc发送给Executor端（CoarseGrainedExecutorBackend实现） 看CoarseGrainedExecutorBackend.receive中对LaunchTask消息的处理逻辑 executor.launchTask中，实例化了TaskRunner，并将taskRunner提交到线程池中调度执行。具体的执行逻辑在下一个小节描述 ShuffleMapTask block写入过程分析 在上文中，我们分析到了TaskRunner。直接跳到TaskRunner里面的run方法实现 可以看到通过执行执行task.run方法拿到执行task后的结果，跟进去看结果是什么数据结构。 发现调用了runTask方法，查看接口的定义，发现有多个实现 看到了熟悉的ShuffleMapTask,ResultTask字眼，结果明朗了，其实就是根据宽窄依赖来调用具体的Task实现。ResultTask生成的result是func在rdd各个partition上的执行结果而ShuffleMapTask生成的result是shuffle 文件输出信息(MapStatus) 我们选ShuffleMapTask.runTask实现分析，返回的数据结构是MapStatus，MapStatus封装了task 所在的blockManager的信息（executorId+host+port）以及map task到每个reducer task的输出FileSegment的大小 来分析outputFile的实现细节，首先这里需要获取具体的ShuffleWriter实现 每个shuffleId对应的ShuffleHandle（也即是ShuffleWriter实现）由ShuffleManager统一管理，通过registerShuffle注册具体的ShuffleWriter 如图所示，目前spark中的shuffleWriter实现大概有三种，这里不详细比较，后续有专门文章分析Spark ShuffleWriter实现；选最常用的SortShuffleWriter.write 实现深入分析MapStatus产生过程 可以看到SortShuffleWriter对于每个mapTask只会产生一个output，通过indexfile start和end offset 来计算后续reduceTask获取数据的位置，这样做大大减小了output 文件数量。最终返回mapStatus结果 于是现在知道调用TaskRunner.run 根据task的类型不同返回的结果也是不同的，统一将其包装成DirectResult发送到driver上；这里根据实际得到的resultSize有不同的处理情况 如果result比较大，超过了maxDirectResultSize则会先把result存到本地的blockManager托管，storageLevel是内存+磁盘，然后把存储信息封装成IndirectTaskResult发送给driver 否则直接将序列化的result发送给driver。通过statusUpdate封装StatusUpdate事件将result发送给driver端处理 这里可以再分析一下result过大，blockManager是如何处理的细节。先看blockManager.doPutBytes，这里可以看到优先将result写入本地内存(LinkedHashMap实现)，如果内存不够（totalSize&gt;memory*spark.storage.memoryFraction），则会将result通过diskStore直接写入磁盘 看CoarseGrainedSchedulerBackend中具体处理StatusUpdate的实现，这里其实嵌套的比较多。按正常的路径首先会经过taskResultGetter.enqueueSuccessfulTask方法，在这里会将result反序列化（有DirectTaskResult与IndirectTaskResult之分），接着调用DagScheduler.handleSuccessfulTask。这里按照task类型不同有不同的处理方式： task是ResultTask的话，可以使用ResultHandler对result进行driver端计算（比如count()会对所有ResultTask的result做sum） 如果是ShuffleMapTask的话会注册mapOutputTracker，方便后续reduce task查询，然后submit 下一个stage Rdd Cache的过程 分析至此，我们似乎还没看到ShuffleMapTask cache的过程，只知道如果是ResultTask产生的数据会优先塞入内存（不够溢写磁盘）。那么我们在平时操作中调用的rdd.cache在哪个环节起作用了呢？其实我们分析ShuffleMapTask处理过程时，忽略了一块代码（ShuffleMapTask.runTask 中 rdd.iterator的调用） 12ShuffleMapTask.runTask=&gt; writer.write(rdd.iterator(partition, context).asInstanceOf[Iterator[_ &lt;: Product2[Any, Any]]]) 进入iterator实现 123Rdd.iterator=&gt; getOrCompute (if storageLevel != StorageLevel.NONE)=&gt; computeOrReadCheckPoint (if storageLevel == StorageLevel.NONE) 发现这里获取rdd的时候取决于当前rdd的存储方式，默认应该是StorageLevel.NONE，显示调cache的话将会走getOrCompute读取缓存逻辑，先看rdd不缓存的情况 123RDD.computeOrReadCheckpoint=&gt; 如果被checkpoint了，读checkpoint数据=&gt; 如果没有则直接重新计算 如果有checkpoint会获取，否则直接compute重新计算rdd。看getOrCompute实现 核心还是调用从blockManager中去拿缓存的rdd或者重新计算更新blockManager，在getLocalValues方法里面会根据当前的StorageLevel到memory或者diskStore里面去拿blockResult，发现diskStore.getBytes实现里面，diskManager.getFile方法正是SortShuffleWriter中获取output路径的底层实现 12DiskStore.getBytes=&gt; val file = diskManager.getFile(blockId.name) 12345SortShuffleWriter.write=&gt; val output = shuffleBlockResolver.getDataFile(dep.shuffleId, mapId)IndexShuffleBlockResolver.getDataFile =&gt;blockManager.diskBlockManager.getFile(ShuffleDataBlockId(shuffleId, mapId, NOOP_REDUCE_ID)) =&gt;DiskManager.getFile 经过一番分析，也能看出，cache主要适用于数据量不大的且反复使用的rdd；如果数据量过大，会发生频繁的数据溢写，还可能导致OOM的错误，收益大于成本，需要慎用 至此，shuffleMapTask从提交到输出到磁盘，以及DagScheduler如何处理Task Completion事件分析完了。后续文章中将分析ResultTask如何从mapOutputTracker拉取数据，以及如何计算的逻辑","link":"/2019/06/10/【Spark源码分析】Job提交执行过程详解/"},{"title":"【spark-tips】spark2.4.0触发的executor内存溢出排查","text":"版本升级背景spark 2.4.0 最近刚发版，\b新增了很多\b令人振奋的特性\b。由于\b本司目前使用的是spark 2.3.0\b版本，本没打算\b这么快升级\b到2.4.0。无奈最近\b\b排查出的两个大bug迫使我们\b只能对\bspark进行\b升级\b。排查的\b两个bug如下：\b \bspark2.3.0 bug导致driver跑一段时间内存溢出，\b经过dump下来的堆转储文件发现\b\b\b占绝大内存的对象是\bspark自身的ElementTrackingStore\b。这是统计\b任务\b运行时资源占用情况的类，在每一个批次处理完之后都没有释放，导致driver\b内存溢出 详情参考文章：导致driver OOM的一个SparkPlanGraphWrapper源码的bug spark streaming 2.3.0 + kafka 0.8.2.1 + zk管理offset 每次\b重启，\b会导致\boffsetrange的\b左区间莫名向右移动若干offset\b size，\b导致\b每个批次通过offsetrange从kafka消费的数据普遍\b\b\b会\b丢失部分\b数据\b，\b具体问题还在通过源码定位中\b 第一个bug\b\b在\bspark 2.4.0中得到\b解决（参考issue）\b\b\b，\b于是对\bspark进行了升级。所幸spark升级对spark on yarn这种运行方式来说非常解耦，\b\b只需要定义spark.jars依赖就行，yarn \bnodemanager会对依赖包进行下载\b。 \b\b遇到的问题问题描述spark 版本升级之后，当天对在线任务观察\b，运行平稳，上一节提到的bug也修复了\b\b；但是第二天离线任务\b的运行却出现了问题\b：\b部分\b\b\b\b\b\b\b离线任务在做\b聚合运算的时候出现executor\b 集体内存溢出，任务执行失败\b \b\b\b问题排查 查看日志发现是内存溢出导致executor触发钩子异常退出 进一步发现在某个计算步骤，需要读入上一个步骤写入hdfs的数据，每个task处理的数据量比较大，且都放到了内存中（导火线） 接着因为要做各种聚合运算（reduceby, groupgy, join…）execution 的内存也不断增大，濒临内存的限制边缘 8G * 0.6(spark.memory.fraction) =4.8G，很容易就会来不及spill到磁盘，导致内存溢出 于是\b基本可以得到问题原因：从读入hdfs的源头去排查，为什么导致一个task处理的数据量过大；发现hdfs中上一步save到hdfs中的每一个part都是将近500M大小的parquet+snappy 压缩文件，而这种格式无法切分，导致一个map task只能对这400多M的文件照单全收，而由于我应用申请的配置是 8 cores 8 mem / executor 导致8个task同时读入大文件到executor jvm中，最终jvm报内存溢出异常 \b\b\b解决方案\b 限制executor 并行度，将cores 调小，内存适当调大 由于上一步写hdfs的操作并行度太小（只有40），重新调整并行度，让输出的每个part文件减小","link":"/2019/01/12/【spark-tips】spark2-4-0触发的executor内存溢出排查/"},{"title":"手动封装HbaseTemplate mapper类","text":"前言最近因为业务关系，用到了Hbase，因为用的是Spring boot框架 ，所以自然而然就用到了spring封装的HbaseTemplate工具类。然而HbaseTemplate封装的代码实在比较糟糕，出了一些基本的CRUD操作之外并没有给我们提供太多便利之处。先来看看痛处： 痛处一及改进 我们先来看看HabaseTemplate最基本的查询操作(以下只是demo演示)： 1234567891011121314151617181920class UserInfo{ string name; string password;}public void putUserInfo(UserInfo userInfo) { hBaseTemplate.execute(TABLE_NAME, (table) -&gt; { //根据rowKey定义一个put对象，可用作插入和更新 Put put = new Put(Bytes.toBytes(rowKey)); //name是否为空 if(userInfo.name!=null){ put.addColumn(COLUMN_FAMILY_NAME.getBytes(), Bytes.toBytes(COLUMN_RAW_DATA)，Bytes.toBytes(userInfo.name)); } //password是否为空 if(userInfo.password!=null){ put.addColumn(COLUMN_FAMILY_NAME.getBytes(), Bytes.toBytes(COLUMN_RAW_DATA)，Bytes.toBytes(userInfo.password)); } table.put(put); return true; }); } 相信大家也看出来了，如果待插入的对象有很多字段呢？还要逐个写if语句来判读非空么？这明显使得代码非常地不简洁。于是，个人封装了一个插入更新模版类（其实只是简单的对Put对象的一个扩展）： 123456789101112131415161718//继承并扩展Put对象public class PutExtension extends Put { String columnFamilyName = &quot;demo&quot;; public PutExtension(String columnFamilyName, byte[] row) { super(row); this.columnFamilyName = columnFamilyName; } public PutExtension build(String paramName, Object param) throws IOException { if (param != null) { this.addColumn(columnFamilyName.getBytes(), paramName.getBytes(), Bytes.toBytes(param.toString())); } return this; }} 封装之后，之前累赘的查询操作可以变得如下所示： 123456789//然后操作如下hBaseTemplate.execute(TABLE_NAME, (table) -&gt; { PutExtension putExtension = new PutExtension(familyName, rowKey.getBytes()); putExtension.build(&quot;name&quot;,userInfo.name) .build(&quot;password&quot;, userInfo.password); table.put(putExtension); return true; }) 其实这也就是一个简单的封装，只不过把冗余的逻辑判断给丢出去了而已。 痛处二及改进 在HbaseTemplate中，根据rowKey查询出来的原始数据是字节数组，我们要将字节数组转化成业务逻辑中希望的java bean需要做很多重复的判断匹配逻辑，以下是没改进前的代码： 12345678910111213141516 public UserInfo getUserInfo() { return (UserInfo) hBaseTemplate.get(TABLE_NAME, rowKey, familyName,(result, i) -&gt;{ UserInfo userInfo=new UserInfo() //重复逻辑一bytes[] nameBytes=result.getValue(familyName.getBytes(), &quot;name&quot;.getBytes()));if(nameBytes!=null){ userInfo.setName(Bytes.toString(nameBytes));}//重复逻辑二bytes[] passwordBytes=result.getValue(familyName.getBytes(), &quot;password&quot;.getBytes()));if(passwordBytes!=null){ userInfo.setPassword(Bytes.toString(passwordBytes));} });} 可以看出，这样做的缺点是一旦java bean的字段一多，重复的非空判断逻辑也会增多，从而使得代码变得十分累赘且不可维护。于是我参考Spring JDBC的RowMapper的封装，利用了Spring框架自带的反射工具beanUtils和beanWrapper，自己实现了如下封装： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class HBaseResultBuilder&lt;T&gt; { private Class&lt;T&gt; mappedClass; private Map&lt;String, PropertyDescriptor&gt; mappedFields; private Set&lt;String&gt; mappedProperties; HashSet populatedProperties; private BeanWrapper beanWrapper; private Result result; private String columnFamilyName; private T t; //接受一些列参数并实例化要返回的结果对象 public HBaseResultBuilder(String columnFamilyName, Result result, Class&lt;T&gt; clazz) { this.columnFamilyName = columnFamilyName; this.result = result; this.mappedClass = clazz; mappedFields = new HashMap&lt;&gt;(); mappedProperties = new HashSet&lt;&gt;(); populatedProperties = new HashSet&lt;&gt;(); this.t = BeanUtils.instantiate(clazz); PropertyDescriptor[] pds = BeanUtils.getPropertyDescriptors(mappedClass); PropertyDescriptor[] var3 = pds; int var4 = pds.length; for (int var5 = 0; var5 &lt; var4; ++var5) { PropertyDescriptor pd = var3[var5]; if (pd.getWriteMethod() != null) { this.mappedFields.put(this.lowerCaseName(pd.getName()), pd); String underscoredName = this.underscoreName(pd.getName()); if (!this.lowerCaseName(pd.getName()).equals(underscoredName)) { this.mappedFields.put(underscoredName, pd); } this.mappedProperties.add(pd.getName()); } } beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(t); } private String underscoreName(String name) { if (!StringUtils.hasLength(name)) { return &quot;&quot;; } else { StringBuilder result = new StringBuilder(); result.append(this.lowerCaseName(name.substring(0, 1))); for (int i = 1; i &lt; name.length(); ++i) { String s = name.substring(i, i + 1); String slc = this.lowerCaseName(s); if (!s.equals(slc)) { result.append(&quot;_&quot;).append(slc); } else { result.append(s); } } return result.toString(); } } private String lowerCaseName(String name) { return name.toLowerCase(Locale.US); } //使用时根据要解析的字段频繁调用此方法即可，仿造java8 流式操作 public HBaseResultBuilder build(String columnName) { byte[] value = result.getValue(columnFamilyName.getBytes(), columnName.getBytes()); if (value == null || value.length == 0) { return this; } else { String field = this.lowerCaseName(columnName.replaceAll(&quot; &quot;, &quot;&quot;)); PropertyDescriptor pd = this.mappedFields.get(field); if (pd == null) { log.error(&quot;HBaseResultBuilder error: can not find property: &quot; + field); } else { beanWrapper.setPropertyValue(pd.getName(), Bytes.toString(value)); populatedProperties.add(pd.getName()); } } return this; } //伪造Java8的即视感，“流最后的终端操作“。 public T fetch() { //只要有一个属性被解析出来就返回结果对象，毕竟hbase存的是稀疏数据，不一定全量 if (CollectionUtils.isNotEmpty(populatedProperties)) { return this.t; } else { return null; } } 通过利用反射的基本原理，我们可以通过结果数据构造出我们需要的java bean。最后我们的调用过程可以简化成如下： 12345public UserInfo getUserInfo() { return (UserInfo) hBaseTemplate.get(TABLE_NAME, rowKey, familyName, (result, i) -&gt; new HBaseResultBuilder&lt;&gt;(familyName, result, UserInfo.class).build(&quot;name&quot;).build(&quot;password&quot;).fetch()); } 成功！！！是不是代码整洁多了，其实也就是将一些复杂的逻辑给抽出去了，正好最近看了Java8实战，从而萌生的一点小想法。","link":"/2016/10/09/手动封装HbaseTemplate-mapper类/"},{"title":"类函数式的sql生成工具类的封装","text":"前言自从正式工作以来，公司一直用的是Spring 原生的JDBC Template以及在其上封装的扩展的一些小工具， 而摈弃了Mybatis、ibatis等ORM框架。总的来说，这种做法对于开发效率来说提高不少，由于真正的查库操作不会直接穿透到Mysql，所以抗压性也没有太大的问题。 问题虽说直接使用原生的JDBC Template比较方便，但是构造参数条件，以及生成查询语句过于简单粗暴，导致代码不简洁，复用度也不高。举个例子，根据特定的条件查询用户：1234567891011121314151617181920212223StringBuffer sqlBuilder = new StringBuffer(&quot;select * from user where &quot;);Map&lt;String, Object&gt; paramsMap = new HashMap&lt;&gt;();if (userId != null) { sqlBuilder.append(&quot;user_id=:userId&quot;); paramsMap.put(&quot;userId&quot;, userId);}if (batchNumber != null) { sqlBuilder.append(&quot;batch_number=:batchNumber&quot;); paramsMap.put(&quot;batchNumber&quot;, batchNumber);}if (status != null) { sqlBuilder.append(&quot;status=:status&quot;); paramsMap.put(&quot;stats&quot;, status);}if (page &gt; 0 &amp;&amp; count &gt; 0) { sqlBuilder.append(&quot; limit &quot;) .append(page * count) .append(&quot;, &quot;) .append(count);}//生成sql语句sqlBuilder.toString(); 可以看到上面的代码大部分在重复同样的逻辑，20多行的代码仅仅只是在构造sql语句以及收集参数，而且这些重复的代码将充斥项目所有的DAO层，导致代码非常不整洁。维护困难。 sql生成工具类封装秉承着恶心重复的代码要重构抽象的态度，对sql生成的步骤，做了一次简单的封装： 先介绍接口12345678910111213141516171819public interface Order { Where desc(); Where asc(); }public interface Where { Where ifPresent(Object value, String sql); Order orderBy(String field); Where limit(int begin, int end); Where in(List&lt;Object&gt; values, String sql); String sql();//构造的sql Map&lt;String, Object&gt; params();//参数值 } 根据sql语句的特点，抽出子句部分的生成单独构造，涵盖Where, in(暂未实现)，limit 以及 order 排序规则。 来看看接口的实现将所有相关的类通过内部静态类封装入SqlWhereBuffer类中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class SqlWhereBuffer { public static SqlWhereBuffer.Where builder() { return new Builder(); } static class Builder implements SqlWhereBuffer.Order, SqlWhereBuffer.Where { private List&lt;String&gt; sql = new ArrayList&lt;&gt;(); private Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); private String orderBy = &quot; &quot;; private String limit = &quot; &quot;; private String in = &quot; &quot;; private List&lt;SqlMapperPlugin&gt; sqlMapperPlugins; public Builder() { //添加基本类型默认的插件 sqlMapperPlugins = Lists.newArrayList(); this.mapperPlugins(SqlMapperPlugin.EnumSqlPlugin) .mapperPlugins(SqlMapperPlugin.BooleanSqlPlugin); } public Builder mapperPlugins(SqlMapperPlugin sqlMapperPlugin) { if (CollectionUtils.isEmpty(sqlMapperPlugins)) { sqlMapperPlugins = Lists.newArrayList(); } sqlMapperPlugins.add(sqlMapperPlugin); return this; } @Override public SqlWhereBuffer.Where ifPresent(Object value, String sql) { Optional.ofNullable(value) .ifPresent(val -&gt; { this.sql.add(sql); Pattern pattern = Pattern.compile(&quot;:([a-z,A-Z,\\\\w,_]*)&quot;); //固定的sql参数模式 Matcher matcher = pattern.matcher(sql); if (!matcher.find()) { throw new IllegalArgumentException(sql + &quot; don&apos;t include :name&quot;); } Optional&lt;SqlMapperPlugin&gt; mapper = sqlMapperPlugins.stream() .filter(sqlMapperPlugin -&gt; sqlMapperPlugin.test(val)) .findFirst(); if (mapper.isPresent()) { params.putAll(mapper.get() .getParams(matcher.group(1), value)); } else { //匹配不到走默认的插件 params.put(matcher.group(1), value); } }); return this; } @Override public SqlWhereBuffer.Order orderBy(String field) { orderBy += &quot;ORDER BY &quot; + field; return this; } @Override public SqlWhereBuffer.Where limit(int offset, int count) { limit += &quot;limit &quot; + offset + &quot;,&quot; + count; return this; } @Override public String sql() { if (sql.isEmpty() || params.isEmpty()) { return &quot;&quot;; } else { return &quot; WHERE &quot; + sql.stream() .collect(Collectors.joining(&quot; AND &quot;)) + orderBy + limit; } } @Override public ImmutableMap&lt;String, Object&gt; params() { return ImmutableMap.copyOf(params); } @Override public SqlWhereBuffer.Where desc() { orderBy += &quot; DESC&quot;; return this; } @Override public SqlWhereBuffer.Where asc() { return this; } }} 静态类Builder实现了SqlWhereBuffer.Order, SqlWhereBuffer.Where这俩个接口的方法。ifPresent是主入口。流程如下：1231、在ifPresent中参数先进行非空判断，如果是空则直接过滤掉；2、然后通过一个正则表达式（**:([a-z,A-Z,\\\\w,_]*)**）对参数sql进行规则校验，如果不符合也将过滤；3、最后value通过一系列的自定义的注册插件的匹配判断，得出sql以及params。 关于自定义插件，本没想做这么复杂，然而在实际的使用过程中，JDBC Template对Enum的支持不够…不过想也是，Enum大多是自定义的，没法做到一套约定的接口满足所有需求。于是封装了一个插件类，方便以后扩展： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static class SqlMapperPlugin { private final Predicate&lt;Object&gt; predicate; private final ParamValue paramValue; private SqlMapperPlugin(Predicate&lt;Object&gt; predicate, ParamValue paramValue) { this.predicate = predicate; this.paramValue = paramValue; } //定义枚举插件 static SqlMapperPlugin EnumSqlPlugin = of(Enum.class).paramValue((value, sql) -&gt; Collections.singletonMap(sql, getEnumValue(value)) ); //定义Boolean插件 static SqlMapperPlugin BooleanSqlPlugin = of(Boolean.class).paramValue((value, sql) -&gt; Collections.singletonMap(sql, ((boolean) value) ? 1 : 0) ); public static SqlMapperPlugin.MapperPluginsBuilder of(Predicate&lt;Object&gt; predicate) { return new MapperPluginsBuilder(predicate); } public static SqlMapperPlugin.MapperPluginsBuilder of(Class clazz) { return of((pd) -&gt; { return clazz.isAssignableFrom(pd.getClass()); }); } boolean test(Object pd) { return this.predicate.test(pd); } Map&lt;String, Object&gt; getParams(String sql, Object value) { return paramValue.getParams(value, sql); } public static class MapperPluginsBuilder { Predicate&lt;Object&gt; predicate; public MapperPluginsBuilder(Predicate&lt;Object&gt; predicate) { this.predicate = predicate; } public SqlMapperPlugin paramValue(SqlMapperPlugin.ParamValue paramValue) { return new SqlMapperPlugin(this.predicate, paramValue); } } @FunctionalInterface public interface ParamValue { Map&lt;String, Object&gt; getParams(Object var1, String var2); } } public static String getEnumValue(Object value) { Method method; try { method = value.getClass() .getMethod(&quot;name&quot;); return String.valueOf(method.invoke(value)); } catch (NoSuchMethodException e) { throw new RuntimeException(&quot;NoSuchMethodException&quot;, e); } catch (IllegalAccessException e) { throw new RuntimeException(&quot;IllegalAccessException&quot;, e); } catch (InvocationTargetException e) { throw new RuntimeException(&quot;InvocationTargetException&quot;, e); } } 主要用到了java8中新增的Predicate接口，用于判断value的Class类型，以及自己定义了一个FunctionalInterface 用于获取查询参数。这里先实现了EnumSqlPlugin，BooleanSqlPlugin俩个插件，之后有其他类型的需求，也可以通过类似的形式加入。对EnumSqlPlugin实现进行解释：1234//定义枚举插件 static SqlMapperPlugin EnumSqlPlugin = of(Enum.class).paramValue((value, sql) -&gt; Collections.singletonMap(sql, getEnumValue(value)) ); 通过定义的of方法定义赋值Predicate,作为判断value是否为指定类型的方法。12345public static SqlMapperPlugin.MapperPluginsBuilder of(Class clazz) { return of((pd) -&gt; { return clazz.isAssignableFrom(pd.getClass()); }); } of方法返回了MapperPluginsBuilder类，紧接着定义函数式接口paramValue的实现：1Collections.singletonMap(sql, getEnumValue(value)) 最后返回EnumSqlPlugin对应的新实例:1return new SqlMapperPlugin(this.predicate, paramValue); 使用的时候，在Builder的构造函数中注入默认的插件即可，如日后有扩展，也可调用mapperPlugins方法动态加入：123456789101112131415 private List&lt;SqlMapperPlugin&gt; sqlMapperPlugins; public Builder() { //添加基本类型默认的插件 sqlMapperPlugins = Lists.newArrayList(); this.mapperPlugins(SqlMapperPlugin.EnumSqlPlugin) .mapperPlugins(SqlMapperPlugin.BooleanSqlPlugin); }public Builder mapperPlugins(SqlMapperPlugin sqlMapperPlugin) { if (CollectionUtils.isEmpty(sqlMapperPlugins)) { sqlMapperPlugins = Lists.newArrayList(); } sqlMapperPlugins.add(sqlMapperPlugin); return this; } 工具的使用现在，我们可以使用封装好的工具了:1234567SqlWhereBuffer.Where where = SqlWhereBuffer.builder() .ifPresent(batchNumber, &quot;batch_number=:batchNumber&quot;) .ifPresent(status, &quot;upload_result=:uploadResult&quot;) .ifPresent(userId, &quot;user_id=:userId&quot;) .limit(page * count, count) .orderBy(&quot;id&quot;) .asc(); 这样，代码变得整洁多了，也符合java8函数式风格的效果。","link":"/2017/01/30/类函数式的sql生成工具类的封装/"},{"title":"记一次失败的debug经历","text":"昨天使用spring aop的事务注解出现了业务中主动抛出异常却无法回滚脏数据的情形，然后崩溃的debug了一天，最后猛然发现不能通过this去掉加了增强的方法否则将拿不到代理对象。归根结底还是自己不甚理解事务实现的其中原理，才导致了bug的出现而不自知。 问题还原如果对java如何实现底层的事务机制不太熟悉的话可以看看java事务处理系列文章 自己手动实现事务处理。 来看看我调用事务的错误示例代码： 1234567891011121314151617181920212223242526@Componentclass DemoService{ public List&lt;ExpressExportRow&gt; notExpressedRecord() { ... changeOrderStatusToExpressing(); ... return expressExportRowList; } @Transactional(value = &quot;apolloTransactionManager&quot;,rollbackFor = Exception.class) public boolean changeOrderStatusToExpressing(Long orderId, Long orderGroupId) { boolean isSuccess = updateExpressRecordStatus(orderId, orderGroupId, OrderStatus.EXPRESSING.getValue()); if (isSuccess) { isSuccess = apolloService.updateOrderStatus(orderId, orderGroupId, OrderStatus.EXPRESSING.getValue()); } if (!isSuccess) { throw new RuntimeException(&quot;更改订单状态失败,订单号为: &quot; + orderId); } return isSuccess; } } 首先DemoService通过@Component注解在容器加载的时候是确实注入进去了， 由于AOP 结合了IOC 的一部分功能（ProxyFactoryBean中实现）也就是在容器启动的过程中跟着在Demoservice封装成了aop代理对象保存在容器中。上面的代码错在直接在service 里面通过this引用去调增强的方法，结果导致方法不会应用相应的增强处理。来看看aop的处理流程图 解决办法 清楚了导出bug的原因和spring事务的基本原理之后，相应的解决办法就很简单，即我们只需要确保我们拿到的demoservice实例是通过容器注入进来的即可，于是可以以下解法：123456789@Componentclass Resource{@Resource DemoServcie demoService; public changeStatus(){ demoService.changeOrderStatusToExpressing(...); } } 通过@Resource注入进来的demoService必然式容器中的已经加载配置好的代理对象。这样就能成功应用事务增强。 或者也可以通过后置器BeanPostProcessor将自身注入进来，即在自身的service里完成调用123456789101112@Component public class DemoService implements BeanPostProcessor { public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return bean; } public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if(bean instanceof BeanSelfAware) { ((BeanSelfAware) bean).setSelf(bean); } return bean; } } 但是这样会出现循环依赖问题。所以第一种方法最为合适。 总结通过这次的低级bug再一次发现自己对源码不够深入，虽然前前后后看过了不少spring源码，但是也没有立即发现bug的存在，各方面理解还有待提高。继续努力吧","link":"/2017/01/19/记一次失败的debug经历/"}],"tags":[{"name":"HBase","slug":"HBase","link":"/tags/HBase/"},{"name":"BigData","slug":"BigData","link":"/tags/BigData/"},{"name":"架构","slug":"架构","link":"/tags/架构/"},{"name":"Hbase","slug":"Hbase","link":"/tags/Hbase/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Hadoop","slug":"Hadoop","link":"/tags/Hadoop/"},{"name":"Yarn","slug":"Yarn","link":"/tags/Yarn/"},{"name":"InnoDB","slug":"InnoDB","link":"/tags/InnoDB/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"成长","slug":"成长","link":"/tags/成长/"},{"name":"读书","slug":"读书","link":"/tags/读书/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"kylin","slug":"kylin","link":"/tags/kylin/"},{"name":"infrastructure","slug":"infrastructure","link":"/tags/infrastructure/"},{"name":"data","slug":"data","link":"/tags/data/"},{"name":"分布式","slug":"分布式","link":"/tags/分布式/"},{"name":"大数据","slug":"大数据","link":"/tags/大数据/"},{"name":"paper","slug":"paper","link":"/tags/paper/"},{"name":"学习","slug":"学习","link":"/tags/学习/"},{"name":"Spark","slug":"Spark","link":"/tags/Spark/"},{"name":"多线程","slug":"多线程","link":"/tags/多线程/"},{"name":"ReentrantLock","slug":"ReentrantLock","link":"/tags/ReentrantLock/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"ioc","slug":"ioc","link":"/tags/ioc/"},{"name":"aop","slug":"aop","link":"/tags/aop/"},{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"Kylin","slug":"Kylin","link":"/tags/Kylin/"},{"name":"kylin - Java - 源码","slug":"kylin-Java-源码","link":"/tags/kylin-Java-源码/"},{"name":"事务处理","slug":"事务处理","link":"/tags/事务处理/"},{"name":"superset","slug":"superset","link":"/tags/superset/"},{"name":"二次开发","slug":"二次开发","link":"/tags/二次开发/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Crawler","slug":"Crawler","link":"/tags/Crawler/"},{"name":"spark","slug":"spark","link":"/tags/spark/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"java8","slug":"java8","link":"/tags/java8/"},{"name":"sqlGenerator","slug":"sqlGenerator","link":"/tags/sqlGenerator/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/函数式编程/"}],"categories":[]}