<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>JVM知识总结 | CHAO LI's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM知识总结</h1><a id="logo" href="/.">CHAO LI's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JVM知识总结</h1><div class="post-meta">Mar 26, 2018<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2018/03/26/JVM知识总结/" href="/2018/03/26/JVM知识总结/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h2 id="HotSpot-JVM-Architecture"><a href="#HotSpot-JVM-Architecture" class="headerlink" title="HotSpot JVM Architecture"></a>HotSpot JVM Architecture</h2><p><img src="http://imgs.wanhb.cn/hotspotjvm-1.png" alt="HotSpot JVM Architecture"></p>
<h2 id="JVM运行时数据区域"><a href="#JVM运行时数据区域" class="headerlink" title="JVM运行时数据区域"></a>JVM运行时数据区域</h2><ul>
<li>程序计数器 (program counter registers)</li>
<li>java虚拟机栈：线程私有，生命周期与线程相同。每个方法在运行期间都会创建一个栈帧用于存储局部变量、操作数栈、动态链接、方法出口等信息。<ul>
<li>经常有人把java内存区分为堆内存和栈内存，这种分法比较粗糙。其中所指的栈就是虚拟机栈。或者说是虚拟机栈中局部变量表部分。</li>
<li>局部变量表存放了编译期间可知的各种基本数据类型(boolean byte char,…)、对象引用和returnAddress类型</li>
</ul>
</li>
<li>本地方法栈 为虚拟机提供Native方法服务</li>
<li>java堆： 是JVM所管理的内存中最大的一块。是被所有线程共享的一块内存区域。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配（随着JIT编译器的发展与逃逸分析技术的成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，导致在堆上分配对象不是那么绝对）。</li>
<li><p>方法区： 与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
<ul>
<li>对于HotSpot熟悉的人员来说，很多人更愿意把方法区称为“永久代”本质上并不等价，仅仅是因为HotSpot虚拟机设计团队选择把GC分代收集扩展到方法区，或者说使用永久代来实现方法区而已。但是这种实现方式更容易遇到内存溢出的问题，现在HotSpot虚拟机也放弃永久代逐步改为采用Native Memory来实现方法区的规划了（如：把原本放在永久代的字符串常量池移除）</li>
<li>JVM规范对方法区限制非常宽松，但也不是永久存在，还是会存在类的卸载，常量池的回收问题</li>
</ul>
</li>
<li><p>运行时常量池：方法区的一部分，Class文件中出了有类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<ul>
<li>运行期间也可以将新的常量放入池中，如String类的intern()方法（目前被废除）</li>
</ul>
</li>
<li><p>直接内存(Direct Memory)：不是JVM规范定义的内存区域，但是也被频繁使用，而且也可能导致内存溢出异常。在JDK1.4新加入了NIO 类，引入了一种基于通道与缓冲区Buffer的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。显然，这部分内存不会受到Java堆大小的限制，但是还是受到本机总内存的限制</p>
</li>
</ul>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><h3 id="分配实例内存的时候可能会出现并发问题的解决方案："><a href="#分配实例内存的时候可能会出现并发问题的解决方案：" class="headerlink" title="分配实例内存的时候可能会出现并发问题的解决方案："></a>分配实例内存的时候可能会出现并发问题的解决方案：</h3><ul>
<li>对分配内存空间的动作进行同步处理———实际上JVM采用CAS配上失败重试的方式保证更新操作的原子性</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存称为本地线程分配缓冲（TLAB）。哪个线程要分配内存就在哪个TLAB上分配，只有TLAB用完并分配新的的时候才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+／-UseTLAB参数来设定</li>
</ul>
<h3 id="GC-算法："><a href="#GC-算法：" class="headerlink" title="GC 算法："></a>GC 算法：</h3><ul>
<li>可达性分析算法（不算GC算法，仅仅是思想）:</li>
<li>GC Roots的对象包括下面几种：<ul>
<li>1、虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>2、方法区中类静态属性引用的对象</li>
<li>3、方法区中常量引用的对象</li>
<li>4、本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
</li>
</ul>
<ul>
<li>引用计数法：</li>
<li>标记清除（Mark-Sweep)：</li>
<li>复制算法 (Copying)</li>
<li>标记-压缩算法 (Mark-Compact)</li>
<li>增量算法 (Incremental Collecting)</li>
</ul>
<h3 id="JVM-垃圾回收器分类"><a href="#JVM-垃圾回收器分类" class="headerlink" title="JVM 垃圾回收器分类"></a>JVM 垃圾回收器分类</h3><ul>
<li>Young generation:<ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
</ul>
</li>
<li>Tenured generation:<ul>
<li>CMS</li>
<li>Parallel Old</li>
<li>Serial Old</li>
</ul>
</li>
<li><p>All</p>
<ul>
<li>G1</li>
</ul>
</li>
<li><p>新生代串行收集器（GC日志中:Default New Generation）： 第一，它仅仅使用单线程进行垃圾回收；第二，它独占式的垃圾回收。复制算法</p>
</li>
<li>老年代串行收集器： 标记-压缩算法。</li>
<li>-XX:+UseParNewGC 参数设置，表示新生代使用并行收集器，老年代使用串行收集器</li>
<li>-XX:+UseParallelGC 参数设置，表示新生代和老年代均使用并行回收收集器</li>
<li>新生代并行回收 (Parallel Scavenge) 收集器，对应的GC日志中新生代的名称为PSYoungGen</li>
<li>老年代并行回收收集器</li>
<li><p>CMS 收集器: 它使用的是标记-清除算法，同时它又是一个使用多线程并发回收的垃圾收集器。</p>
<ul>
<li>主要步骤有：初始标记、并发标记、重新标记、并发清除和并发重置。其中初始标记和重新标记是独占系统资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。因此，从整体上来说，CMS 收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。</li>
<li>标记-清除算法将会造成大量内存碎片，离散的可用空间无法分配较大的对象。在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存，这种现象对系统性能是相当不利的，为了解决这个问题，CMS 收集器还提供了几个用于内存压缩整理的算法。</li>
<li>-XX:+UseCMSCompactAtFullCollection 参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。</li>
<li><p>-XX:CMSFullGCsBeforeCompaction 参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。使用CMS收集器后，默认新老年代分别使用ParNew和CMS收集器进行垃圾回收</p>
</li>
<li><p>G1 收集器 (Garbage First) : 与 CMS 收集器相比，G1 收集器是基于标记-压缩算法的</p>
<ul>
<li>G1 收集器还可以进行非常精确的停顿控制。它可以让开发人员指定当停顿时长为 M 时，垃圾回收时间不超过 N。</li>
<li>使用参数-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC 来启用 G1 回收器，设置 G1 回收器的目标停顿时间：-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JVM内存分配情况"><a href="#JVM内存分配情况" class="headerlink" title="JVM内存分配情况"></a>JVM内存分配情况</h3><ul>
<li><a href="http://trustmeiamadeveloper.com/2016/03/18/where-is-my-memory-java/" target="_blank" rel="noopener">参考链接</a></li>
<li>容器内存 = 文件缓存 + Java 应用内存<br>Java 应用内存 = 堆内存 + MetaSpace + 堆外内存<br>堆外内存 = 线程栈 + 缓冲区（例如 NIO）等等</li>
<li>所以按照目前的经验来看，堆内存至少应该小于 2/3 的容器内存（？）</li>
</ul>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><ul>
<li>定义<ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）</li>
</ul>
</li>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>
<li>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>
</ul>
<h3 id="对象转入老年代的情况："><a href="#对象转入老年代的情况：" class="headerlink" title="对象转入老年代的情况："></a>对象转入老年代的情况：</h3><ul>
<li>1、经过了正常的MinoGC过程数次之后（可以通过-XX:MaxTenuringThreshold配置）晋升到老年代</li>
<li>2、大于一定值的对象直接进入老年代（ 通过-XX:PretenureSizeThreshold配置）</li>
<li>3、空间分配担保：MinorGC之前，jvm会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么MinorGC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则尝试一次MinorGC，尽管会有风险，如果小于。或者HandlePromotionFailure设置不允许冒险，那这时候也需要改为进行一次Full GC.</li>
<li>因为新生代是使用复制收集算法，但是为了内存利用率，只使用其中一个Survivor空间作为轮换备份，因此当出现大量对象在MinorGC后仍然存活。就需要老年代进行分配担保。把Survivor无法容纳的对象直接进入老年代。前提是老年代还有容纳这些对象的剩余空间，一共有多少对象会存活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间比较，决定是否进行FullGc来让老年代腾出空间。如果允许担保失败(HandlePromotionFailure)并且老年代最大可用连续空间大于历次晋升到老年代对象的平均大小，将尝试进行一次MinorGC，如果小于或者不允许担保失败则会进行一次 FullGC，所以一般会将HandlePromotionFailure打开，以防止FullGC频率过高</li>
</ul>
<h3 id="一些JVM工具"><a href="#一些JVM工具" class="headerlink" title="一些JVM工具"></a>一些JVM工具</h3><ul>
<li><p>jps : 虚拟机进程状况工具</p>
<ul>
<li><a href="http://www.importnew.com/?p=18132&amp;preview=true" target="_blank" rel="noopener">详细参考文章</a></li>
<li>-q 只输出LVMID,省略主类名称</li>
<li>-m 输出虚拟机进程启动时传递给主类main()函数的参数</li>
<li>-l 输出主类的全名，如果进程执行的是Jar包，输出jar路径</li>
<li>-v 输出虚拟机进程启动时JVM参数</li>
</ul>
</li>
<li><p>jstat: 虚拟机统计信息监视工具，可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p>
<ul>
<li><a href="http://www.importnew.com/18202.html" target="_blank" rel="noopener">详细参考文章</a></li>
<li>-class pid 监视类装载、卸载数量、总空间以及类装载所耗费时间</li>
<li>-gc pid 监视Java堆状况，包括Eden区，两个Survivor区、老年代、永久代容量、已用空间、GC时间合计等信息</li>
<li>-gccapacity pid 可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小</li>
<li>-gcnew pid 年轻代对象的信息</li>
<li>-gcold 年老代对象信息</li>
</ul>
</li>
<li><p>jinfo: java配置信息工具</p>
<ul>
<li>实时地查看和调整虚拟机各项参数，未被显示指定的参数的系统默认值</li>
<li>jinfo -flag CMSInitiatingOccupancyFraction 14444</li>
</ul>
</li>
<li><p>jmap java内存映象工具 用于生成堆转储快照（一般称为heapdump或dump文件）如果不使用jmap命令，还可以使用暴力的手段如：-XX:+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在 OOM异常之后自动生成dump文件。通过-XX:+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件。</p>
<ul>
<li><a href="http://www.importnew.com/18196.html" target="_blank" rel="noopener">详细参考文章</a></li>
<li>jmap 的作用不仅仅是为了获取dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。</li>
<li>-dump 生成java堆转储快照 -dump:[live, ]format=b, file=,其中live子参数说明是否只dump出存活的对象</li>
<li>-heap 显示java堆详细信息，如使用那种回收器、参数配置、分代状况等／</li>
<li>-histo 显示堆中对象的统计信息，包括类，实例数量，合计容量</li>
<li>-F 当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。</li>
<li>例子：jmap -dump:format=b,file=exlipse.bin 3500 (3500 是通过jps命令查询到的LVMID)</li>
</ul>
</li>
<li><p>jhat: 虚拟机堆转储快照分析工具</p>
<ul>
<li>sun JDK提供jhat 与jmap 搭配使用，来分析jmap 生成的堆转储快照。jhat内置了一个微型的Http/Html服务器，生成dump文件的分析结果后，可以在浏览器中查看之后可以用visualVM来分析dump文件</li>
</ul>
</li>
<li><p>jstack: java堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环</p>
<ul>
<li><a href="http://www.importnew.com/18176.html" target="_blank" rel="noopener">详细参考文章</a></li>
</ul>
</li>
</ul>
<h3 id="垃圾收集器参数总结："><a href="#垃圾收集器参数总结：" class="headerlink" title="垃圾收集器参数总结："></a>垃圾收集器参数总结：</h3><ul>
<li>UseSerialGC ：虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old 的收集器组合进行内存回收</li>
<li>UseParNewGC: 打开此开关后使用ParNew+SerialOld的收集器组合进行内存回收</li>
<li>UseConcMarkSweepGC：打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收，Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用</li>
<li>UseparallelGC 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old (PS MarkSweep) 的收集器组合进行内存回收<br>UseParallelOldGC: 使用Parallel Scavenge+ Parallel Old的收集器组合进行内存回收</li>
</ul>
<h3 id="GC-相关参数总结"><a href="#GC-相关参数总结" class="headerlink" title="GC 相关参数总结"></a>GC 相关参数总结</h3><ul>
<li>与串行回收器相关的参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC:在新生代和老年代使用串行回收器。</span><br><span class="line">-XX:+SurvivorRatio:设置 eden 区大小和 survivor 区大小的比例。</span><br><span class="line">-XX:+PretenureSizeThreshold:设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。</span><br><span class="line">-XX:MaxTenuringThreshold:设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。</span><br></pre></td></tr></table></figure>
<ul>
<li>与并行 GC 相关的参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC: 在新生代使用并行收集器。</span><br><span class="line">-XX:+UseParallelOldGC: 老年代使用并行回收收集器。</span><br><span class="line">-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。</span><br><span class="line">-XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。</span><br><span class="line">-XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。</span><br><span class="line">-XX:+UseAdaptiveSizePolicy:打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</span><br></pre></td></tr></table></figure>
<ul>
<li>与 CMS 回收器相关的参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS+串行收集器。</span><br><span class="line">-XX:+ParallelCMSThreads: 设定 CMS 的线程数量。</span><br><span class="line">-XX:+CMSInitiatingOccupancyFraction:设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。</span><br><span class="line">-XX:+UseFullGCsBeforeCompaction:设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。</span><br><span class="line">-XX:+CMSClassUnloadingEnabled:允许对类元数据进行回收。</span><br><span class="line">-XX:+CMSParallelRemarkEndable:启用并行重标记。</span><br><span class="line">-XX:CMSInitatingPermOccupancyFraction:当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。</span><br><span class="line">-XX:UseCMSInitatingOccupancyOnly:表示只在到达阈值的时候，才进行 CMS 回收。</span><br><span class="line">-XX:+CMSIncrementalMode:使用增量模式，比较适合单 CPU。</span><br></pre></td></tr></table></figure>
<ul>
<li>与 G1 回收器相关的参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC：使用 G1 回收器。</span><br><span class="line">-XX:+UnlockExperimentalVMOptions:允许使用实验性参数。</span><br><span class="line">-XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间。</span><br><span class="line">-XX:+GCPauseIntervalMills:设置停顿间隔时间。</span><br></pre></td></tr></table></figure>
<ul>
<li>其他参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC: 禁用显示 GC。</span><br></pre></td></tr></table></figure>
<h3 id="JVM调优实战"><a href="#JVM调优实战" class="headerlink" title="JVM调优实战"></a>JVM调优实战</h3><p>除了Java堆和永久代之外还有以下区域还会占用较多的内存，这些内存总和受到操作系统进程最大内存的限制</p>
<ul>
<li>DirectMemory：可通过 -XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError 或者 OutOfMemoryError: Direct buffer memory.如果把系统大部分的内存都分配给了java堆，并且很长时间没有发生GC操作。那么DirectMemory可能会溢出。因为DirectMemory只是等待老年代满了之后FullGC，然后顺便帮它清理掉内存的废弃对象。否则就只能一直等到抛出内存溢出异常。</li>
<li>线程堆栈： 可通过-Xss调整大小，内存不足时抛出StackOverflowError</li>
<li>Socket 缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连续多的话这块内存也很可观。</li>
<li>JNI 代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</li>
<li>虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存</li>
</ul>
<ul>
<li>解读GC 日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 2017-10-15T16:02:33.567+0800: 790.871: [ParNew</span><br><span class="line">Desired survivor size 17432576 bytes, new threshold 6 (max 6)</span><br><span class="line">- age 1: 7619992 bytes, 7619992 total</span><br><span class="line">- age 2: 1081760 bytes, 8701752 total</span><br></pre></td></tr></table></figure>
<p>可以明显看出上述 GC 日志包含两次 Minor GC。 注意到第二次 Minor GC 的情况， 日志打出 “Desired survivor size 53673984 bytes”， 但是却存活了 “- age 1: 107256200 bytes, 107256200 total” 这么多。 可以看出明显的新生代的 Survivor 空间不足。正因为 Survivor 空间不足， 那么从 Eden 存活下来的和原来在 Survivor 空间中不够老的对象占满 Survivor 后， 就会提升到老年代， 可以看到这一轮 Minor GC 后老年代由原来的 0K 占用变成了 105782K 占用， 这属于一个典型的 JVM 内存问题， 称为 “premature promotion”(过早提升)。”premature promotion” 在短期看来不会有问题， 但是经常性的”premature promotion”， 最总会导致大量短期对象被提升到老年代， 最终导致老年代空间不足， 引发另一个 JVM 内存问题 “promotion failure”（提升失败： 即老年代空间不足以容乃 Minor GC 中提升上来的对象）。 “promotion failure” 发生就会让 JVM 进行一次 CMS 垃圾收集进而腾出空间接受新生代提升上来的对象， CMS 垃圾收集时间比 Minor GC 长， 导致吞吐量下降、 时延上升， 将对用户体验造成影响。</p>
<h3 id="Java什么情况下会报OutOfMemoryError"><a href="#Java什么情况下会报OutOfMemoryError" class="headerlink" title="Java什么情况下会报OutOfMemoryError"></a>Java什么情况下会报OutOfMemoryError</h3><ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StatckOverflowError异常；若果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</li>
<li>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样，在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</li>
<li>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</li>
<li>运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法在申请到内存时会抛出OutOfMemoryError异常。</li>
<li>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常的出现。在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native中来回复制数据。显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或分页文件)的大小及处理器寻址空间的限制。</li>
</ul>
<h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><ul>
<li>类加载的生命周期：加载—验证—准备—解析—初始化—使用—卸载</li>
<li><p>类初始化阶段：<br>是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说字节码）<br>在准备阶段，变量已经赋值锅系统要求的初始值，，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，从另一个方面表达：<br>初始化阶段是执行类构造器()方法的过程。<br>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在原文件中出现的顺序决定的。</p>
</li>
<li><p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">static&#123;</span><br><span class="line">i=0; //给变量赋值可以正常编译通过</span><br><span class="line">System.out.print(i); //这句编译器会提示“非法向前引用”</span><br><span class="line">&#125;</span><br><span class="line">static int i=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  () 方法与类的构造函数不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的clinit方法执行之前，父类的cinit方法已经执行完毕。因此在虚拟机中第一个被执行的cinit方法的类肯定是java.lang.object。由于父类的clinit方法先执行，也就意味着父类中定义的静态语句块要优先于子类变量赋值操作。比如如下B的值将会是2而不是1</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class Parent&#123;</span><br><span class="line">public static int A =1;</span><br><span class="line">	static &#123;</span><br><span class="line">	A =2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Sub extends Parent&#123;</span><br><span class="line">public static int B=A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">system.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>- 1）clinit 方法不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，也就没有必要为这个类生成clint方法。
- 2）接口中不能使用静态语句块，但仍然有变量初始化赋值操作，因此接口和类一样都会生成clinit方法。但接口与类不同的是，执行接口的clinit方法不需要先执行父接口的clinit方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口实现类在初始化时也一样不会执行接口的clinit方法
- 3）虚拟机保证一个类的clinit方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit方法，其他线程都需要阻塞等待，直到活动线程执行clinit方法完毕。同一个类加载器下，一个类型只会初始化一次
</code></pre><ul>
<li>类加载器<ul>
<li>1）用于实现类的加载动作.比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类就必定不相等。相等指的是 equals() isAssignableFrom()方法，isInstance()方法返回的结果。也包括使用instanceof关键字做对象所属关系判定等情况。</li>
<li>2）双亲委派模型<br>从Java虚拟机的角度，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器由C++实现，另一种就是所有其他的类加载器，由Java实现并且都继承自抽象类java.lang.ClassLoader</li>
<li>3）从开发人员的角度，类加载器还可以分更细：<ul>
<li>启动类加载器(Bootstrap ClassLoader)：负责加载Java_HOME\lib目录中的，或者被-Xbooclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。无法被java程序直接饮用。</li>
<li>扩展类加载器（Extension ClassLoader） 负责加载JAVA_HOME\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器</li>
<li>应用程序加载器（Application ClassLoader） 这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以也被称为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序没有自定义锅自己的类加载器，一般情况下这个就是程序中默认的类加载器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JIT-与Java10"><a href="#JIT-与Java10" class="headerlink" title="JIT 与Java10"></a>JIT 与Java10</h3><ul>
<li>Introduction:<ul>
<li>对于大部分应用开发者来说，Java编译器指的是JDK自带的javac指令。这一指令可将Java源程序编译成.class文件，其中包含的代码格式我们称之为Java bytecode（Java字节码）。这种代码格式无法直接运行，但可以被不同平台JVM中的interpreter解释执行。<em>由于interpreter效率低下，JVM中的JIT compiler（即时编译器）会在运行时有选择性地将运行次数较多的方法编译成二进制代码，直接运行在底层硬件上。</em>Oracle的HotSpot VM便附带两个用C++实现的JIT compiler：C1及C2。</li>
<li>与interpreter，GC等JVM的其他子系统相比，JIT compiler并不依赖于诸如直接内存访问的底层语言特性。它可以看成一个输入Java bytecode输出二进制码的黑盒，其实现方式取决于开发者对开发效率，可维护性等的要求。Graal是一个以Java为主要编程语言，面向Java bytecode的编译器。与用C++实现的C1及C2相比，它的模块化更加明显，也更加容易维护。Graal既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现AOT编译。在Java 10中，Graal作为试验性JIT compiler一同发布（JEP 317）。这篇文章将介绍Graal在动态编译上的应用。有关静态编译，可查阅JEP 295或Substrate VM。</li>
</ul>
</li>
<li>Tiered Compilation<ul>
<li>HotSpot中的tiered compilation<ul>
<li>JIT compiler — C1及C2（或称为Client及Server）<ul>
<li>前者没有应用激进的优化技术，因为这些优化往往伴随着耗时较长的代码分析。因此，C1的编译速度较快，而C2所编译的方法运行速度较快。在Java 7前，用户需根据自己的应用场景选择合适的JIT compiler。举例来说，针对偏好高启动性能的GUI用户端程序则使用C1，针对偏好高峰值性能的服务器端程序则使用C2。</li>
<li>Java 7引入了tiered compilation的概念，综合了C1的高启动性能及C2的高峰值性能。这两个JIT compiler以及interpreter将HotSpot的执行方式划分为五个级别：<ul>
<li>level 0：interpreter解释执行</li>
<li>level 1：C1编译，无profiling</li>
<li>level 2：C1编译，仅方法及循环back-edge执行次数的profiling</li>
<li>level 3：C1编译，除level 2中的profiling外还包括branch（针对分支跳转字节码）及receiver type（针对成员方法调用或类检测，如checkcast，instnaceof，aastore字节码）的profiling</li>
<li>level 4：C2编译。其中，1级和4级为接受状态 — 除非已编译的方法被invalidated（通常在deoptimization中触发），否则HotSpot不会再发出该方法的编译请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://ol7zjjc80.bkt.clouddn.com/271524552778_.pic.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2018/03/26/JVM知识总结/" data-id="cjoy15nhg002o1946v6qwxijp" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACPklEQVR42u3awY7CMAxFUf7/pzvSrEbqUO6zKSLO7QoJmuZ08UjsPB74On6vv5/P1/nb8whknPO9b7tkyJCxLIMM92xoMunrafGX8mJMGTJkbMAgIcunyKdy/crI+DJkyJBBps6ncj3FNOhlyJAho/ZIsoh8NtpH/zdkyJCxICMtopGH1Spjt+/FZciQsSCj1hj4zOfb+xsyZMj4esZRusiyst/+DOYjQ4aM0Qyy+ezn3h0lvAfvpsqQIWMDRj9wrwt2vMAXlNtkyJAxiFGbXPpt55gFek0yZMjYmPGuhkEtyoNlogwZMkYzatmVxivf4taKdDJkyJjNIEGWBigP0/TpT0eWIUPGaEbn0AMv5afBmjYhZMiQsQ8jXRTykOUbYB7KL/obMmTIGMrol/jTxV+8w+ZLQxkyZIxj8C1rGo58CcibmqiZKkOGjKEMEn8HvkiUk2ZDfBxEhgwZ4xj8IEUtv/vbV7JMlCFDxmxGGrXpcjANUB7BrX8MGTJkLMjghS0enTy+O4cwEEmGDBkjGLWlW7/QnxbgUDNAhgwZGzBIUKYtzM42NbhLhgwZoxm1G0izkx+2SOcTr3BlyJCxLOMIr7Q7yje36cGLYLctQ4aMxRm19VWniEYqf+RYWBrWMmTIWJ2RHvDqNxp5YyA45CFDhowNGLWQ5Yu2/iLvxXNlyJAhAy8HeVh3Wpj/zFmGDBky2ttUHtn8BcmQIWM3Ru3IRScieVlNhgwZMtLGAN+aXt+VHi/jv5chQ8Ygxg8/NmqYBAbbVAAAAABJRU5ErkJggg==" class="article-share-link">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/JVM/">JVM</a></div><div class="post-nav"><a href="/2018/04/24/okhttp-support-100-continue-for-palo/" class="pre">okhttp support 100-continue for palo</a><a href="/2017/10/31/kylin-query原理剖析/" class="next">kylin query原理剖析</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'https://jacobs-wanhb.disqus.com/embed.js';
var disqus_identifier = '2018/03/26/JVM知识总结/';
var disqus_title = 'JVM知识总结';
var disqus_url = 'http://yoursite.com/2018/03/26/JVM知识总结/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//https://jacobs-wanhb.disqus.com/embed.js.disqus.com/count.js" async></script></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yOTg3MC82NDM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/Hbase/" style="font-size: 15px;">Hbase</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/kylin/" style="font-size: 15px;">kylin</a> <a href="/tags/kylin-Java-源码/" style="font-size: 15px;">kylin - Java - 源码</a> <a href="/tags/superset/" style="font-size: 15px;">superset</a> <a href="/tags/二次开发/" style="font-size: 15px;">二次开发</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/成长/" style="font-size: 15px;">成长</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/infrastructure/" style="font-size: 15px;">infrastructure</a> <a href="/tags/data/" style="font-size: 15px;">data</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/ReentrantLock/" style="font-size: 15px;">ReentrantLock</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Crawler/" style="font-size: 15px;">Crawler</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/sqlGenerator/" style="font-size: 15px;">sqlGenerator</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/aop/" style="font-size: 15px;">aop</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/事务处理/" style="font-size: 15px;">事务处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/Spark学习笔记/">Spark实战总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/30/airflow实战总结/">airflow实战总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/12/impala集群搭建/">impala集群搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/okhttp-support-100-continue-for-palo/">okhttp support 100-continue for palo</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/26/JVM知识总结/">JVM知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/kylin-query原理剖析/">kylin query原理剖析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/superset-customization/">superset customization</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/23/lombok-builder-泛型擦除问题/">lombok builder 泛型擦除</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Kylin二次开发——测试环境搭建/">Kylin二次开发——测试环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/kylin-master-slave同步原理及问题排查/">kylin master-slave同步原理及问题排查</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//https://jacobs-wanhb.disqus.com/embed.js.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/chao-li-11/activities" title="知乎" target="_blank">知乎</a><ul></ul><a href="http://weibo.com/3101672623/profile?topnav=1&amp;wvr=6" title="微博" target="_blank">微博</a><ul></ul><a href="https://github.com/lichaojacobs" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">CHAO LI's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ca08f1c48fe3bf3d0e2bfb54473d985## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>